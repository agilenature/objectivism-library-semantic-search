---
phase: 14-batch-performance
plan: 03
type: execute
wave: 1
depends_on: []
files_modified: [benchmarks/bench_fsm.py]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "A --shared-connection flag exists in bench_fsm.py CLI"
    - "Running with --shared-connection uses a single aiosqlite connection for all workers instead of per-worker connections"
    - "A before/after comparison table shows baseline vs shared-connection P95 numbers side by side at c=10 zero profile"
    - "Mitigation results are saved to benchmarks/results-mitigation-*.json"
  artifacts:
    - path: "benchmarks/bench_fsm.py"
      provides: "--shared-connection flag and shared connection code path in run_benchmark()"
      contains: "shared.connection"
    - path: "benchmarks/results-mitigation-*.json"
      provides: "Mitigation benchmark results with before/after comparison data"
  key_links:
    - from: "benchmarks/bench_fsm.py --shared-connection"
      to: "aiosqlite shared connection"
      via: "single aiosqlite.connect() opened before workers, passed to all"
      pattern: "shared_conn"
---

<objective>
Close SC2 gap: add a `--shared-connection` mitigation to bench_fsm.py and run it at c=10 zero profile to produce before/after measurements.

Purpose: ROADMAP SC2 requires "at least one mitigation is tested... with before/after measurements." The baseline passed both thresholds (337x/66x margin), but no mitigation was actually coded or measured. This plan adds the simplest mitigation (shared persistent aiosqlite connection) and runs it to produce the before/after comparison.

Output: Modified bench_fsm.py with --shared-connection flag, results-mitigation-*.json with comparison data, Rich table showing before/after delta.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-batch-performance/14-CONTEXT.md
@.planning/phases/14-batch-performance/14-VERIFICATION.md
@.planning/phases/14-batch-performance/14-01-SUMMARY.md
@.planning/phases/14-batch-performance/14-02-SUMMARY.md
@benchmarks/bench_fsm.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add --shared-connection flag and shared connection code path to bench_fsm.py</name>
  <files>benchmarks/bench_fsm.py</files>
  <action>
Add a `--shared-connection` flag to the argparse CLI in `parse_args()`:
```python
parser.add_argument(
    "--shared-connection",
    action="store_true",
    help="Mitigation: share one aiosqlite connection across all workers (reduces WAL lock contention)",
)
```

Modify `run_benchmark()` to accept an optional `shared_conn: aiosqlite.Connection | None = None` parameter. When provided, workers use it instead of opening their own connection:

```python
async def run_benchmark(
    concurrency: int,
    profile: str,
    db_path: str,
    realistic_delay: float = 2.0,
    shared_conn: aiosqlite.Connection | None = None,
) -> list[dict[str, float]]:
    sem = asyncio.Semaphore(concurrency)

    async def worker(file_path: str, version: int) -> dict[str, float]:
        async with sem:
            if shared_conn is not None:
                mock = MockApiAdapter(profile, realistic_delay=realistic_delay)
                return await process_file(file_path, version, shared_conn, mock)
            else:
                async with aiosqlite.connect(db_path) as db:
                    await db.execute("PRAGMA journal_mode=WAL")
                    await db.execute("PRAGMA synchronous=NORMAL")
                    mock = MockApiAdapter(profile, realistic_delay=realistic_delay)
                    return await process_file(file_path, version, db, mock)

    tasks = [worker(f"/bench/file_{i:04d}.txt", 0) for i in range(FILE_COUNT)]
    results = await asyncio.gather(*tasks)
    return list(results)
```

In `main()`, after the existing 6-config run loop completes:

1. Check `if args.shared_connection:` -- if set, run ONE additional config: c=10, zero profile, with a shared connection.
2. Before the additional run, call `await reset_files(db_path)` to reset files to untracked.
3. Open a single shared connection: `async with aiosqlite.connect(db_path) as shared_db:` with WAL+NORMAL pragmas.
4. Pass `shared_conn=shared_db` to `run_benchmark()`.
5. Compute segment stats identically to the existing loop.
6. Print a Rich "Before vs After" comparison table showing the c=10 zero baseline P95 vs the shared-connection P95 for db_total_ms, lock_wait_ms, fsm_dispatch_ms, and fsm_net_ms.
7. Save results to `benchmarks/results-mitigation-{timestamp}.json` containing:
   - `baseline` key: the c=10 zero config from the standard run (already in `all_configs`)
   - `mitigation` key: the shared-connection run config
   - `comparison` key: a dict mapping segment names to `{baseline_p95, mitigation_p95, delta_ms, delta_pct}` for the four segments above.

The before/after Rich table should look like:
```
Before vs After: Shared Connection Mitigation (c=10, zero profile)
| Segment       | Baseline P95 | Mitigation P95 | Delta    |
| db_total_ms   | XX.XX ms     | YY.YY ms       | -ZZ.ZZ%  |
| lock_wait_ms  | XX.XX ms     | YY.YY ms       | -ZZ.ZZ%  |
| fsm_dispatch  | XX.XX ms     | YY.YY ms       | +ZZ.ZZ%  |
| fsm_net_ms    | XX.XX ms     | YY.YY ms       | -ZZ.ZZ%  |
```

Print this table using Rich after the existing results table and bottleneck output but before saving JSON.

Display the --shared-connection flag status in the header print block.

IMPORTANT: The shared connection approach serializes all DB writes through one connection. With c=10 and zero profile, this should significantly reduce lock_wait_ms because there is no cross-connection WAL lock contention -- all writes queue through one connection's internal serialization. Document this expected behavior in a comment.
  </action>
  <verify>
Run: `uv run python benchmarks/bench_fsm.py --quick --shared-connection`

Verify:
1. All 6 standard configs run and produce results (same as before)
2. A 7th "mitigation" config runs at c=10 zero with shared connection
3. All 818 files reach indexed state in the mitigation run
4. A before/after Rich table prints showing P95 comparison
5. A `benchmarks/results-mitigation-*.json` file is created with baseline, mitigation, and comparison keys
6. The lock_wait_ms P95 is lower (or at minimum different) in the mitigation run vs baseline

Also run: `uv run python benchmarks/bench_fsm.py --quick` (without --shared-connection)
Verify: Existing behavior unchanged -- no mitigation run occurs, no comparison table printed.
  </verify>
  <done>
bench_fsm.py has a --shared-connection flag. When used, it runs an additional c=10 zero benchmark with a single shared aiosqlite connection and prints a before/after P95 comparison table. Results saved to results-mitigation-*.json. Without the flag, existing behavior is unchanged. SC2 gap is closed: a mitigation was coded, executed, and measured with before/after numbers.
  </done>
</task>

</tasks>

<verification>
1. `uv run python benchmarks/bench_fsm.py --quick --shared-connection` completes without errors
2. All 818 files reach indexed state in all 7 runs (6 standard + 1 mitigation)
3. Before/after comparison table shows P95 values for db_total_ms, lock_wait_ms, fsm_dispatch_ms, fsm_net_ms
4. `benchmarks/results-mitigation-*.json` exists and contains baseline, mitigation, comparison keys
5. `uv run pytest tests/ -x -q` still passes all tests (benchmark changes don't affect production code)
6. `uv run python benchmarks/bench_fsm.py --quick` without --shared-connection shows identical behavior to pre-change
</verification>

<success_criteria>
- A coded mitigation (shared connection) is tested with a real benchmark run
- Before/after P95 measurements are reported in a Rich table and saved to JSON
- SC2 ("at least one mitigation is tested with before/after measurements") is satisfied
- No regression in existing benchmark behavior or test suite
</success_criteria>

<output>
After completion, create `.planning/phases/14-batch-performance/14-03-SUMMARY.md`
</output>
