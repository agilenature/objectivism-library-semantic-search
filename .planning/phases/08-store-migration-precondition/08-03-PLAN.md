---
phase: 08-store-migration-precondition
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/check_stability.py
autonomous: true

must_haves:
  truths:
    - "check_stability.py validates all 6 assertions independently using gemini_state='indexed' (not status='uploaded')"
    - "Assertions 5 and 6 vacuously pass when the store is empty (0 indexed files)"
    - "check_stability.py exits 0 (STABLE), 1 (UNSTABLE), or 2 (ERROR) with correct semantics"
    - "Passing --store objectivism-library-test after Phase 8 migration returns exit code 2 (store not found)"
    - "Passing --store objectivism-library with empty store returns exit code 0 (all assertions vacuously pass)"
  artifacts:
    - path: "scripts/check_stability.py"
      provides: "v2 stability instrument with FSM-aware assertions and 3-tier exit codes"
      min_lines: 300
      exports: ["StabilityChecker", "main"]
  key_links:
    - from: "scripts/check_stability.py"
      to: "data/library.db"
      via: "sqlite3 connection reading gemini_state column"
      pattern: "gemini_state.*indexed"
    - from: "scripts/check_stability.py"
      to: "Gemini File Search API"
      via: "genai.Client for store resolution and document listing"
      pattern: "file_search_stores"
    - from: "scripts/check_stability.py"
      to: "sys.exit"
      via: "exit code 0/1/2 based on prerequisite and assertion results"
      pattern: "sys\\.exit"
---

<objective>
Rewrite `scripts/check_stability.py` to be the v2 FSM-aware stability instrument that serves as the mandatory gate for all subsequent v2.0 waves.

Purpose: This instrument validates the Gemini-SQLite synchronization state after every wave. It must produce trustworthy, actionable exit codes (0/1/2) that can be used as automated gates. The v1 version checks `status='uploaded'`; v2 must check `gemini_state='indexed'`.

Output: Rewritten check_stability.py with 6 independent assertions, proper prerequisite checking, 3-tier exit codes, and vacuous pass logic for empty stores.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-store-migration-precondition/08-CONTEXT.md
@.planning/phases/08-store-migration-precondition/08-RESEARCH.md
@.planning/phases/08-store-migration-precondition/CLARIFICATIONS-ANSWERED.md
@scripts/check_stability.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite check_stability.py as v2 FSM-aware stability instrument</name>
  <files>scripts/check_stability.py</files>
  <action>
Rewrite `scripts/check_stability.py` preserving the overall structure (StabilityChecker class, argparse CLI, ANSI formatting) but updating all assertions to use FSM state columns and implementing the locked exit code semantics.

**Changes from v1 to v2:**

**1. Default store name:**
Change `DEFAULT_STORE = "objectivism-library-test"` to `DEFAULT_STORE = "objectivism-library"`.

**2. Prerequisites (_check_prerequisites method -- NEW):**
Before running any assertions, validate:
- DB file exists at `--db` path --> if not, print "ERROR: Database not found at {path}" to stderr, return exit 2
- DB has required columns: run `PRAGMA table_info(files)` and check that `gemini_state`, `gemini_store_doc_id`, `gemini_state_updated_at` all exist --> if missing, print "ERROR: Schema migration not applied. Run: python scripts/migrate_phase8.py" to stderr, return exit 2
- API key loadable from keyring --> if not, print existing error message, return exit 2
- Store resolves by display name --> if not found, print "ERROR: Store '{name}' not found. Available stores: [list]" to stderr, return exit 2. Catch both `google.api_core.exceptions.NotFound` and the generic case where list() returns no match.

The `run()` method should call `_check_prerequisites()` first. If it returns an exit code (2), return that immediately without running assertions.

**3. DB loading -- use gemini_state instead of status:**
Replace the `_load_db()` method. Instead of querying `status='uploaded'` and `gemini_file_id`, query:
```python
# Count of files in 'indexed' state (the FSM-tracked count)
indexed_count = conn.execute(
    "SELECT COUNT(*) FROM files WHERE gemini_state = 'indexed'"
).fetchone()[0]

# Canonical store doc IDs for indexed files
rows = conn.execute(
    "SELECT gemini_store_doc_id FROM files "
    "WHERE gemini_state = 'indexed' AND gemini_store_doc_id IS NOT NULL"
).fetchall()
canonical_doc_ids = {row[0] for row in rows}

# Status counts (for check 4 -- stuck transitions)
status_rows = conn.execute(
    "SELECT gemini_state, COUNT(*) AS n FROM files GROUP BY gemini_state"
).fetchall()
state_counts = {r[0]: r[1] for r in status_rows}
```

Return `(indexed_count, canonical_doc_ids, state_counts)`.

**4. Assertion 1 -- Count invariant:**
```python
def _check_count(self, indexed_count: int, store_doc_count: int) -> None:
    if indexed_count == store_doc_count:
        self._pass("Assertion 1 -- Count invariant",
                   f"DB indexed={indexed_count}, store docs={store_doc_count}")
    else:
        delta = store_doc_count - indexed_count
        direction = f"{delta} orphaned in store" if delta > 0 else f"{abs(delta)} ghosts in DB"
        self._fail("Assertion 1 -- Count invariant",
                   f"DB indexed={indexed_count} != store docs={store_doc_count} ({direction})")
```

**5. Assertion 2 -- DB-to-Store ghosts:**
For every file with `gemini_state='indexed'`, its `gemini_store_doc_id` must match a store document.
- If indexed_count == 0: vacuous pass "N/A -- 0 indexed files"
- Otherwise: compare `canonical_doc_ids` against store document names
```python
def _check_db_to_store(self, canonical_doc_ids: set[str], store_doc_names: set[str]) -> None:
    if not canonical_doc_ids:
        self._pass("Assertion 2 -- DB->Store (no ghosts)", "N/A -- 0 indexed files")
        return
    ghosts = canonical_doc_ids - store_doc_names
    if not ghosts:
        self._pass("Assertion 2 -- DB->Store (no ghosts)",
                   f"all {len(canonical_doc_ids)} indexed files present in store")
    else:
        self._fail("Assertion 2 -- DB->Store (ghost records)",
                   f"{len(ghosts)} files with gemini_state='indexed' but no store document")
```

**6. Assertion 3 -- Store-to-DB orphans:**
Every store document must have a matching `gemini_store_doc_id` in the DB.
- If store is empty (0 docs): vacuous pass "N/A -- store is empty"
- Otherwise: compare store document names against `canonical_doc_ids`
```python
def _check_store_to_db(self, canonical_doc_ids: set[str], store_doc_names: set[str]) -> None:
    if not store_doc_names:
        self._pass("Assertion 3 -- Store->DB (no orphans)", "N/A -- store is empty (0 documents)")
        return
    orphans = store_doc_names - canonical_doc_ids
    if not orphans:
        self._pass("Assertion 3 -- Store->DB (no orphans)",
                   f"all {len(store_doc_names)} store docs match DB records")
    else:
        sample = sorted(orphans)[:5]
        self._fail("Assertion 3 -- Store->DB (orphaned store docs)",
                   f"{len(orphans)} store docs have no matching DB record. Sample: {sample}")
```

**7. Assertion 4 -- Stuck transitions:**
Check `gemini_state='uploading'` count (not `status='uploading'`).
```python
def _check_stuck(self, state_counts: dict[str, int]) -> None:
    stuck = state_counts.get("uploading", 0)
    if stuck == 0:
        self._pass("Assertion 4 -- No stuck transitions", "0 files in 'uploading' state")
    else:
        self._fail("Assertion 4 -- Stuck transitions",
                   f"{stuck} files stuck in gemini_state='uploading'")
    # Non-blocking warning for 'failed' state
    failed = state_counts.get("failed", 0)
    if failed > 0:
        self._warn("Assertion 4b -- Failed files",
                   f"{failed} files with gemini_state='failed'")
```

**8. Assertion 5 -- Search returns results (vacuous pass on empty store):**
Per locked decision Q1: if indexed_count == 0, vacuous pass.
```python
def _check_search_results(self, indexed_count: int) -> list | None:
    if indexed_count == 0:
        self._pass("Assertion 5 -- Search returns results",
                   "N/A -- store is empty (0 indexed files)")
        return None  # Signal to skip assertion 6
    # Otherwise, run actual search (keep existing search logic from v1)
    try:
        response = self.client.models.generate_content(
            model=SEARCH_MODEL,
            contents=self.sample_query,
            config=genai_types.GenerateContentConfig(
                tools=[genai_types.Tool(
                    file_search=genai_types.ToolFileSearch(
                        file_search_store=self.store_resource_name
                    )
                )]
            ),
        )
        # Extract citations from grounding metadata
        citations = []
        if response.candidates:
            gm = getattr(response.candidates[0], "grounding_metadata", None)
            if gm:
                chunks = getattr(gm, "grounding_chunks", []) or []
                for chunk in chunks:
                    rc = getattr(chunk, "retrieved_context", None)
                    if rc:
                        citations.append(rc)
        if not citations:
            self._fail("Assertion 5 -- Search returns results",
                       "0 citations returned for sample query (store has indexed files)")
            return None
        self._pass("Assertion 5 -- Search returns results",
                   f"{len(citations)} citations returned")
        return citations
    except Exception as e:
        self._fail("Assertion 5 -- Search returns results", f"Exception: {e}")
        return None
```

Import `google.genai.types` as `genai_types` at the top of the file for `GenerateContentConfig`, `Tool`, `ToolFileSearch`.

**9. Assertion 6 -- Citation resolution (vacuous pass if assertion 5 was vacuous):**
If assertion 5 returned None (either vacuous or failed), skip assertion 6 with vacuous pass if indexed_count == 0, or skip silently if assertion 5 failed.
```python
def _check_citation_resolution(self, citations: list | None, indexed_count: int) -> None:
    if indexed_count == 0:
        self._pass("Assertion 6 -- Citation resolution",
                   "N/A -- store is empty (0 indexed files)")
        return
    if citations is None:
        # Assertion 5 failed -- can't check citation resolution
        return
    # Check each citation resolves to a DB record
    conn = sqlite3.connect(self.db_path)
    unresolved = []
    for citation in citations:
        title = getattr(citation, "title", "") or ""
        # A resolved citation has a filename extension
        if "." in title:
            continue
        # Try to look up by gemini_store_doc_id or gemini_file_id
        uri = getattr(citation, "uri", "") or ""
        # Check if title (which might be a file ID) exists in DB
        row = conn.execute(
            "SELECT filename FROM files WHERE gemini_store_doc_id = ? OR gemini_file_id = ?",
            (title, f"files/{title}"),
        ).fetchone()
        if not row:
            unresolved.append(title or "<empty>")
    conn.close()
    if unresolved:
        self._fail("Assertion 6 -- Citation resolution",
                   f"{len(unresolved)}/{len(citations)} citations unresolvable: {unresolved}")
    else:
        self._pass("Assertion 6 -- Citation resolution",
                   f"all {len(citations)} citations resolve to DB records")
```

**10. Updated run() method flow:**
```python
async def run(self) -> int:
    # Print header
    # ...
    # Step 0: Prerequisites
    prereq_result = self._check_prerequisites()
    if prereq_result is not None:
        return prereq_result  # Exit 2

    # Step 1: Load DB (using gemini_state)
    db_result = self._load_db()
    if db_result is None:
        return 2
    indexed_count, canonical_doc_ids, state_counts = db_result

    # Step 2: List store documents
    store_docs = await self._list_store_docs()
    if store_docs is None:
        return 2
    store_doc_names = {getattr(doc, "name", "") for doc in store_docs}

    # Step 3: Structural assertions
    self._check_count(indexed_count, len(store_docs))
    self._check_db_to_store(canonical_doc_ids, store_doc_names)
    self._check_store_to_db(canonical_doc_ids, store_doc_names)
    self._check_stuck(state_counts)

    # Step 4: Search + citation assertions
    citations = self._check_search_results(indexed_count)
    self._check_citation_resolution(citations, indexed_count)

    # Step 5: Verdict
    # ... (keep existing verdict logic)
    return 0 if not self.failed else 1
```

**11. Make _check_search_results and _check_citation_resolution use SYNC API calls** since the rest of the script already mixes sync and async. Keep `_list_store_docs` async (it already is). For search, use `self.client.models.generate_content()` (sync) not `self.client.aio.models.generate_content()`. This avoids adding more async complexity.

**12. Remove the v1 dependency on `objlib.search.client` and `objlib.search.citations`** for assertions 5 and 6. The v2 script should use the raw genai SDK directly for search and citation extraction. This makes the stability instrument independent of the application's search layer -- important since the search layer may evolve while the instrument must remain stable.

**13. Keep the `main()` function's `if __name__ == '__main__': sys.exit(main())` pattern with `asyncio.run()` inside main.**

**Overall structure:**
```
#!/usr/bin/env python3
"""docstring with exit code table"""

imports
constants (DEFAULT_STORE="objectivism-library", DEFAULT_DB, DEFAULT_QUERY, SEARCH_MODEL)
ANSI formatting helpers

class StabilityChecker:
    __init__(api_key, store_display_name, db_path, sample_query, verbose)
    _pass / _fail / _warn / _verbose helpers
    _check_prerequisites() -> int | None  # NEW
    _resolve_store() -> bool  # updated
    _load_db() -> tuple | None  # rewritten for gemini_state
    _list_store_docs() -> list | None  # keep async
    _check_count(indexed_count, store_doc_count)  # updated
    _check_db_to_store(canonical_doc_ids, store_doc_names)  # rewritten
    _check_store_to_db(canonical_doc_ids, store_doc_names)  # rewritten
    _check_stuck(state_counts)  # updated for gemini_state
    _check_search_results(indexed_count) -> list | None  # vacuous pass logic
    _check_citation_resolution(citations, indexed_count)  # vacuous pass + rewritten
    run() -> int  # updated flow

def main() -> int:
    parser setup
    keyring lookup
    StabilityChecker instantiation
    return asyncio.run(checker.run())

if __name__ == '__main__':
    sys.exit(main())
```
  </action>
  <verify>
1. Syntax check: `python -c "import ast; ast.parse(open('scripts/check_stability.py').read()); print('Syntax OK')"`

2. Test with current store (objectivism-library-test still exists at this point -- 08-02 hasn't run yet):
   `python scripts/check_stability.py --store objectivism-library-test --verbose`
   Expected behavior: The store resolves, but the DB now has `gemini_state='untracked'` (after 08-01 migration) so indexed_count=0. Store still has ~2,038 docs. Assertion 1 should FAIL (0 != 2038). Exit code 1 (UNSTABLE). This is correct -- the system IS unstable (DB reset but store not yet migrated).

3. Test with non-existent store:
   `python scripts/check_stability.py --store nonexistent-store-name`
   Expected: "ERROR: Store 'nonexistent-store-name' not found" and exit code 2.

4. Test with missing DB:
   `python scripts/check_stability.py --store objectivism-library-test --db /nonexistent/path.db`
   Expected: "ERROR: Database not found" and exit code 2.

5. Verify exit codes programmatically:
   ```bash
   python scripts/check_stability.py --store nonexistent-store-name; echo "Exit: $?"
   ```
   Expected: "Exit: 2"
  </verify>
  <done>
check_stability.py v2 is operational with:
- All 6 assertions using gemini_state='indexed' instead of status='uploaded'
- Prerequisite checks producing exit 2 for configuration errors
- Vacuous pass logic for assertions 5 and 6 on empty stores
- Independence from objlib search layer (uses raw genai SDK)
- Correct exit codes: 0=STABLE, 1=UNSTABLE, 2=ERROR
  </done>
</task>

<task type="auto">
  <name>Task 2: Add gemini_state column prerequisite check</name>
  <files>scripts/check_stability.py</files>
  <action>
Ensure the `_check_prerequisites()` method includes a specific check for the new schema columns. This is part of the STAB-03 requirement: if the schema migration hasn't been run, the instrument must exit 2 with a clear message, not crash with a confusing SQL error.

The check (already described in Task 1's action under prerequisites point 2):
```python
def _check_prerequisites(self) -> int | None:
    """Return exit code 2 if prerequisites fail, None if all pass."""
    # Check DB exists
    if not Path(self.db_path).exists():
        print(f"ERROR: Database not found at {self.db_path}", file=sys.stderr)
        return 2

    # Check schema has required columns
    try:
        conn = sqlite3.connect(self.db_path)
        cols = {row[1] for row in conn.execute("PRAGMA table_info(files)")}
        conn.close()
        required = {"gemini_state", "gemini_store_doc_id", "gemini_state_updated_at"}
        missing = required - cols
        if missing:
            print(f"ERROR: Schema migration not applied. Missing columns: {missing}", file=sys.stderr)
            print("Run: python scripts/migrate_phase8.py", file=sys.stderr)
            return 2
    except Exception as e:
        print(f"ERROR: Cannot read database schema: {e}", file=sys.stderr)
        return 2

    # Check API key
    if not self.api_key:
        print("ERROR: No API key provided", file=sys.stderr)
        return 2

    return None  # All prerequisites pass
```

This task exists as a separate verification step to ensure the prerequisite check is thorough. If Task 1 already includes this code inline, this task confirms it works and adds any missing edge cases (e.g., DB file exists but is corrupt, columns exist but have wrong types).

Also verify that `_resolve_store()` returns the correct error handling: if the store is not found, it should trigger exit 2 (not exit 1). In the v1 code, store resolution failure calls `self._fail()` which would make it exit 1 (UNSTABLE). In v2, store not found is a PREREQUISITE failure = exit 2. Move store resolution into `_check_prerequisites()` or ensure the `run()` method treats store resolution failure as exit 2.
  </action>
  <verify>
1. Create a test database without V9 columns to verify prerequisite detection:
   ```bash
   python -c "
   import sqlite3, tempfile, os
   db = tempfile.NamedTemporaryFile(suffix='.db', delete=False)
   db.close()
   c = sqlite3.connect(db.name)
   c.execute('CREATE TABLE files (file_path TEXT PRIMARY KEY, status TEXT)')
   c.execute('PRAGMA user_version = 8')
   c.close()
   os.system(f'python scripts/check_stability.py --store objectivism-library --db {db.name}; echo Exit: \$?')
   os.unlink(db.name)
   "
   ```
   Expected: "ERROR: Schema migration not applied. Missing columns: ..." and "Exit: 2"

2. Verify store resolution failure produces exit 2:
   `python scripts/check_stability.py --store definitely-does-not-exist; echo "Exit: $?"`
   Expected: Exit 2 (not exit 1).
  </verify>
  <done>
Prerequisite checks correctly identify missing schema, missing API key, missing DB, and missing store -- all produce exit code 2 (ERROR), not exit code 1 (UNSTABLE). The instrument is safe to run before, during, or after any Phase 8 step.
  </done>
</task>

</tasks>

<verification>
1. `python scripts/check_stability.py --store objectivism-library-test --verbose` exits 1 (UNSTABLE) when DB has been reset but old store still has documents -- correct behavior
2. `python scripts/check_stability.py --store nonexistent` exits 2 (ERROR)
3. `python scripts/check_stability.py --db /nonexistent` exits 2 (ERROR)
4. After 08-02 runs (store migration): `python scripts/check_stability.py --store objectivism-library` exits 0 (STABLE) with all assertions vacuously passing on empty store
5. `python scripts/check_stability.py --store objectivism-library-test` exits 2 (store deleted by 08-02)
</verification>

<success_criteria>
- All 6 assertions use gemini_state='indexed' (not status='uploaded')
- Prerequisites produce exit 2 for all configuration errors
- Vacuous pass on empty store: assertions 1-6 all pass when indexed_count=0 and store has 0 docs
- Store not found produces exit 2 (STAB-03)
- Script is standalone (no dependency on objlib CLI or Typer)
- Exit codes: 0=STABLE, 1=UNSTABLE, 2=ERROR -- formally correct per Q6 locked decision
</success_criteria>

<output>
After completion, create `.planning/phases/08-store-migration-precondition/08-03-SUMMARY.md`
</output>
