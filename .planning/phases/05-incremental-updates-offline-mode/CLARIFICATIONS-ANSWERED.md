# CLARIFICATIONS-ANSWERED.md

## Phase 5: Incremental Updates & Offline Mode ‚Äî Stakeholder Decisions

**Generated:** 2026-02-18
**Mode:** YOLO (balanced strategy ‚Äî synthesis recommendations auto-selected)
**Source:** Auto-generated by discuss-phase-ai --yolo

---

## Decision Summary

**Total questions:** 13
**Tier 1 (Blocking):** 6 answered
**Tier 2 (Important):** 5 answered
**Tier 3 (Polish):** 2 answered

---

## Tier 1: Blocking Decisions

### Q1: Sync Atomicity ‚Äî Upload-First Strategy

**YOLO DECISION: Option A ‚Äî Upload-first with orphaned ID tracking**

- Upload NEW file first ‚Üí get `new_gemini_file_id`
- Update SQLite: set `gemini_file_id = new_gemini_file_id`, store old ID in `orphaned_gemini_file_id`
- Attempt deletion of old ID ‚Äî if fails/404, log warning; `orphaned_gemini_file_id` remains for cleanup
- Add `sync --cleanup-orphans` for deferred orphan deletion pass
- On startup: any file with `orphaned_gemini_file_id != NULL` is cleaned up automatically

**Rationale:** ‚úÖ Consensus from all 3 providers. Upload-first guarantees no coverage gap. Deletion failures are non-critical because old entry still returns valid (if stale) results.

**Sub-decisions:**
- Gemini duplicate display_name: **Test during implementation; assume allowed, handle 400 gracefully**
- Orphan cleanup timing: **Automatic on each sync startup (cleanup pass before main sync loop)**

---

### Q2: Disk Availability ‚Äî Multi-Layer Mount Check

**YOLO DECISION: Multi-layer check (`isdir` + `listdir`), orphan cleanup blocked unless `available`**

```python
def check_disk_availability(library_root: str) -> Literal['available', 'unavailable', 'degraded']:
    mount_point = "/Volumes/U32 Shadow"
    if not os.path.isdir(mount_point):
        return 'unavailable'
    try:
        os.listdir(mount_point)
    except OSError:
        return 'unavailable'
    if not os.path.isdir(library_root):
        return 'degraded'  # Volume mounted but library path missing
    return 'available'
```

- `sync`/`scan`/`upload` fail fast with actionable error when `unavailable`
- Orphan detection (missing file ‚Üí Gemini deletion) ONLY runs when `available`
- Library root path: **store in SQLite `library_config` table** for cross-session consistency

**Rationale:** ‚úÖ Consensus from all 3 providers. Critical safety measure ‚Äî prevents mass index deletion from transient disconnects.

---

### Q3: Sync Pipeline ‚Äî Enriched by Default

**YOLO DECISION: Option A ‚Äî Always enriched, with `--skip-enrichment` escape hatch**

- `sync` reuses `EnrichedUploadOrchestrator` from Phase 6.2
- Changed files get full AI metadata injection on re-upload
- Add `--skip-enrichment` flag for emergency fast sync (uses Phase 2 simple pipeline)
- If AI metadata extraction fails for a changed file: **fall back to raw upload** (log warning, don't skip)

**Rationale:** ‚úÖ Consensus from OpenAI + Gemini. Library files change rarely; enrichment cost on changed files is negligible. Consistent index quality outweighs occasional sync latency.

---

### Q4: Orphan Deletion Policy ‚Äî Mark-First, Explicit Delete

**YOLO DECISION: Mark as `missing`, never auto-delete, require `--prune-missing` flag**

- First detection of absent file: set `status='missing'`, record `missing_since = now()`
- Gemini deletion NEVER happens automatically during regular sync
- User runs `sync --prune-missing` to explicitly delete `missing` files from Gemini
- Add `sync --dry-run` to preview what would be pruned without executing
- Default age threshold for `--prune-missing` auto-mode: **7 days** (configurable)

**Rationale:** ‚úÖ Consensus from OpenAI + Perplexity. Safety over aggressiveness. Explicit flag prevents accidental data loss.

---

### Q5: Partial Sync Failure ‚Äî Per-File SQLite Commits (Phase 2 Pattern)

**YOLO DECISION: Reuse existing per-file commit pattern; errors continue batch with report**

- SQLite committed immediately after each successfully processed file (unchanged from Phase 2)
- On restart: files with `status='indexed'` + same `content_hash` + same `enrichment_version` are skipped
- Files with `status='pending_upload'` or `status='error'` are retried
- Processing errors: mark `status='error'`, continue to next file, report errors in summary at end
- Max retries per file: **3** (with exponential backoff, consistent with Phase 2 circuit breaker)

**Rationale:** ‚úÖ Consensus from all 3 providers. Proven pattern from Phase 2 upload pipeline. No new infrastructure needed.

---

### Q6: Gemini 48-Hour TTL ‚Äî Store-Level Deletion, 404 = Success

**YOLO DECISION: Use store-document deletion API; wrap in try/except; 404 treated as success**

```python
def delete_from_store(file_id: str, store_name: str, client) -> None:
    """Delete a file from the File Search Store. 404 = already gone = acceptable."""
    try:
        client.delete_file_from_store(store_name=store_name, file_id=file_id)
    except NotFound:
        pass  # Raw file expired (48h TTL) or already deleted ‚Äî acceptable outcome
```

- Always use store-level deletion, not raw file deletion
- During implementation: **test whether raw file TTL expiry auto-removes store entry**
- If google-genai SDK lacks separate store-delete method, use `files.delete()` with same 404 handling

**Rationale:** ‚úÖ Consensus from all 3 providers. Idempotent deletion prevents unnecessary failures.

---

## Tier 2: Important Decisions

### Q7: File Identity ‚Äî Path-Based, Rename = Delete+Add

**YOLO DECISION: Existing absolute path as primary key; rename treated as delete+add**

- No changes to file identity scheme
- Rename/move ‚Üí old record becomes `missing`, new record created as `pending_upload`
- Document in CLI help: "Renamed files will be re-indexed"

**Rationale:** ‚ö†Ô∏è 2 providers agreed. Simplest implementation. Library files rarely renamed.

---

### Q8: Hash Strategy ‚Äî Source Hash + Upload Hash + Enrichment Version

**YOLO DECISION: Three-column tracking for complete change detection**

Schema additions:
- Keep existing `content_hash` as `source_hash` (rename for clarity OR add new column)
- Add `upload_hash` = SHA-256 of enriched bytes actually sent to Gemini
- Add `enrichment_version` = short hash of (prompt template + model name + injection schema version)

Sync re-uploads a file if ANY of these differ from stored values:
1. `source_hash` (raw file content changed)
2. `enrichment_version` (enrichment config changed since last upload)

`upload_hash` stored for debugging/verification only (not used in change detection).

**Rationale:** ‚ö†Ô∏è 2 providers recommended. Enables accurate change detection when enrichment evolves.

---

### Q9: Offline Metadata ‚Äî Verify SQLite `metadata_json` Sufficiency

**YOLO DECISION: Verify during implementation; if gap found, populate SQLite in migration**

- Assumption: Phase 6 stored extracted AI metadata in `metadata_json` column
- `view` (metadata-only mode) should already read from SQLite, not Gemini
- During Phase 5 planning: **verify `view` command reads from SQLite for metadata display**
- If metadata gap found: add schema migration to backfill from Phase 6 extraction data

**Rationale:** ‚ö†Ô∏è 2 providers flagged as potential blocker. Needs verification, not necessarily implementation.

---

### Q10: Offline Scope ‚Äî Disk-Offline Only for Phase 5

**YOLO DECISION: Phase 5 = disk-offline only; network-offline handled by existing error paths**

- "Offline mode" is explicitly defined as: USB drive not connected, internet/Gemini available
- CLI help and error messages will use "disk offline" not "offline mode" to avoid confusion
- Network-offline behavior: existing Gemini API error handling already covers this (fail with error)
- No new network-offline graceful degradation in Phase 5

**Rationale:** ‚ö†Ô∏è 2 providers recommended scoping to disk-offline. Keeps Phase 5 focused.

---

### Q11: mtime Hybrid Optimization ‚Äî Implement

**YOLO DECISION: Implement mtime+hash hybrid for sync performance**

Schema addition: `mtime` column (float, filesystem modification timestamp)

Sync logic:
```python
if file.mtime == db_record.mtime:
    continue  # Assume unchanged ‚Äî skip hash computation
else:
    new_hash = sha256(file.content)
    if new_hash == db_record.source_hash:
        db_record.mtime = file.mtime  # Touch only
    else:
        mark_for_reupload(file)  # Content changed
```

**Rationale:** ‚ö†Ô∏è Gemini recommended. Low implementation cost, meaningful performance improvement for USB I/O.

---

## Tier 3: Polish Decisions

### Q12: Enrichment Configuration Versioning ‚Äî Implement

**YOLO DECISION: Add `enrichment_version` column (as decided in Q8)**

- `enrichment_version` = `sha256(prompt_template + model_name + schema_version)[:8]`
- Stored in SQLite per-file; updated when enrichment re-runs
- Sync re-uploads if `enrichment_version` differs from current app's enrichment config version

**Rationale:** üîç 1 provider recommended. Low cost, high value for long-term maintenance.

---

### Q13: Gemini Store Consistency Guard ‚Äî Implement

**YOLO DECISION: Store `gemini_store_name` in SQLite `library_config` table**

- New table: `library_config (key TEXT PRIMARY KEY, value TEXT)`
- On first `upload`/`sync`: store `gemini_store_name` in config table
- On subsequent `upload`/`sync`: verify CLI store name matches stored name
- If mismatch: fail with error: `"Store mismatch: CLI configured '{}' but SQLite records '{}'. Use --allow-store-mismatch to override."`

**Rationale:** üîç 1 provider recommended. High safety value for minimal cost.

---

## Implementation Priorities for Planning

**Must implement in Phase 5:**
1. `sync` command with change detection (new/modified/deleted)
2. Upload-first atomicity with orphaned ID tracking
3. Disk availability check (`check_disk_availability()`)
4. Mark-missing policy (never auto-delete from Gemini)
5. Offline mode guard for `scan`/`upload`/`sync` commands
6. OFFL-01/02/03: verify existing commands work without disk
7. mtime+hash hybrid optimization
8. `--prune-missing` and `--dry-run` flags
9. `--force` flag (re-process all files)
10. `--skip-enrichment` flag

**Schema changes needed:**
- Add `mtime` column to files table (schema V7 migration)
- Add `orphaned_gemini_file_id` column to files table
- Add `missing_since` column to files table
- Add `upload_hash` column to files table
- Add `enrichment_version` column to files table
- Add `library_config` table (key/value store)

---

## Next Steps

1. ‚úÖ Clarifications answered (YOLO mode ‚Äî balanced strategy)
2. ‚è≠ Proceed to `/gsd:plan-phase 5`
3. üìã Human review of YOLO decisions recommended before implementation begins

---

*Auto-generated by discuss-phase-ai --yolo (balanced strategy)*
*Human review recommended before final implementation*
*Generated: 2026-02-18*
