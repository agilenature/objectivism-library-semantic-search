---
phase: 05-incremental-updates-offline-mode
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/objlib/upload/client.py
autonomous: true

must_haves:
  truths:
    - "GeminiFileSearchClient can delete a document from a File Search store (not just the raw file)"
    - "GeminiFileSearchClient can list all documents in a File Search store"
    - "GeminiFileSearchClient can find the store document name given a gemini_file_id"
    - "404/NOT_FOUND on store document deletion is treated as success (not exception)"
  artifacts:
    - path: "src/objlib/upload/client.py"
      provides: "delete_store_document, list_store_documents, find_store_document_name methods"
      contains: "file_search_stores.documents"
  key_links:
    - from: "src/objlib/upload/client.py"
      to: "Gemini File Search Store Documents API"
      via: "client.aio.file_search_stores.documents.delete/list"
      pattern: "file_search_stores\\.documents\\.(delete|list)"
---

<objective>
Add Gemini File Search Store document management methods to GeminiFileSearchClient.

Purpose: The existing delete_file() method only deletes the temporary raw File (48hr TTL), NOT the indexed store entry. For sync to clean up orphaned entries and prune missing files from the search index, we need store-level document deletion. This is the critical API gap identified in research.

Output: Updated GeminiFileSearchClient with delete_store_document(), list_store_documents(), and find_store_document_name() methods.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/objlib/upload/client.py
@.planning/phases/05-incremental-updates-offline-mode/05-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add store document management methods to GeminiFileSearchClient</name>
  <files>src/objlib/upload/client.py</files>
  <action>
Add three new methods to the GeminiFileSearchClient class, placed after the existing `delete_file` method and before the `build_custom_metadata` static method.

**Method 1: delete_store_document()**
```python
async def delete_store_document(self, document_name: str) -> bool:
    """Delete an indexed document from the File Search store.

    CRITICAL: Unlike delete_file() which deletes the temporary raw File
    (48hr TTL), this removes the INDEXED content that persists indefinitely
    in the search store. Per locked decision #6, 404 = success.

    Args:
        document_name: Full resource name, e.g.
            'fileSearchStores/abc123/documents/doc456'

    Returns:
        True if deleted (or already gone), False on unexpected error.
    """
    try:
        await self._safe_call(
            self._client.aio.file_search_stores.documents.delete,
            name=document_name,
        )
        logger.info("Deleted store document: %s", document_name)
        return True
    except Exception as exc:
        # 404 = document already gone (TTL expiry or prior cleanup) -- acceptable per decision #6
        exc_str = str(exc)
        if "404" in exc_str or "NOT_FOUND" in exc_str or "not found" in exc_str.lower():
            logger.info("Store document already deleted (404): %s", document_name)
            return True
        logger.error("Failed to delete store document %s: %s", document_name, exc)
        return False
```

**Method 2: list_store_documents()**
```python
async def list_store_documents(self, store_name: str | None = None) -> list[Any]:
    """List all documents in a File Search store.

    Used to discover document resource names for deletion, since
    import_file() does not return the document resource name.

    Args:
        store_name: Store resource name (e.g. 'fileSearchStores/abc123').
            Uses self.store_name if not provided.

    Returns:
        List of document objects from the Gemini API.

    Raises:
        RuntimeError: If no store_name available.
    """
    parent = store_name or self.store_name
    if not parent:
        raise RuntimeError("store_name not set -- call get_or_create_store() first")

    documents = []
    try:
        result = await self._client.aio.file_search_stores.documents.list(
            parent=parent
        )
        async for doc in result:
            documents.append(doc)
    except Exception as exc:
        logger.error("Failed to list store documents for %s: %s", parent, exc)
        raise
    logger.info("Listed %d documents in store %s", len(documents), parent)
    return documents
```

**Method 3: find_store_document_name()**
```python
async def find_store_document_name(
    self, gemini_file_id: str, store_name: str | None = None
) -> str | None:
    """Find the store document resource name for a given file ID.

    The Gemini API does not directly map file IDs to document names.
    This method lists all documents and finds the one matching the
    given file ID by inspecting document attributes.

    Args:
        gemini_file_id: Gemini file resource name (e.g. 'files/xyz789').
        store_name: Optional override for store resource name.

    Returns:
        Full document resource name (e.g. 'fileSearchStores/abc/documents/def')
        or None if not found.
    """
    documents = await self.list_store_documents(store_name)
    # Normalize the file ID for comparison
    normalized_id = gemini_file_id
    if not normalized_id.startswith("files/"):
        normalized_id = f"files/{normalized_id}"

    for doc in documents:
        # Check common attribute names where the file reference might be stored
        # The exact attribute depends on the SDK version -- try multiple
        for attr in ("file_name", "source_file", "name", "display_name"):
            val = getattr(doc, attr, None)
            if val and normalized_id in str(val):
                return doc.name if hasattr(doc, "name") else str(doc)

        # Also check if the document name itself contains the file ID suffix
        doc_name = getattr(doc, "name", "")
        file_id_suffix = normalized_id.replace("files/", "")
        if file_id_suffix and file_id_suffix in doc_name:
            return doc_name

    logger.warning(
        "Could not find store document for file %s in store %s",
        gemini_file_id,
        store_name or self.store_name,
    )
    return None
```

**IMPORTANT NOTES:**
- The `_safe_call` wrapper already handles circuit breaker integration for all API calls.
- The list_store_documents may need to handle pagination if the SDK's async iterator handles it automatically (the google-genai SDK typically auto-paginates async iterators).
- The find_store_document_name method is necessarily a scan (O(n)) because the Gemini API doesn't provide a direct lookup. For the Objectivism Library (~1,749 files), this is acceptable.
- Do NOT remove the existing delete_file() method -- it's still used by the enriched upload pipeline for raw file cleanup before re-upload.
- Add a docstring note to delete_file() warning that it only deletes the raw file, not the indexed store entry, and pointing to delete_store_document() for store cleanup.
  </action>
  <verify>
Run: `python -c "from objlib.upload.client import GeminiFileSearchClient; print('Methods:', [m for m in dir(GeminiFileSearchClient) if 'store_document' in m or 'list_store' in m])"` -- should show delete_store_document, find_store_document_name, list_store_documents.

Run: `python -c "import inspect; from objlib.upload.client import GeminiFileSearchClient; sig = inspect.signature(GeminiFileSearchClient.delete_store_document); print('delete_store_document params:', list(sig.parameters)); sig2 = inspect.signature(GeminiFileSearchClient.list_store_documents); print('list_store_documents params:', list(sig2.parameters))"` -- should show correct parameter names.

Run: `python -c "from objlib.upload.client import GeminiFileSearchClient; help(GeminiFileSearchClient.delete_file)"` -- should show updated docstring with warning about raw file vs store entry.
  </verify>
  <done>
GeminiFileSearchClient has three new methods: delete_store_document() (with 404=success handling per locked decision #6), list_store_documents() (async pagination), find_store_document_name() (scan-based lookup). Existing delete_file() retains backward compatibility with added docstring clarification.
  </done>
</task>

</tasks>

<verification>
- `python -c "from objlib.upload.client import GeminiFileSearchClient; assert hasattr(GeminiFileSearchClient, 'delete_store_document'); assert hasattr(GeminiFileSearchClient, 'list_store_documents'); assert hasattr(GeminiFileSearchClient, 'find_store_document_name'); print('PASS: all methods exist')"`
- `python -c "import inspect; from objlib.upload.client import GeminiFileSearchClient; src = inspect.getsource(GeminiFileSearchClient.delete_store_document); assert '404' in src; assert 'NOT_FOUND' in src; print('PASS: 404 handling present')"`
- `python -c "import inspect; from objlib.upload.client import GeminiFileSearchClient; src = inspect.getsource(GeminiFileSearchClient.delete_file); assert 'store entry' in src.lower() or 'store document' in src.lower(); print('PASS: delete_file docstring updated')"`
</verification>

<success_criteria>
1. delete_store_document() uses file_search_stores.documents.delete (NOT files.delete)
2. 404/NOT_FOUND on deletion returns True (not exception) per locked decision #6
3. list_store_documents() returns all documents via async iteration
4. find_store_document_name() can locate document name from gemini_file_id
5. Existing delete_file() method unchanged (backward compatible)
6. All methods integrate with _safe_call for circuit breaker protection
</success_criteria>

<output>
After completion, create `.planning/phases/05-incremental-updates-offline-mode/05-02-SUMMARY.md`
</output>
