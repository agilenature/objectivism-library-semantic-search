---
phase: 05-incremental-updates-offline-mode
plan: 04
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/objlib/cli.py
autonomous: true

must_haves:
  truths:
    - "search/browse/filter/view work without source disk connected (OFFL-01)"
    - "view --full gracefully degrades to metadata-only with clear messaging when disk disconnected (OFFL-02)"
    - "scan command fails with clear actionable error when disk disconnected (OFFL-03)"
    - "upload command fails with clear actionable error when disk disconnected (OFFL-03)"
    - "enriched-upload command fails with clear actionable error when disk disconnected"
    - "Error messages include disk path and resolution steps"
  artifacts:
    - path: "src/objlib/cli.py"
      provides: "Disk availability guards on scan/upload/enriched-upload, improved view --full messaging"
      contains: "check_disk_availability"
  key_links:
    - from: "src/objlib/cli.py"
      to: "src/objlib/sync/disk.py"
      via: "import check_disk_availability, disk_error_message"
      pattern: "from objlib\\.sync\\.disk import"
---

<objective>
Add offline mode guards to existing CLI commands: disk availability checks on scan/upload/enriched-upload, and improved messaging for view --full when disk is disconnected.

Purpose: Ensures OFFL-01 (query commands work without disk), OFFL-02 (view gracefully degrades), and OFFL-03 (maintenance commands fail with actionable errors). The query commands (search, browse, filter, view metadata-only) already work offline since they use Gemini API + SQLite -- this plan verifies that and adds explicit guards where needed.

Output: Updated cli.py with disk availability checks on scan/upload/enriched-upload commands and improved view --full offline messaging.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-incremental-updates-offline-mode/05-01-SUMMARY.md
@src/objlib/cli.py
@src/objlib/sync/disk.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add disk availability guards to scan, upload, and enriched-upload commands</name>
  <files>src/objlib/cli.py</files>
  <action>
Import `check_disk_availability` and `disk_error_message` from `objlib.sync.disk` at the top of cli.py (near other imports from objlib).

**Add DEFAULT_LIBRARY_ROOT constant** near the top of cli.py:
```python
DEFAULT_LIBRARY_ROOT = "/Volumes/U32 Shadow/Objectivism Library"
DEFAULT_MOUNT_POINT = "/Volumes/U32 Shadow"
```

**Modify the `scan` command** (around line 186 where `config.library_path.exists()` is checked):

Replace the existing path existence check with a disk availability check:

```python
# Check disk availability before filesystem operations (OFFL-03)
from objlib.sync.disk import check_disk_availability, disk_error_message

availability = check_disk_availability(str(config.library_path))
if availability != "available":
    msg = disk_error_message(availability, str(config.library_path), "scan")
    console.print(f"[red]Error:[/red] {msg}")
    raise typer.Exit(code=1)
```

Place this BEFORE the existing `if not config.library_path.exists()` check. Keep the existing `.exists()` and `.is_dir()` checks as fallbacks for non-standard library paths (user might use a local directory).

Actually -- better approach: Add the disk check ONLY when the library path starts with `/Volumes/` (i.e., it's an external drive). For local paths, keep the existing simple `.exists()` check. This avoids breaking local development usage.

```python
library_str = str(config.library_path)
if library_str.startswith("/Volumes/"):
    from objlib.sync.disk import check_disk_availability, disk_error_message
    availability = check_disk_availability(library_str)
    if availability != "available":
        msg = disk_error_message(availability, library_str, "scan")
        console.print(f"[red]Error:[/red] {msg}")
        raise typer.Exit(code=1)
else:
    # Existing checks for local paths
    if not config.library_path.exists():
        console.print(f"[red]Error:[/red] Library path does not exist: {config.library_path}")
        raise typer.Exit(code=1)
    if not config.library_path.is_dir():
        console.print(f"[red]Error:[/red] Library path is not a directory: {config.library_path}")
        raise typer.Exit(code=1)
```

**Modify the `upload` command:**
The upload command reads file content from disk paths stored in the database to upload to Gemini, so it requires disk access. Add a disk guard at the start of the upload command function:

```python
# Check if library disk is available (files are read from disk for upload)
from objlib.sync.disk import check_disk_availability, disk_error_message
# Check using the default library mount point
availability = check_disk_availability(DEFAULT_LIBRARY_ROOT)
if availability != "available":
    msg = disk_error_message(availability, DEFAULT_LIBRARY_ROOT, "upload")
    console.print(f"[red]Error:[/red] {msg}")
    raise typer.Exit(code=1)
```

**Modify the `enriched_upload` command:**
Same disk guard as upload -- it reads file content from disk paths stored in DB.

```python
from objlib.sync.disk import check_disk_availability, disk_error_message
availability = check_disk_availability(DEFAULT_LIBRARY_ROOT)
if availability != "available":
    msg = disk_error_message(availability, DEFAULT_LIBRARY_ROOT, "enriched-upload")
    console.print(f"[red]Error:[/red] {msg}")
    raise typer.Exit(code=1)
```

**Improve `view --full` messaging (OFFL-02):**
Find the section where `view --full` handles missing source file (around line 1086-1088). The current message is:
```python
console.print(
    f"[yellow]Warning:[/yellow] Source file not found on disk: {file_path}\n"
```

Improve this to be more specific about disk availability:
```python
from objlib.sync.disk import check_disk_availability
availability = check_disk_availability(DEFAULT_LIBRARY_ROOT)
if availability != "available":
    console.print(
        f"[yellow]Source disk not connected.[/yellow] Full document text requires "
        f"the library disk at [dim]{DEFAULT_MOUNT_POINT}[/dim].\n"
        f"Showing metadata only. Connect the disk and retry with [bold]--full[/bold]."
    )
else:
    console.print(
        f"[yellow]Warning:[/yellow] Source file not found on disk: [dim]{file_path}[/dim]"
    )
```

This distinguishes between "disk disconnected" (user action: connect disk) and "file actually deleted" (different issue).

**Verify OFFL-01 (query commands work without disk):**
The following commands already work without disk because they only use Gemini API + SQLite:
- `search`: Uses Gemini File Search API (network only)
- `browse`: Reads from SQLite metadata_json
- `filter`: Reads from SQLite metadata_json
- `view` (without --full): Reads from SQLite metadata_json

No changes needed for these commands. They don't access the filesystem at all.

The `view` command with `--show-related` uses the Gemini API (network), not disk.

**IMPORTANT:** Use lazy imports (inside functions) for `from objlib.sync.disk import ...` to avoid import overhead for commands that don't need it. The sync module may not exist when running commands in an older installation.
  </action>
  <verify>
Run: `python -m objlib scan --help` -- should show help (no import error from sync module).

Run: `python -m objlib upload --help` -- should show help.

Run: `python -m objlib view --help` -- should show help.

If disk disconnected:
- `python -m objlib scan --library "/Volumes/U32 Shadow/Objectivism Library" --db data/library.db` should show clear error "Library disk not connected" with resolution steps.
- `python -m objlib upload --db data/library.db` should show clear error about disk.

If disk connected (or local path):
- `python -m objlib scan --library /tmp/test-lib --db data/library.db` should use existing path checks (not disk availability).

Test view offline messaging:
- `python -m objlib view "Introduction to Objectivism.txt" --full --db data/library.db` -- if disk disconnected, should show "Source disk not connected" message (not crash).
  </verify>
  <done>
scan/upload/enriched-upload commands fail fast with actionable error when library disk is unavailable (OFFL-03). view --full shows "Source disk not connected" with guidance when disk unavailable, metadata-only view still works (OFFL-02). search/browse/filter/view (metadata-only) continue to work without disk (OFFL-01 verified). Error messages include specific path and resolution steps.
  </done>
</task>

</tasks>

<verification>
- `python -m objlib scan --help` shows help without errors
- `python -m objlib upload --help` shows help without errors
- `python -m objlib view --help` shows help without errors
- `python -c "from objlib.sync.disk import check_disk_availability; print(check_disk_availability('/nonexistent'))"` returns 'unavailable'
- With disk disconnected: `python -m objlib scan --library "/Volumes/U32 Shadow/Objectivism Library"` shows "Library disk not connected" error
- With disk disconnected: `python -m objlib --store objectivism-library-test search "test"` still works (Gemini API, no disk needed) -- or shows API error, not disk error
- `python -m objlib browse --db data/library.db` works without disk (SQLite only)
- `python -m objlib filter --category course --db data/library.db` works without disk
</verification>

<success_criteria>
1. scan fails fast with "Library disk not connected" when disk unavailable
2. upload fails fast with "Library disk not connected" when disk unavailable
3. enriched-upload fails fast with "Library disk not connected" when disk unavailable
4. view --full shows "Source disk not connected" with metadata fallback when disk unavailable
5. search/browse/filter/view (metadata) work normally without disk
6. Error messages include expected mount path (/Volumes/U32 Shadow) and resolution steps
7. Local path usage (not /Volumes/) uses existing path checks (no regression)
8. All --help commands work without import errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-incremental-updates-offline-mode/05-04-SUMMARY.md`
</output>
