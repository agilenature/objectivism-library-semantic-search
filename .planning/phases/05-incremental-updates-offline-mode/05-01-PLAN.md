---
phase: 05-incremental-updates-offline-mode
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/objlib/database.py
  - src/objlib/models.py
  - src/objlib/sync/__init__.py
  - src/objlib/sync/disk.py
autonomous: true

must_haves:
  truths:
    - "SQLite schema is V7 with expanded CHECK constraint allowing 'missing' and 'error' status values"
    - "files table has mtime, orphaned_gemini_file_id, missing_since, upload_hash, enrichment_version columns"
    - "library_config table exists and can store/retrieve key-value pairs"
    - "check_disk_availability() returns 'available', 'unavailable', or 'degraded' based on mount status"
    - "FileStatus enum includes MISSING and ERROR values"
    - "Database methods exist for new sync operations (mark_missing, get_missing_files, get_orphaned_files, store/verify config)"
  artifacts:
    - path: "src/objlib/database.py"
      provides: "V7 migration SQL, new sync query methods, library_config CRUD"
      contains: "MIGRATION_V7_SQL"
    - path: "src/objlib/models.py"
      provides: "MISSING and ERROR FileStatus enum values"
      contains: "MISSING"
    - path: "src/objlib/sync/disk.py"
      provides: "check_disk_availability function"
      exports: ["check_disk_availability"]
    - path: "src/objlib/sync/__init__.py"
      provides: "sync module public API"
  key_links:
    - from: "src/objlib/database.py"
      to: "data/library.db"
      via: "MIGRATION_V7_SQL executescript"
      pattern: "MIGRATION_V7_SQL"
    - from: "src/objlib/sync/disk.py"
      to: "/Volumes/U32 Shadow"
      via: "os.path.isdir + os.listdir"
      pattern: "check_disk_availability"
---

<objective>
Schema V7 migration, new sync-related database methods, disk availability utility, and FileStatus enum updates.

Purpose: Foundation for all sync and offline operations. The V7 migration is the critical prerequisite because the existing CHECK constraint blocks new status values ('missing', 'error'), and all other plans depend on these columns and methods.

Output: Updated database.py with V7 migration, new sync query methods, updated models.py with new FileStatus values, new src/objlib/sync/ module with disk availability check.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/objlib/database.py
@src/objlib/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema V7 migration with table rebuild and new FileStatus values</name>
  <files>src/objlib/database.py, src/objlib/models.py</files>
  <action>
**In src/objlib/models.py:**
Add two new values to the FileStatus enum:
- `MISSING = "missing"` (files deleted from disk but Gemini entry preserved)
- `ERROR = "error"` (sync-specific errors like disk read failure)

**In src/objlib/database.py:**
Add `MIGRATION_V7_SQL` constant with the table-rebuild approach (SQLite cannot ALTER CHECK constraints). The migration must:

1. Create `files_v7` table with ALL existing columns from V1-V6 PLUS these new columns:
   - `mtime REAL` (filesystem modification timestamp for mtime+hash hybrid)
   - `orphaned_gemini_file_id TEXT` (old Gemini ID pending cleanup after upload-first replace)
   - `missing_since TEXT` (ISO 8601 timestamp when file first detected as absent)
   - `upload_hash TEXT` (SHA-256 of enriched bytes actually uploaded to Gemini)
   - `enrichment_version TEXT` (short hash of enrichment config, e.g. 8-char hex)

2. Expand the CHECK constraint on status to: `('pending', 'uploading', 'uploaded', 'failed', 'skipped', 'LOCAL_DELETE', 'missing', 'error')`

3. Copy all existing data from `files` into `files_v7` (new columns get NULL defaults)

4. Drop `files` table, rename `files_v7` to `files`

5. Recreate ALL indexes: `idx_content_hash`, `idx_status`, `idx_metadata_quality`

6. Recreate ALL triggers: `update_files_timestamp`, `log_status_change`

7. Create `library_config` table:
   ```sql
   CREATE TABLE IF NOT EXISTS library_config (
       key TEXT PRIMARY KEY,
       value TEXT,
       updated_at TEXT DEFAULT (strftime('%Y-%m-%dT%H:%M:%f', 'now'))
   );
   ```

In `_setup_schema()`, add a `if version < 7:` block after the `if version < 6:` block that runs `self.conn.executescript(MIGRATION_V7_SQL)`. Update the final `PRAGMA user_version` to 7.

**IMPORTANT:** The INSERT INTO files_v7 SELECT must enumerate ALL columns explicitly and add `NULL, NULL, NULL, NULL, NULL` for the 5 new V7 columns. Count existing columns carefully from the current schema: file_path, content_hash, filename, file_size, metadata_json, metadata_quality, status, error_message, gemini_file_uri, gemini_file_id, upload_timestamp, remote_expiration_ts, embedding_model_version, created_at, updated_at, ai_metadata_status, ai_confidence_score, entity_extraction_version, entity_extraction_status, upload_attempt_count, last_upload_hash = 21 columns.

Add new Database methods for sync operations:

- `mark_missing(file_paths: set[str]) -> None`: Set status='missing' and missing_since=now() for the given paths. Only mark files that aren't already 'missing' (avoid resetting missing_since).

- `get_missing_files(min_age_days: int | None = None) -> list[dict]`: Return files with status='missing'. If min_age_days provided, filter to files where missing_since is older than N days. Return dicts with file_path, filename, gemini_file_id, missing_since.

- `get_orphaned_files() -> list[dict]`: Return files where orphaned_gemini_file_id IS NOT NULL. Return dicts with file_path, orphaned_gemini_file_id.

- `clear_orphan(file_path: str) -> None`: Set orphaned_gemini_file_id = NULL for the given file.

- `set_library_config(key: str, value: str) -> None`: INSERT OR REPLACE into library_config.

- `get_library_config(key: str) -> str | None`: SELECT value from library_config WHERE key = ?.

- `update_file_sync_columns(file_path: str, **kwargs) -> None`: Update arbitrary sync columns (mtime, upload_hash, enrichment_version, orphaned_gemini_file_id, missing_since) on a file record. Uses the same pattern as update_file_status but without changing status.

- `get_file_with_sync_data(file_path: str) -> dict | None`: Return a single file record including mtime, content_hash, upload_hash, enrichment_version, gemini_file_id, status. Used by sync detector.

- `get_all_active_files_with_mtime() -> dict[str, tuple[str, int, float | None]]`: Like get_all_active_files but returns {file_path: (content_hash, file_size, mtime)}. Used by sync change detection with mtime optimization.
  </action>
  <verify>
Run: `python -c "from objlib.database import Database; db = Database('data/library.db'); print('V7 OK, version:', db.conn.execute('PRAGMA user_version').fetchone()[0])"` -- should print "V7 OK, version: 7".

Run: `python -c "from objlib.database import Database; db = Database('data/library.db'); db.conn.execute(\"UPDATE files SET status='missing' WHERE 1=0\"); print('CHECK constraint OK')"` -- should succeed (no IntegrityError).

Run: `python -c "from objlib.database import Database; db = Database('data/library.db'); db.set_library_config('test_key', 'test_val'); print(db.get_library_config('test_key'))"` -- should print "test_val".

Run: `python -c "from objlib.models import FileStatus; print(FileStatus.MISSING.value, FileStatus.ERROR.value)"` -- should print "missing error".
  </verify>
  <done>
Schema V7 migration runs idempotently. files table has 5 new columns and expanded CHECK constraint. library_config table exists. All new Database methods are callable. FileStatus enum has MISSING and ERROR values. Existing data is preserved (no data loss during table rebuild).
  </done>
</task>

<task type="auto">
  <name>Task 2: Disk availability check and sync module skeleton</name>
  <files>src/objlib/sync/__init__.py, src/objlib/sync/disk.py</files>
  <action>
Create new `src/objlib/sync/` package.

**src/objlib/sync/__init__.py:**
```python
"""Incremental sync pipeline for the Objectivism Library."""
from objlib.sync.disk import check_disk_availability

__all__ = ["check_disk_availability"]
```

**src/objlib/sync/disk.py:**
Implement the locked decision #2 disk availability check exactly as specified:

```python
import os
from typing import Literal

def check_disk_availability(
    library_root: str,
    mount_point: str = "/Volumes/U32 Shadow",
) -> Literal["available", "unavailable", "degraded"]:
    """Check if the library disk is accessible.

    Per locked decision #2, uses multi-layer mount check:
    1. Verify mount_point is a directory (os.path.isdir)
    2. Verify mount_point is accessible (os.listdir)
    3. Verify library_root exists within mount (os.path.isdir)

    Returns:
        'available' -- disk mounted and library path exists
        'unavailable' -- disk not mounted or inaccessible
        'degraded' -- disk mounted but library_root not found
    """
    if not os.path.isdir(mount_point):
        return "unavailable"
    try:
        os.listdir(mount_point)
    except OSError:
        return "unavailable"
    if not os.path.isdir(library_root):
        return "degraded"
    return "available"
```

Also add a helper function for generating user-facing error messages:

```python
def disk_error_message(
    availability: Literal["available", "unavailable", "degraded"],
    library_root: str,
    command: str,
) -> str | None:
    """Return a user-facing error message for disk unavailability, or None if available."""
    if availability == "available":
        return None
    if availability == "unavailable":
        return (
            f"Library disk not connected.\n"
            f"  Expected mount: /Volumes/U32 Shadow\n"
            f"  Action: Connect the USB drive and try '{command}' again."
        )
    # degraded
    return (
        f"Library disk is mounted but library path not found.\n"
        f"  Expected: {library_root}\n"
        f"  Action: Verify the library directory exists on the mounted drive."
    )
```

Make mount_point configurable (parameter with default) so tests can use a temp dir.
  </action>
  <verify>
Run: `python -c "from objlib.sync.disk import check_disk_availability; print(check_disk_availability('/nonexistent/path'))"` -- should print "unavailable".

Run: `python -c "from objlib.sync.disk import check_disk_availability, disk_error_message; msg = disk_error_message('unavailable', '/foo', 'sync'); print(msg)"` -- should print actionable error message.

Run: `python -c "from objlib.sync import check_disk_availability; print('import OK')"` -- should print "import OK".
  </verify>
  <done>
src/objlib/sync/ package exists with check_disk_availability() and disk_error_message() functions. check_disk_availability returns correct Literal type for all three states. disk_error_message provides clear, actionable user guidance.
  </done>
</task>

</tasks>

<verification>
- `python -c "from objlib.database import Database; db = Database('data/library.db'); v = db.conn.execute('PRAGMA user_version').fetchone()[0]; assert v == 7, f'Expected 7, got {v}'; print('PASS: schema V7')"`
- `python -c "from objlib.models import FileStatus; assert hasattr(FileStatus, 'MISSING'); assert hasattr(FileStatus, 'ERROR'); print('PASS: FileStatus')"`
- `python -c "from objlib.sync.disk import check_disk_availability; print('PASS: sync module')"`
- `python -c "from objlib.database import Database; db = Database('data/library.db'); cols = [r[1] for r in db.conn.execute('PRAGMA table_info(files)').fetchall()]; assert 'mtime' in cols; assert 'orphaned_gemini_file_id' in cols; assert 'missing_since' in cols; assert 'upload_hash' in cols; assert 'enrichment_version' in cols; print('PASS: V7 columns')"`
- `python -c "from objlib.database import Database; db = Database('data/library.db'); row = db.conn.execute('SELECT COUNT(*) FROM files').fetchone(); print(f'PASS: {row[0]} files preserved after migration')"`
</verification>

<success_criteria>
1. Schema V7 migration runs without data loss on existing database with 1,902 files
2. New status values 'missing' and 'error' accepted by CHECK constraint
3. All 5 new columns exist on files table
4. library_config table created and functional
5. All new Database methods callable and return expected types
6. check_disk_availability() returns correct state for mounted/unmounted/degraded scenarios
7. FileStatus enum has MISSING and ERROR members
</success_criteria>

<output>
After completion, create `.planning/phases/05-incremental-updates-offline-mode/05-01-SUMMARY.md`
</output>
