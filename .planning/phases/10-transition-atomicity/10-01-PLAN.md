---
phase: 10-transition-atomicity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - spike/phase10_spike/__init__.py
  - spike/phase10_spike/db.py
  - spike/phase10_spike/exceptions.py
  - spike/phase10_spike/states.py
  - spike/phase10_spike/safe_delete.py
  - spike/phase10_spike/transition_reset.py
  - spike/phase10_spike/tests/__init__.py
  - spike/phase10_spike/tests/conftest.py
  - spike/phase10_spike/tests/test_safe_delete.py
  - spike/phase10_spike/tests/test_crash_points.py
autonomous: true

must_haves:
  truths:
    - "A file in 'indexed' state with Gemini IDs can be reset to 'untracked' with both remote resources deleted"
    - "If the process crashes after delete_store_document but before delete_file, the DB records exactly which step completed (intent_api_calls_completed=1)"
    - "If the process crashes after both API calls but before Txn B finalizes, the DB records intent_api_calls_completed=2 with gemini_state still 'indexed'"
    - "If Txn B itself fails, the DB is in the same state as crash point 2 (api_calls_completed=2, state still 'indexed')"
    - "safe_delete wrappers treat 404 as success and re-raise all other errors"
  artifacts:
    - path: "spike/phase10_spike/db.py"
      provides: "Extended schema with intent columns + gemini ID columns, init_spike_db(), read helpers"
      contains: "intent_type TEXT"
    - path: "spike/phase10_spike/states.py"
      provides: "Extended FSM class with reset and retry transitions, NO final=True on indexed or failed"
      contains: "reset = indexed.to(untracked)"
    - path: "spike/phase10_spike/safe_delete.py"
      provides: "safe_delete_store_document() and safe_delete_file() wrappers"
      contains: "exc.code == 404"
    - path: "spike/phase10_spike/transition_reset.py"
      provides: "ResetTransitionManager with Txn A, safe_delete API calls, progress tracking, Txn B"
      contains: "execute_reset"
    - path: "spike/phase10_spike/tests/test_crash_points.py"
      provides: "3 crash point tests proving partial state is recoverable"
      min_lines: 80
    - path: "spike/phase10_spike/tests/test_safe_delete.py"
      provides: "safe_delete wrapper tests (404=success, other errors re-raise)"
      min_lines: 30
  key_links:
    - from: "spike/phase10_spike/transition_reset.py"
      to: "spike/phase10_spike/db.py"
      via: "write_intent(), update_progress(), finalize_reset()"
      pattern: "write_intent|update_progress|finalize_reset"
    - from: "spike/phase10_spike/transition_reset.py"
      to: "spike/phase10_spike/safe_delete.py"
      via: "safe_delete_store_document(), safe_delete_file()"
      pattern: "safe_delete_store_document|safe_delete_file"
    - from: "spike/phase10_spike/tests/test_crash_points.py"
      to: "spike/phase10_spike/transition_reset.py"
      via: "ResetTransitionManager.execute_reset() with mock injection"
      pattern: "ResetTransitionManager"
---

<objective>
Build the write-ahead intent pattern for the two-API-call reset transition (INDEXED -> UNTRACKED) with crash simulation tests proving every crash point leaves recoverable partial state.

Purpose: This is the core transition atomicity mechanism for Phase 10. The reset transition involves two sequential API calls (delete_store_document, delete_file) followed by a DB finalize. If the process crashes at any point, the write-ahead intent columns record exactly how far the transition got, enabling deterministic recovery (Plan 10-02).

Output: Extended spike DB schema, modified FSM (no final states), safe_delete wrappers, ResetTransitionManager, and 3 crash point tests demonstrating recoverable partial state.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-transition-atomicity/10-CONTEXT.md
@.planning/phases/10-transition-atomicity/10-RESEARCH.md
@.planning/phases/09-async-fsm-spike/09-02-SUMMARY.md

# Phase 9 spike code (patterns to extend, not modify)
@spike/phase9_spike/db.py
@spike/phase9_spike/states.py
@spike/phase9_spike/exceptions.py
@spike/phase9_spike/integration/scaffold.py
@spike/phase9_spike/adapters/statemachine_adapter.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Spike infrastructure -- extended DB schema, FSM states, safe_delete wrappers</name>
  <files>
    spike/phase10_spike/__init__.py
    spike/phase10_spike/db.py
    spike/phase10_spike/exceptions.py
    spike/phase10_spike/states.py
    spike/phase10_spike/safe_delete.py
    spike/phase10_spike/tests/__init__.py
    spike/phase10_spike/tests/conftest.py
    spike/phase10_spike/tests/test_safe_delete.py
  </files>
  <action>
    Create spike/phase10_spike/ directory structure. Import and reuse FileLockManager from spike.phase9_spike.integration.scaffold. Copy and extend db.py, states.py, exceptions.py from Phase 9 (do NOT modify Phase 9 code).

    **db.py** -- Extended schema with 5 new columns beyond Phase 9:
    - `gemini_file_id TEXT` -- raw file resource name (e.g., "files/abc123")
    - `gemini_store_doc_id TEXT` -- store document resource name
    - `intent_type TEXT` -- NULL or 'reset_intent' (GA-1)
    - `intent_started_at TEXT` -- ISO timestamp (GA-1)
    - `intent_api_calls_completed INTEGER` -- 0, 1, or 2 (GA-1)
    - Add `CREATE INDEX IF NOT EXISTS idx_intent ON files(intent_type)` for recovery scan
    - Provide helper functions: `init_spike_db()`, `read_file_state()` (returns gemini_state, version), `read_file_full()` (returns all columns as dict), `write_intent()` (Txn A per GA-6: UPDATE WHERE gemini_state='indexed' AND version=?, sets intent columns, NO version increment), `update_progress()` (simple UPDATE intent_api_calls_completed, no OCC), `finalize_reset()` (Txn B per GA-6: UPDATE WHERE version=? AND intent_type='reset_intent', sets gemini_state='untracked', clears gemini_file_id/gemini_store_doc_id/intent columns, increments version)
    - Each write function opens a fresh aiosqlite connection with WAL mode + BEGIN IMMEDIATE (same pattern as Phase 9 execute_with_retry)
    - `write_intent()` and `finalize_reset()` return bool (True if rowcount==1, False if OCC conflict)

    **states.py** -- Extended FSM class with Phase 10 transitions:
    - Copy FileLifecycleSM from Phase 9 adapter but REMOVE `final=True` from both `indexed` and `failed` states (CRITICAL -- python-statemachine raises InvalidDefinition if final states have outgoing transitions)
    - Add three new transitions: `reset = indexed.to(untracked)` (GA-7), `retry = failed.to(untracked)` (GA-4), `fail_reset = indexed.to(failed)` (for reset failures)
    - Update VALID_EDGES and EVENTS dicts to include new transitions
    - Keep async guard `cond_not_stale` and `on_enter_state` from Phase 9

    **exceptions.py** -- Reuse Phase 9 exceptions. Add `ResetCrashError(Exception)` if needed for crash point classification, but prefer reusing existing exception types.

    **safe_delete.py** -- Two idempotent delete wrapper functions (GA-2):
    - `async def safe_delete_store_document(delete_fn: Callable, document_name: str) -> bool` -- calls delete_fn(document_name), catches `google.genai.errors.ClientError` where `exc.code == 404` and returns True (idempotent success), re-raises all other exceptions
    - `async def safe_delete_file(delete_fn: Callable, file_name: str) -> bool` -- same pattern for raw file deletion
    - Import: `from google.genai import errors as genai_errors` (verified in 10-RESEARCH.md as the correct import path for google-genai 1.63.0)
    - Both functions return True on success (including 404)

    **tests/conftest.py** -- Shared fixtures:
    - `spike_db` fixture: creates temp file, calls init_spike_db(), yields path, cleans up (including -wal, -shm files)
    - `seed_indexed_file` fixture (factory): inserts a file with gemini_state='indexed', version=5, gemini_file_id='files/test123', gemini_store_doc_id='fileSearchStores/store1/documents/doc1'
    - `seed_failed_file` fixture (factory): inserts a file with gemini_state='failed', version=3

    **tests/test_safe_delete.py** -- 4 tests:
    1. `test_safe_delete_store_doc_success` -- delete_fn returns normally, wrapper returns True
    2. `test_safe_delete_store_doc_404_is_success` -- delete_fn raises ClientError with code=404, wrapper returns True
    3. `test_safe_delete_store_doc_other_error_propagates` -- delete_fn raises ClientError with code=403, wrapper re-raises
    4. `test_safe_delete_file_404_is_success` -- same pattern for file deletion
    - For mocking `google.genai.errors.ClientError`: create the exception manually. Research confirms the constructor accepts `(status_code, response=None, message=None)` or similar. If the constructor is problematic to instantiate directly, create a mock object with a `.code` attribute set to 404. The test must verify `exc.code == 404` is the exact check used.
  </action>
  <verify>
    Run: `python -m pytest spike/phase10_spike/tests/test_safe_delete.py -v`
    All 4 tests pass. No import errors.
    Run: `python -c "from spike.phase10_spike.db import init_spike_db; print('OK')"` -- confirms schema module loads
    Run: `python -c "from spike.phase10_spike.states import FileLifecycleSM; sm = FileLifecycleSM(); print('FSM created, states:', [s.value for s in sm.states])"` -- confirms FSM loads without InvalidDefinition error and indexed/failed are NOT final
  </verify>
  <done>
    - spike/phase10_spike/db.py: init_spike_db creates table with all 11 columns; write_intent/update_progress/finalize_reset implement GA-6 two-transaction pattern
    - spike/phase10_spike/states.py: FileLifecycleSM has 5 states (none final), 8 transitions including reset/retry/fail_reset
    - spike/phase10_spike/safe_delete.py: Both wrappers catch ClientError with code==404 as success
    - 4 safe_delete tests pass
    - conftest.py provides spike_db, seed_indexed_file, seed_failed_file fixtures
  </done>
</task>

<task type="auto">
  <name>Task 2: ResetTransitionManager and 3 crash point tests</name>
  <files>
    spike/phase10_spike/transition_reset.py
    spike/phase10_spike/tests/test_crash_points.py
  </files>
  <action>
    **transition_reset.py** -- ResetTransitionManager class:
    - Constructor takes: `db_path: str`, `delete_store_doc_fn: Callable`, `delete_file_fn: Callable`
    - Uses FileLockManager from spike.phase9_spike.integration.scaffold (import, not copy)
    - `async def execute_reset(self, file_path: str) -> str`:
      1. Acquire per-file lock via FileLockManager
      2. Read current state + version from DB via read_file_full()
      3. Call write_intent(db_path, file_path, version) -- Txn A (GA-6). If returns False, raise StaleTransitionError
      4. Call safe_delete_store_document(self._delete_store_doc_fn, row["gemini_store_doc_id"]) -- API call 1
      5. Call update_progress(db_path, file_path, 1) -- record completion of step 1
      6. Call safe_delete_file(self._delete_file_fn, row["gemini_file_id"]) -- API call 2
      7. Call update_progress(db_path, file_path, 2) -- record completion of step 2
      8. Call finalize_reset(db_path, file_path, version) -- Txn B (GA-6). If returns False, raise StaleTransitionError
      9. Return "untracked"
    - The method does NOT use StateMachineAdapter (research open question #2 -- reset bypasses FSM adapter and manages DB directly). The FSM class defines the valid transitions but ResetTransitionManager handles multi-step execution directly.
    - On any exception during steps 4-8, the exception propagates upward (no catch). The intent columns in DB record how far we got, enabling recovery (Plan 10-02).

    **tests/test_crash_points.py** -- 3 crash point tests (GA-5):

    **test_crash_point_1** -- After delete_store_document, before delete_file:
    - Seed an indexed file
    - Create ResetTransitionManager with: delete_store_doc_fn=AsyncMock(return_value=None), delete_file_fn=AsyncMock(side_effect=RuntimeError("crash after API call 1"))
    - Call execute_reset(), expect RuntimeError
    - Assert DB state: gemini_state='indexed' (not finalized), intent_type='reset_intent', intent_api_calls_completed=1
    - This proves crash point 1 leaves recoverable partial state

    **test_crash_point_2** -- After both API calls, before Txn B:
    - Seed an indexed file
    - Create ResetTransitionManager with both delete fns as AsyncMock(return_value=None)
    - Monkey-patch or mock the update_progress call for step 2 to: first call the real update_progress (setting api_calls_completed=2), then raise asyncio.CancelledError("crash before Txn B")
    - Implementation approach: Instead of mocking update_progress directly (which would prevent the DB write), use a side_effect on the delete_file_fn that succeeds, then mock finalize_reset to first call update_progress(db_path, file_path, 2) and then raise CancelledError. OR: subclass ResetTransitionManager to override execute_reset with a version that raises CancelledError after update_progress(2) but before finalize_reset(). The simplest approach: mock the module-level finalize_reset function to raise asyncio.CancelledError, and let update_progress run normally.
    - Assert DB state: gemini_state='indexed', intent_type='reset_intent', intent_api_calls_completed=2
    - This proves crash point 2 leaves recoverable partial state with both API calls completed

    **test_crash_point_3** -- Txn B itself fails:
    - Seed an indexed file
    - Create ResetTransitionManager with both delete fns as AsyncMock(return_value=None)
    - Mock finalize_reset to raise RuntimeError("DB crash during Txn B")
    - Assert DB state: gemini_state='indexed', intent_type='reset_intent', intent_api_calls_completed=2
    - This proves crash point 3 is identical to crash point 2 from recovery perspective

    All 3 tests verify: (a) gemini_state is still 'indexed' (not stuck in some intermediate), (b) intent columns record exactly which step completed, (c) version has NOT incremented (Txn B never ran). Recovery (Plan 10-02) will verify these same files can be recovered to 'untracked'.

    IMPORTANT: asyncio.CancelledError is BaseException, not Exception. The test for crash point 2 should use `pytest.raises(BaseException)` or `pytest.raises(asyncio.CancelledError)`, not `pytest.raises(Exception)`.
  </action>
  <verify>
    Run: `python -m pytest spike/phase10_spike/tests/test_crash_points.py -v`
    All 3 crash point tests pass.
    Run: `python -m pytest spike/phase10_spike/tests/ -v`
    All tests pass (safe_delete + crash points combined). No import errors.
  </verify>
  <done>
    - ResetTransitionManager implements the full Txn A -> safe_delete APIs -> Txn B flow
    - Crash point 1: after API call 1, DB shows intent_api_calls_completed=1, gemini_state='indexed'
    - Crash point 2: after both API calls, DB shows intent_api_calls_completed=2, gemini_state='indexed'
    - Crash point 3: Txn B fails, DB state identical to crash point 2
    - All 3 tests prove partial state is recorded and recoverable
    - Version NOT incremented at any crash point (Txn B never completed)
  </done>
</task>

</tasks>

<verification>
Run full test suite for Phase 10 Plan 01:
```bash
python -m pytest spike/phase10_spike/tests/ -v --tb=short
```

Expected: 7+ tests pass (4 safe_delete + 3 crash points).

Verify schema loads correctly:
```bash
python -c "
import asyncio
from spike.phase10_spike.db import init_spike_db
asyncio.run(init_spike_db('/tmp/phase10_verify.db'))
import sqlite3
conn = sqlite3.connect('/tmp/phase10_verify.db')
cols = [row[1] for row in conn.execute('PRAGMA table_info(files)')]
print('Columns:', cols)
assert 'intent_type' in cols, 'Missing intent_type'
assert 'gemini_file_id' in cols, 'Missing gemini_file_id'
assert 'gemini_store_doc_id' in cols, 'Missing gemini_store_doc_id'
print('Schema OK')
conn.close()
import os; os.remove('/tmp/phase10_verify.db')
"
```

Verify FSM has no final states:
```bash
python -c "
from spike.phase10_spike.states import FileLifecycleSM
sm = FileLifecycleSM()
for s in sm.states:
    assert not s.final, f'{s.value} should not be final'
print('No final states -- OK')
print('Transitions:', [t.name for t in sm.transitions])
"
```
</verification>

<success_criteria>
1. Extended spike DB schema has all 11 columns (Phase 9's 6 + 5 new)
2. FileLifecycleSM has reset, retry, fail_reset transitions with NO final states
3. safe_delete wrappers correctly handle 404 as success (4 passing tests)
4. ResetTransitionManager implements Txn A -> APIs -> Txn B with per-file locking
5. 3 crash point tests prove partial state is deterministically recorded at each crash point
6. All tests pass: `python -m pytest spike/phase10_spike/tests/ -v` shows 7+ passing, 0 failing
</success_criteria>

<output>
After completion, create `.planning/phases/10-transition-atomicity/10-01-SUMMARY.md`
</output>
