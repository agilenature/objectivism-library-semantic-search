# CLARIFICATIONS-ANSWERED.md

## Phase 12: 50-File FSM-Managed Upload ‚Äî Stakeholder Decisions

**Generated:** 2026-02-20
**Mode:** YOLO (balanced strategy ‚Äî auto-generated from synthesis recommendations)
**Source:** Auto-generated by discuss-phase-ai based on Gemini Pro + Perplexity synthesis

---

## Decision Summary

**Total questions:** 7
**Tier 1 (Blocking):** 3 answered
**Tier 2 (Important):** 3 answered
**Tier 3 (Process):** 1 answered

---

## Tier 1: Blocking Decisions

### Q1: FSM-AsyncUploadStateManager Integration Architecture

**YOLO DECISION:** **Option A ‚Äî Wrapper-Based (FSM as Orchestrator)**

**Rationale:** Confidence ‚úÖ (both providers agree)
- Add FSM-aware write methods to `AsyncUploadStateManager`: `transition_to_uploading()`, `transition_to_processing()`, `transition_to_indexed(gemini_store_doc_id)`, `transition_to_failed(reason)`
- Each method writes ONLY `gemini_state` (and associated FSM columns). Dual-writes `status` column for backward compat (Phase 13 will retire dual-write).
- FSM `on_enter_*` async callbacks call these methods via dependency injection
- Legacy write methods (`record_upload_intent`, `record_import_success`) preserved for crash-recovery read compatibility but NOT called in the new FSM upload path
- SC4 audit = `grep -r "gemini_state\|gemini_store_doc_id" src/` confirming all write sites are the new transition_to_* methods only

**Sub-decisions:**
- FSM instance scope: **per-file** ‚Äî each `_upload_single_file()` instantiates its own `UploadFileFSM(model=file_info)` with `current_state=row['gemini_state']`
- python-statemachine binding: FSM `on_enter_*` callbacks declared `async def`, passed `AsyncUploadStateManager` reference at construction
- No shared FSM state across concurrent upload tasks ‚Äî each task has its own FSM instance

---

### Q2: `_reset_existing_files()` Store Document Lookup Fix

**YOLO DECISION:** **Direct `gemini_store_doc_id` from DB (Option A), with list+map fallback for NULL**

**Rationale:** Confidence ‚úÖ (both providers agree; direct DB lookup is cleaner with FSM tracking)
- For files with `gemini_store_doc_id IS NOT NULL`: call `delete_store_document(gemini_store_doc_id)` directly
- For files with `gemini_store_doc_id IS NULL` (legacy or pre-FSM): fall back to existing `list_store_documents()` map approach
- Write-ahead intent: before ANY delete API call, FSM transitions file to reset-intent state (uses Phase 10 `intent_type` columns)
- SC3 verification: upload 50 files ‚Üí all indexed ‚Üí get `list_store_documents()` count (should be 50) ‚Üí reset 5 files ‚Üí confirm `list_store_documents()` count is now 45

---

### Q3: RecoveryCrawler SC6 Fix ‚Äî `finalize_reset()` False Return

**YOLO DECISION:** **Raise `OCCConflictError` per-file, outer loop continues recovery**

**Rationale:** Confidence ‚úÖ (both providers agree; per-file raise satisfies SC6 without aborting batch)

**Production `_recover_file()` implementation:**
```python
result = await finalize_reset(self._db_path, file_path, row["version"])
if not result:
    raise OCCConflictError(f"OCC conflict during recovery finalize: {file_path}")
logger.info("Recovered %s", file_path)
```

**Production `recover_all()` implementation:**
```python
recovered = []
occ_failures = []
for row in rows:
    try:
        await self._recover_file(row)
        recovered.append(row["file_path"])
    except OCCConflictError as e:
        logger.error("Recovery OCC conflict (file will retry next startup): %s", e)
        occ_failures.append(row["file_path"])
return recovered, occ_failures
```

**SC6 test:** Inject version increment between crawler's DB read and `finalize_reset()` write. Confirm `OCCConflictError` is raised (not logged as "Recovered").

---

## Tier 2: Important Decisions

### Q4: 50-File Test Corpus Selection

**YOLO DECISION:** **First 50 alphabetically by `file_path`**

**Rationale:** Confidence ‚ö†Ô∏è (Gemini recommendation; simpler and reproducible)
```sql
SELECT file_path FROM files
WHERE gemini_state = 'untracked' AND filename LIKE '%.txt'
ORDER BY file_path
LIMIT 50
```
- Pre-flight: verify none of these 50 file paths exist in `list_store_documents()` before upload
- Document the list of 50 paths in the T=0 SUMMARY.md verbatim

---

### Q5: SUMMARY.md Verbatim Content Requirements

**YOLO DECISION:** **5 verbatim data points per checkpoint, same 5 TUI queries across all checkpoints**

**Required verbatim in every SUMMARY.md:**
1. `python scripts/check_stability.py --store objectivism-library` ‚Äî full stdout/stderr + exit code
2. `SELECT COUNT(*) FROM files WHERE gemini_state='indexed'` ‚Äî exact integer
3. `SELECT COUNT(*) FROM files WHERE gemini_store_doc_id IS NOT NULL` ‚Äî exact integer
4. `python -m objlib store-sync --store objectivism-library` (dry-run default) ‚Äî full stdout
5. 5 TUI search queries with full results verbatim (queries chosen in 12-02, reused in 12-03, 12-04, 12-05)
6. ISO timestamp of checkpoint execution

**T=0 SUMMARY.md additionally includes:** The list of 50 file paths uploaded (for SC2 cross-check in T+24h session).

---

### Q6: Bidirectional Cross-Verification Algorithm (SC2)

**YOLO DECISION:** **Two-step algorithm: documents.get() per file + list_store_documents() for orphans**

**Pass condition:**
- Step A: 0 files with 404 from `documents.get(gemini_store_doc_id)` (all 50 DB records confirmed in Store)
- Step B: `list_store_documents()` returns count = 50 AND all 50 names match DB `gemini_store_doc_id` values (0 orphans)

**Failure modes:**
- `missing_from_store > 0`: indexed in DB but gone from Store (serious ‚Äî FSM said indexed but store lost it)
- `orphaned_in_store > 0`: in Store but no DB record (orphan accumulation ‚Äî SC3 fix should prevent this)

---

## Tier 3: Process Decision

### Q7: Partial Upload Failure Gate Policy

**YOLO DECISION:** **Zero-failure after retry (strict, matches SC1 "zero gaps")**

**Rationale:** Confidence ‚úÖ (SC1 is explicit: "zero gaps")
- After 50-file upload completes, run `retry_failed_file()` on any FAILED files
- Re-run upload for retried files (they return to UNTRACKED ‚Üí full pipeline)
- Gate assessment happens AFTER retry attempt
- If any file remains FAILED after retry: Phase 12 gate does NOT pass. Investigate failures, fix, re-run.
- Zero transient failures should reach the gate given RetryManager is in place

---

## Implementation Order (12-01 tasks in priority order)

1. **New `AsyncUploadStateManager` transition methods** ‚Äî foundation for SC4
2. **FSM class definition** (python-statemachine 2.6.0) ‚Äî 5 states, async on_enter callbacks
3. **Wire FSM into `_upload_single_file()`** ‚Äî replace direct state manager calls with FSM transitions
4. **`display_name.strip()` sanitization** ‚Äî Phase 11 finding, 1-line fix
5. **`_reset_existing_files()` DB-first lookup** ‚Äî use `gemini_store_doc_id`, fallback to list
6. **Production `RecoveryCrawler`** in `src/objlib/` ‚Äî SC6 fix (raise not ignore)
7. **SC4 grep audit** ‚Äî confirm no direct `gemini_state` writes outside FSM path
8. **SC6 test** ‚Äî inject OCC conflict, confirm `OCCConflictError` raised

---

## Next Steps

1. ‚úÖ Clarifications answered (YOLO mode)
2. ‚è≠ Proceed to `/gsd:plan-phase 12`
3. üìã 5 plans to create: 12-01 through 12-05

---

*Auto-generated by discuss-phase-ai YOLO mode (balanced strategy)*
*Human review recommended before final implementation*
*Generated: 2026-02-20*
