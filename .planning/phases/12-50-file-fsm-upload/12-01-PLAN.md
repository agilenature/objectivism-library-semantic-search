---
phase: 12-50-file-fsm-upload
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/objlib/database.py
  - src/objlib/upload/fsm.py
  - src/objlib/upload/exceptions.py
  - src/objlib/upload/state.py
autonomous: true

must_haves:
  truths:
    - "V10 migration adds version, intent_type, intent_started_at, intent_api_calls_completed columns to production DB"
    - "FileLifecycleSM defines 5 states and 8 transitions with no final=True on any state"
    - "transition_to_* methods on AsyncUploadStateManager write gemini_state + status atomically with OCC guard"
    - "OCCConflictError is raised when version mismatch occurs during transition"
  artifacts:
    - path: "src/objlib/database.py"
      provides: "V10 migration SQL and _setup_schema() update"
      contains: "PRAGMA user_version = 10"
    - path: "src/objlib/upload/fsm.py"
      provides: "FileLifecycleSM class with 5 states and 8 transitions"
      exports: ["FileLifecycleSM"]
      min_lines: 30
    - path: "src/objlib/upload/exceptions.py"
      provides: "OCCConflictError exception class"
      exports: ["OCCConflictError"]
    - path: "src/objlib/upload/state.py"
      provides: "transition_to_uploading, transition_to_processing, transition_to_indexed, transition_to_failed methods"
      contains: "async def transition_to_"
  key_links:
    - from: "src/objlib/upload/state.py"
      to: "src/objlib/upload/exceptions.py"
      via: "import OCCConflictError"
      pattern: "from objlib\\.upload\\.exceptions import OCCConflictError"
    - from: "src/objlib/upload/state.py"
      to: "src/objlib/database.py"
      via: "V10 columns exist in DB at runtime"
      pattern: "version = \\?"
---

<objective>
Add V10 DB migration and FSM core infrastructure: FileLifecycleSM class, OCCConflictError exception, and transition_to_*() methods on AsyncUploadStateManager.

Purpose: These are the foundational building blocks that Plan 12-02 will wire into the upload pipeline. Without these, no FSM-mediated state transition is possible.

Output: Four modified/created files providing the FSM state machine, OCC exception, transition methods, and V10 schema migration.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-50-file-fsm-upload/12-CONTEXT.md
@.planning/phases/12-50-file-fsm-upload/12-RESEARCH.md
@src/objlib/database.py
@src/objlib/upload/state.py
@spike/phase10_spike/states.py
@spike/phase10_spike/db.py
@spike/phase9_spike/exceptions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: V10 DB migration and FSM class + exception</name>
  <files>
    src/objlib/database.py
    src/objlib/upload/fsm.py
    src/objlib/upload/exceptions.py
  </files>
  <action>
**1. Create `src/objlib/upload/exceptions.py`:**
Create a new file with `OCCConflictError(Exception)` class. Docstring: "OCC version conflict -- another coroutine modified the file concurrently." This is the production equivalent of `spike/phase9_spike/exceptions.py:StaleTransitionError`. Keep the class minimal -- just a docstring, no custom __init__.

**2. Create `src/objlib/upload/fsm.py`:**
Create the production `FileLifecycleSM` class following the pattern in `spike/phase10_spike/states.py` but simplified for production use (no on_enter_state DB callback -- the transition_to_* methods handle persistence):

```python
from statemachine import State, StateMachine

class FileLifecycleSM(StateMachine):
    # 5 states, NO final=True on any state
    untracked = State("untracked", initial=True, value="untracked")
    uploading = State("uploading", value="uploading")
    processing = State("processing", value="processing")
    indexed = State("indexed", value="indexed")
    failed = State("failed", value="failed")

    # 8 transitions
    start_upload = untracked.to(uploading)
    complete_upload = uploading.to(processing)
    complete_processing = processing.to(indexed)
    fail_upload = uploading.to(failed)
    fail_processing = processing.to(failed)
    reset = indexed.to(untracked)
    retry = failed.to(untracked)
    fail_reset = indexed.to(failed)
```

CRITICAL: Do NOT add `final=True` to any state (Phase 10 finding -- causes InvalidDefinition).
CRITICAL: Do NOT add guards (cond=...) or on_enter_state callbacks. The production pattern uses transition_to_*() methods on AsyncUploadStateManager for DB persistence, not FSM callbacks. The FSM is used only to validate that a transition is legal before the DB write.
CRITICAL: Do NOT import from spike code. This is a standalone production module.

Include a module-level docstring explaining the per-file ephemeral pattern: "Each file gets its own FSM instance, initialized at the file's current gemini_state. Used to validate transition legality before AsyncUploadStateManager persists the state change."

Add a convenience function:
```python
def create_fsm(current_state: str) -> FileLifecycleSM:
    """Create an FSM instance at the given state."""
    return FileLifecycleSM(start_value=current_state)
```

**3. Add V10 migration to `src/objlib/database.py`:**
After the existing `MIGRATION_V9_SQL` constant, add:

```python
MIGRATION_V10_SQL = """-- V10: Phase 10 OCC + write-ahead intent columns
-- Applied via ALTER TABLE in _setup_schema() for column-exists safety
"""
```

In `_setup_schema()`, after the `if version < 9:` block, add:

```python
if version < 10:
    for alter_sql in [
        "ALTER TABLE files ADD COLUMN version INTEGER NOT NULL DEFAULT 0",
        "ALTER TABLE files ADD COLUMN intent_type TEXT",
        "ALTER TABLE files ADD COLUMN intent_started_at TEXT",
        "ALTER TABLE files ADD COLUMN intent_api_calls_completed INTEGER",
    ]:
        try:
            self.conn.execute(alter_sql)
        except sqlite3.OperationalError:
            pass  # Column already exists
    # Indexes for recovery and state queries
    self.conn.execute(
        "CREATE INDEX IF NOT EXISTS idx_intent_type ON files(intent_type)"
    )
    self.conn.execute(
        "CREATE INDEX IF NOT EXISTS idx_gemini_state ON files(gemini_state)"
    )
```

Update the final `PRAGMA user_version` from 9 to 10:
```python
self.conn.execute("PRAGMA user_version = 10")
```

Also update the `_setup_schema()` docstring to mention v10.
  </action>
  <verify>
Run: `python -c "from objlib.upload.fsm import FileLifecycleSM, create_fsm; fsm = create_fsm('untracked'); fsm.start_upload(); print(f'State after start_upload: {fsm.current_state.value}'); assert fsm.current_state.value == 'uploading'"` -- should print "uploading".

Run: `python -c "from objlib.upload.exceptions import OCCConflictError; raise OCCConflictError('test')"` -- should raise OCCConflictError.

Run: `python -c "from objlib.database import LibraryDatabase; db = LibraryDatabase('data/library.db'); version = db.conn.execute('PRAGMA user_version').fetchone()[0]; print(f'DB version: {version}'); assert version == 10"` -- should print "DB version: 10".

Run: `python -c "from objlib.database import LibraryDatabase; db = LibraryDatabase('data/library.db'); cols = [r[1] for r in db.conn.execute('PRAGMA table_info(files)').fetchall()]; assert 'version' in cols; assert 'intent_type' in cols; print('V10 columns present')"` -- should print "V10 columns present".
  </verify>
  <done>
V10 migration applied to production DB (user_version=10, all 4 columns present). FileLifecycleSM validates all 8 transitions. OCCConflictError importable from objlib.upload.exceptions.
  </done>
</task>

<task type="auto">
  <name>Task 2: transition_to_*() methods on AsyncUploadStateManager</name>
  <files>src/objlib/upload/state.py</files>
  <action>
Add four new methods to `AsyncUploadStateManager` in a new section after the existing "Write operations" section. Header comment: `# FSM-mediated transition methods (Phase 12)`.

Each method follows the same OCC-guarded pattern from `spike/phase10_spike/db.py`:
- Takes `file_path: str` and `expected_version: int` plus method-specific params
- Executes `UPDATE files SET ... WHERE file_path = ? AND version = ?`
- Dual-writes both `gemini_state` and `status` in the same UPDATE (backward compat per Q1 decision)
- Commits immediately (no held transactions across await boundaries)
- If `cursor.rowcount == 0`, raises `OCCConflictError`
- Returns the new version (`expected_version + 1`)

**Method 1: `transition_to_uploading(file_path, expected_version) -> int`**
Sets `gemini_state='uploading'`, `status='uploading'`, increments version.
WHERE clause: `AND gemini_state = 'untracked' AND version = ?`

**Method 2: `transition_to_processing(file_path, expected_version, gemini_file_id, gemini_file_uri) -> int`**
Sets `gemini_state='processing'`, `gemini_file_id=?`, `gemini_file_uri=?`, `upload_timestamp=now`, increments version.
Dual-write: `status` stays at 'uploading' (this is the processing phase, not yet uploaded).
WHERE clause: `AND gemini_state = 'uploading' AND version = ?`

**Method 3: `transition_to_indexed(file_path, expected_version, gemini_store_doc_id) -> int`**
Sets `gemini_state='indexed'`, `gemini_store_doc_id=?`, `status='uploaded'`, increments version.
WHERE clause: `AND gemini_state = 'processing' AND version = ?`

**Method 4: `transition_to_failed(file_path, expected_version, error_message) -> int`**
Sets `gemini_state='failed'`, `error_message=?`, `status='failed'`, increments version.
WHERE clause: `AND version = ?` (no gemini_state guard -- fail can come from uploading or processing).

All methods also set `gemini_state_updated_at = now_iso`.

Add the import at the top of state.py:
```python
from objlib.upload.exceptions import OCCConflictError
```

Also add two new read methods for FSM pipeline use:

**`get_fsm_pending_files(limit=50) -> list[dict]`**
Returns files WHERE `gemini_state = 'untracked' AND filename LIKE '%.txt'` ORDER BY file_path LIMIT ?.
Returns: file_path, content_hash, filename, file_size, metadata_json, version, gemini_state.
This is the FSM-path equivalent of `get_pending_files()` (which uses legacy `status='pending'`).

**`get_file_version(file_path) -> tuple[str, int]`**
Returns `(gemini_state, version)` for a single file. Raises ValueError if not found.
  </action>
  <verify>
Run existing tests: `python -m pytest tests/test_upload.py -x -q` -- should still pass (legacy methods untouched).

Run: `python -c "
import asyncio, aiosqlite

async def test():
    from objlib.upload.state import AsyncUploadStateManager
    async with AsyncUploadStateManager('data/library.db') as state:
        # Pick first untracked file
        files = await state.get_fsm_pending_files(limit=1)
        if files:
            fp = files[0]['file_path']
            ver = files[0]['version']
            print(f'File: {fp[:60]}..., version={ver}, state={files[0][\"gemini_state\"]}')
            print('get_fsm_pending_files works')
        else:
            print('No untracked files found')

asyncio.run(test())
"` -- should print file info with version=0 and state=untracked.
  </verify>
  <done>
Four transition_to_*() methods added to AsyncUploadStateManager with OCC guards and dual-write. get_fsm_pending_files() and get_file_version() read methods added. Existing tests pass. Import of OCCConflictError verified.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from objlib.upload.fsm import FileLifecycleSM, create_fsm"` -- imports without error
2. `python -c "from objlib.upload.exceptions import OCCConflictError"` -- imports without error
3. `python -c "from objlib.upload.state import AsyncUploadStateManager"` -- imports without error (no circular imports)
4. `python -c "from objlib.database import LibraryDatabase; db = LibraryDatabase('data/library.db'); v = db.conn.execute('PRAGMA user_version').fetchone()[0]; assert v == 10, f'Expected 10, got {v}'"` -- V10 applied
5. `python -m pytest tests/test_upload.py -x -q` -- existing tests pass
6. FSM transition validation: `create_fsm('untracked').start_upload()` succeeds, `create_fsm('indexed').start_upload()` raises TransitionNotAllowed
</verification>

<success_criteria>
- Production DB at V10 with version, intent_type, intent_started_at, intent_api_calls_completed columns
- FileLifecycleSM validates all 8 legal transitions and rejects illegal ones
- transition_to_*() methods OCC-guard every gemini_state write
- Dual-write (gemini_state + status) in every transition method
- No existing test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/12-50-file-fsm-upload/12-01-SUMMARY.md`
</output>
