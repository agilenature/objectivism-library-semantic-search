---
phase: 12-50-file-fsm-upload
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - src/objlib/upload/orchestrator.py
  - src/objlib/upload/recovery.py
  - tests/test_fsm.py
autonomous: true

must_haves:
  truths:
    - "FSM-mediated upload path uses transition_to_*() for all gemini_state mutations -- no raw UPDATE SET gemini_state outside these methods"
    - "_reset_existing_files() deletes store document BEFORE raw file using gemini_store_doc_id from DB (SC3)"
    - "_reset_existing_files() writes intent_type='reset' BEFORE any API call (write-ahead intent)"
    - "RecoveryCrawler._recover_file() raises OCCConflictError when finalize_reset() returns False (SC6)"
    - "RecoveryCrawler.recover_all() catches OCCConflictError per-file and continues to next file"
    - "display_name.strip() applied before every upload call"
    - "No gemini_state mutation occurs outside transition_to_*() methods (SC4)"
  artifacts:
    - path: "src/objlib/upload/orchestrator.py"
      provides: "FSMUploadOrchestrator with FSM-mediated upload path and fixed _reset_existing_files()"
      contains: "transition_to_"
    - path: "src/objlib/upload/recovery.py"
      provides: "Production RecoveryCrawler and retry_failed_file()"
      contains: "OCCConflictError"
    - path: "tests/test_fsm.py"
      provides: "Tests for FSM transitions, OCC guard, SC6 (RecoveryCrawler raises on OCC conflict)"
      min_lines: 50
  key_links:
    - from: "src/objlib/upload/orchestrator.py"
      to: "src/objlib/upload/state.py"
      via: "transition_to_*() calls in _upload_fsm_file()"
      pattern: "transition_to_(uploading|processing|indexed|failed)"
    - from: "src/objlib/upload/orchestrator.py"
      to: "src/objlib/upload/fsm.py"
      via: "create_fsm() for transition validation"
      pattern: "create_fsm"
    - from: "src/objlib/upload/orchestrator.py"
      to: "src/objlib/upload/client.py"
      via: "delete_store_document before delete_file in reset"
      pattern: "delete_store_document.*delete_file"
    - from: "tests/test_fsm.py"
      to: "src/objlib/upload/exceptions.py"
      via: "OCCConflictError assertion in SC6 test"
      pattern: "OCCConflictError"
---

<objective>
Wire FSM into the production upload pipeline, fix _reset_existing_files() for SC3, create production RecoveryCrawler with SC6 fix, and write tests validating FSM transitions and SC6.

Purpose: This plan turns the FSM infrastructure from Plan 12-01 into a working upload path. After this plan, the `fsm-upload` command can upload files through the full FSM lifecycle (UNTRACKED -> UPLOADING -> PROCESSING -> INDEXED).

Output: Modified orchestrator with FSMUploadOrchestrator, production RecoveryCrawler, and test suite.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-50-file-fsm-upload/12-CONTEXT.md
@.planning/phases/12-50-file-fsm-upload/12-RESEARCH.md
@.planning/phases/12-50-file-fsm-upload/12-01-SUMMARY.md
@src/objlib/upload/orchestrator.py
@src/objlib/upload/client.py
@src/objlib/upload/state.py
@src/objlib/upload/fsm.py
@src/objlib/upload/exceptions.py
@spike/phase10_spike/recovery_crawler.py
@spike/phase10_spike/safe_delete.py
@spike/phase10_spike/db.py
@spike/phase11_spike/TRIGGER-STRATEGY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: FSMUploadOrchestrator and fixed _reset_existing_files()</name>
  <files>src/objlib/upload/orchestrator.py</files>
  <action>
Add a new class `FSMUploadOrchestrator` that extends `EnrichedUploadOrchestrator`. This class replaces the legacy status-based upload path with FSM-mediated transitions. Add it after the existing `EnrichedUploadOrchestrator` class.

**New class: FSMUploadOrchestrator(EnrichedUploadOrchestrator)**

Constructor adds:
- Imports: `from objlib.upload.fsm import create_fsm` and `from objlib.upload.exceptions import OCCConflictError`
- No new instance variables needed beyond parent

**Override: `run_fsm(store_display_name: str) -> dict[str, int]`**
Similar to `run_enriched()` but uses FSM-mediated methods:
1. Setup signal handlers
2. Ensure store exists
3. Acquire single-writer lock
4. If `_reset_existing` is True, call `_reset_existing_files_fsm()` (the fixed version)
5. Fetch files via `self._state.get_fsm_pending_files(limit=self._file_limit or 50)`
6. Process in batches using `_process_fsm_batch()`
7. Release lock, return summary

**Override: `_upload_fsm_file(file_info: dict) -> tuple[str, Any] | None`**
The FSM-mediated single-file upload:
1. Check shutdown and circuit breaker (same as parent)
2. Read version from file_info (already has 'version' from get_fsm_pending_files)
3. Validate transition is legal: `fsm = create_fsm(file_info['gemini_state']); fsm.start_upload()` -- if TransitionNotAllowed, log warning and skip
4. Call `transition_to_uploading(file_path, expected_version)` -- this is the write-ahead intent
5. Parse metadata, build display_name with `.strip()` (SC: display_name sanitization per Phase 11)
6. Build enriched metadata if ai_metadata available, otherwise basic metadata
7. Prepare enriched content if applicable
8. Upload with semaphore: `file_obj, operation = await self._client.upload_and_import(...)`
9. Call `transition_to_processing(file_path, version+1, file_obj.name, file_obj.uri)` -- stores gemini_file_id
10. Return (file_path, operation, version+2) for polling phase

**Override: `_poll_fsm_operation(operation_info: tuple) -> bool`**
After polling completes:
1. If operation succeeded (`done=True`, no error):
   - Extract document_name from operation response (see Pattern 3 in RESEARCH.md)
   - Try: `completed_op.response.document_name` (SDK typed path)
   - Fallback: raw API parsing if response is None (see Pattern 4 in RESEARCH.md)
   - The document_name is the `gemini_store_doc_id` to persist
   - Call `transition_to_indexed(file_path, expected_version, gemini_store_doc_id)`
   - Optional: single `documents.get(name=gemini_store_doc_id)` visibility check (Phase 11: P50=0.243s, non-blocking)
2. If operation failed or timed out:
   - Call `transition_to_failed(file_path, expected_version, error_message)`

**New: `_process_fsm_batch(files, batch_number)`**
Similar to `_process_enriched_batch()` but:
- Uses `_upload_fsm_file()` instead of `_upload_enriched_file()`
- Uses `_poll_fsm_operation()` instead of `_poll_single_operation()`
- Includes retry pass for transient failures (same 30s cooldown pattern)

**New: `_reset_existing_files_fsm(limit=0)`**
The SC3-compliant reset implementation (Q2 locked decision):

1. Query files that need reset: `SELECT file_path, gemini_file_id, gemini_store_doc_id, version FROM files WHERE gemini_state = 'indexed' AND gemini_store_doc_id IS NOT NULL` (or whatever the parent's criteria is, but using gemini_state not status).
2. For each file to reset:
   a. **Write-ahead intent**: Set `intent_type='reset'` via a new `write_reset_intent()` method on state manager (or inline SQL with OCC guard on version).
   b. **Delete store document FIRST** (SC3 order): Use `gemini_store_doc_id` from DB directly (Q2 decision: no list+map needed). Call `self._client.delete_store_document(gemini_store_doc_id)`. Wrap in try/except: 404 = success (idempotent). Update `intent_api_calls_completed = 1`.
   c. **Delete raw file SECOND**: Call `self._client.delete_file(gemini_file_id)`. Wrap in try/except: 404 = success. Update `intent_api_calls_completed = 2`.
   d. **Finalize**: Clear gemini_file_id, gemini_store_doc_id, intent columns. Set `gemini_state='untracked'`, `status='pending'`. Increment version.
   e. If `gemini_store_doc_id IS NULL` for a file (legacy path), fall back to the list+map lookup from the parent class pattern.

**display_name sanitization**: In `_upload_fsm_file()`, apply `.strip()` to display_name before upload:
```python
display_name = file_info.get("filename", os.path.basename(file_path))[:512].strip()
```

**Also add these helper methods on AsyncUploadStateManager** (in state.py -- this plan modifies it):
Actually, since Plan 12-01 already added the transition methods, add only:
- `write_reset_intent(file_path, expected_version) -> int`: Sets intent_type='reset', intent_started_at=now, intent_api_calls_completed=0. OCC-guarded. Does NOT increment version (per Phase 10 pattern: Txn A writes intent without version increment).
- `update_intent_progress(file_path, api_calls_completed) -> None`: Updates intent_api_calls_completed. No OCC check (simple progress marker).
- `finalize_reset(file_path, expected_version) -> bool`: Clears all gemini IDs and intent columns, sets gemini_state='untracked', status='pending', increments version. OCC-guarded. Returns True on success, False on conflict.

These three methods go in `src/objlib/upload/state.py` (add them in the "FSM-mediated transition methods" section created by Plan 12-01).

**SC4 audit step**: After implementation, grep the entire codebase for raw `gemini_state =` writes outside of transition_to_*() methods. The ONLY places that should write gemini_state are:
- `transition_to_uploading()`, `transition_to_processing()`, `transition_to_indexed()`, `transition_to_failed()` in state.py
- `finalize_reset()` in state.py
- The V9 migration in database.py (initial default)
- `_reset_existing_files_fsm()` finalize step (which calls finalize_reset())
Any other sites are SC4 violations that must be fixed.
  </action>
  <verify>
SC4 audit: `grep -rn "gemini_state\s*=" src/objlib/ --include="*.py" | grep -v "test_\|\.pyc\|__pycache__\|#\|==\|!=\|DEFAULT"` -- should show ONLY transition_to_* methods and finalize_reset in state.py, plus the V9 migration in database.py. No other write sites.

Import check: `python -c "from objlib.upload.orchestrator import FSMUploadOrchestrator; print('FSMUploadOrchestrator importable')"` -- should succeed.

Existing tests: `python -m pytest tests/test_upload.py -x -q` -- should still pass.
  </verify>
  <done>
FSMUploadOrchestrator class added with FSM-mediated upload path. _reset_existing_files_fsm() deletes store document BEFORE raw file (SC3). display_name.strip() applied. write_reset_intent/update_intent_progress/finalize_reset added to state.py. SC4 grep audit passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Production RecoveryCrawler and test suite</name>
  <files>
    src/objlib/upload/recovery.py
    tests/test_fsm.py
  </files>
  <action>
**1. Add RecoveryCrawler to `src/objlib/upload/recovery.py`:**

The existing `recovery.py` has a `RecoveryManager` class. Add a NEW class `RecoveryCrawler` below it (do not modify RecoveryManager). This is the production equivalent of `spike/phase10_spike/recovery_crawler.py`.

```python
class RecoveryCrawler:
    """Startup recovery for files with pending write-ahead intents.

    Scans for files with intent_type IS NOT NULL (indicating a crash during
    a multi-step transition) and recovers each to 'untracked' using linear
    step resumption. No retry loops (GA-9).

    SC6: _recover_file() raises OCCConflictError if finalize_reset() returns
    False. The outer recover_all() catches per-file and continues.
    """

    def __init__(self, state: AsyncUploadStateManager, client: GeminiFileSearchClient):
        self._state = state
        self._client = client

    async def recover_all(self) -> list[str]:
        """Scan for pending intents and recover each file."""
        db = self._state._ensure_connected()
        cursor = await db.execute(
            """SELECT file_path, intent_type, intent_api_calls_completed,
                      gemini_store_doc_id, gemini_file_id, version
               FROM files WHERE intent_type IS NOT NULL
               ORDER BY intent_started_at ASC"""
        )
        rows = [dict(r) for r in await cursor.fetchall()]

        recovered = []
        for row in rows:
            try:
                await self._recover_file(row)
                recovered.append(row["file_path"])
            except OCCConflictError as exc:
                logger.warning("OCC conflict recovering %s, skipping: %s", row["file_path"], exc)
                # Per Q3: catch per-file, continue to next
            except Exception as exc:
                logger.error("Failed to recover %s: %s", row["file_path"], exc)
        return recovered

    async def _recover_file(self, row: dict) -> None:
        """Linear step resumption from crash point. SC6: raises on OCC conflict."""
        file_path = row["file_path"]
        completed = row["intent_api_calls_completed"] or 0

        # Step 1: Delete store document (if not already done)
        if completed < 1 and row.get("gemini_store_doc_id"):
            try:
                await self._client.delete_store_document(row["gemini_store_doc_id"])
            except Exception as exc:
                if "404" not in str(exc) and "NOT_FOUND" not in str(exc):
                    raise
            await self._state.update_intent_progress(file_path, 1)

        # Step 2: Delete raw file (if not already done)
        if completed < 2 and row.get("gemini_file_id"):
            file_name = row["gemini_file_id"]
            if not file_name.startswith("files/"):
                file_name = f"files/{file_name}"
            try:
                await self._client.delete_file(file_name)
            except Exception as exc:
                if "404" not in str(exc) and "NOT_FOUND" not in str(exc):
                    raise
            await self._state.update_intent_progress(file_path, 2)

        # Step 3: Finalize (SC6 fix -- check return value and raise)
        result = await self._state.finalize_reset(file_path, row["version"])
        if not result:
            raise OCCConflictError(
                f"finalize_reset() OCC conflict during recovery: {file_path}"
            )
        logger.info("Recovered %s: intent=%s, resumed_from_step=%d",
                     file_path, row["intent_type"], completed)
```

Add imports at top: `from objlib.upload.exceptions import OCCConflictError`

Also add `retry_failed_file()` as a standalone async function (production equivalent of spike version):
```python
async def retry_failed_file(state: AsyncUploadStateManager, file_path: str) -> bool:
    """Transition a FAILED file back to UNTRACKED. Returns True on success."""
    db = state._ensure_connected()
    now = state._now_iso()
    cursor = await db.execute(
        """UPDATE files
           SET gemini_state = 'untracked',
               status = 'pending',
               gemini_file_id = NULL,
               gemini_store_doc_id = NULL,
               intent_type = NULL,
               intent_started_at = NULL,
               intent_api_calls_completed = NULL,
               error_message = NULL,
               version = version + 1,
               gemini_state_updated_at = ?
           WHERE file_path = ?
             AND gemini_state = 'failed'""",
        (now, file_path),
    )
    await db.commit()
    return cursor.rowcount == 1
```

**2. Create `tests/test_fsm.py`:**

Write tests covering:

**Test 1: FSM transition validation** -- Test all 8 legal transitions succeed. Test that illegal transitions (e.g., untracked->indexed, indexed->uploading) raise TransitionNotAllowed.

**Test 2: transition_to_uploading OCC guard** -- Create a temp DB with a file at version=0, gemini_state='untracked'. Call transition_to_uploading with expected_version=0 (should succeed, return 1). Call again with expected_version=0 (should raise OCCConflictError because version is now 1).

**Test 3: Full FSM lifecycle** -- Using a temp DB, take a file through untracked -> uploading -> processing -> indexed via transition_to_* methods. Verify final state and version.

**Test 4: SC6 -- RecoveryCrawler raises on OCC conflict** -- Create a temp DB with a file that has intent_type='reset'. Set up a mock client. Before recover_file runs finalize_reset, increment the version in the DB (simulating a concurrent modification). Confirm RecoveryCrawler._recover_file() raises OCCConflictError. Confirm recover_all() catches it and continues.

**Test 5: _reset_existing_files_fsm store-doc-first order** -- Mock the client's delete_store_document and delete_file methods with call order tracking. Run _reset_existing_files_fsm on a file with gemini_store_doc_id. Verify delete_store_document was called BEFORE delete_file (SC3).

Use `tmp_path` fixture for temp DBs. Use `unittest.mock.AsyncMock` for client mocks. The temp DB needs V10 schema -- create it by instantiating LibraryDatabase on a temp path, then use aiosqlite to insert test rows.

IMPORTANT: Do NOT import from spike code in tests. Only import from production `src/objlib/`.
  </action>
  <verify>
Run: `python -m pytest tests/test_fsm.py -x -v` -- all tests pass.

Run: `python -m pytest tests/ -x -q` -- full test suite passes (no regressions).

SC6 test specifically: `python -m pytest tests/test_fsm.py -k "sc6 or occ_conflict_recovery" -v` -- passes.
  </verify>
  <done>
Production RecoveryCrawler raises OCCConflictError on finalize_reset() failure (SC6). recover_all() catches per-file and continues (Q3). retry_failed_file() provides FAILED->UNTRACKED escape. Test suite covers FSM transitions, OCC guard, full lifecycle, SC6, and SC3 delete order.
  </done>
</task>

</tasks>

<verification>
1. SC3: `_reset_existing_files_fsm()` calls `delete_store_document()` before `delete_file()` -- verified by test with call order tracking
2. SC4: `grep -rn "gemini_state\s*=" src/objlib/ --include="*.py"` shows ONLY transition methods + finalize_reset + V9 migration
3. SC6: Test injects OCC conflict, RecoveryCrawler raises OCCConflictError (not silently logged as "Recovered")
4. FSM-04: All gemini_state writes go through transition_to_* or finalize_reset
5. display_name.strip() applied in _upload_fsm_file()
6. `python -m pytest tests/ -x -q` -- full test suite green
</verification>

<success_criteria>
- FSMUploadOrchestrator can run a file through UNTRACKED -> UPLOADING -> PROCESSING -> INDEXED
- _reset_existing_files_fsm() deletes store doc before raw file (SC3)
- RecoveryCrawler._recover_file() raises on OCC conflict (SC6)
- No gemini_state mutation outside FSM transition methods (SC4 grep audit)
- All tests pass including new test_fsm.py
</success_criteria>

<output>
After completion, create `.planning/phases/12-50-file-fsm-upload/12-02-SUMMARY.md`
</output>
