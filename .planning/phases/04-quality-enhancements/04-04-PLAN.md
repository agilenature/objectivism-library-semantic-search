---
phase: 04-quality-enhancements
plan: 04
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/objlib/session/__init__.py
  - src/objlib/session/manager.py
autonomous: true

must_haves:
  truths:
    - "User can create a named session and append search/view/note events to it"
    - "Session events are stored as append-only JSON payloads in SQLite"
    - "Session can be exported as a Markdown file with formatted timeline"
    - "Session resume displays saved timeline of all events"
  artifacts:
    - path: "src/objlib/session/__init__.py"
      provides: "Session subpackage init"
      exports: ["SessionManager"]
    - path: "src/objlib/session/manager.py"
      provides: "Session CRUD, event logging, export, resume"
      exports: ["SessionManager"]
      min_lines: 100
  key_links:
    - from: "src/objlib/session/manager.py"
      to: "src/objlib/database.py"
      via: "Database connection for sessions/session_events tables"
      pattern: "sessions|session_events"
---

<objective>
Build the session manager that provides CRUD operations for research sessions, event logging (search, view, synthesize, note, error), timeline display for resume, and Markdown export.

Purpose: Research sessions let users save their work (queries, results, notes) and resume later. Append-only event logging preserves the complete research trail. Markdown export enables sharing research notes outside the CLI.
Output: session/manager.py with SessionManager class providing all session operations.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-quality-enhancements/04-CONTEXT.md
@.planning/phases/04-quality-enhancements/CLARIFICATIONS-ANSWERED.md
@src/objlib/database.py
@src/objlib/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: SessionManager — CRUD, event logging, and resume</name>
  <files>src/objlib/session/__init__.py, src/objlib/session/manager.py</files>
  <action>
**File 1: `src/objlib/session/__init__.py`**
```python
"""Session management for research workflows."""
from objlib.session.manager import SessionManager

__all__ = ["SessionManager"]
```

**File 2: `src/objlib/session/manager.py`**

Create the SessionManager class. It operates on the sessions and session_events tables created in schema V6.

```python
"""Research session manager with append-only event logging.

Provides CRUD for sessions, event logging (search, view, synthesize, note, error),
timeline display for resume, and Markdown export.
"""
from __future__ import annotations

import json
import logging
import uuid
from datetime import datetime
from pathlib import Path
from typing import Any

from rich.console import Console
from rich.panel import Panel
from rich.table import Table

logger = logging.getLogger(__name__)
```

**Class: SessionManager**

Constructor takes a sqlite3.Connection (from Database.conn):
```python
def __init__(self, conn: sqlite3.Connection) -> None:
    self._conn = conn
```

**Methods to implement:**

1. `create(self, name: str | None = None) -> str` — Create a new session.
   - Generate UUID4 as session id.
   - If name is None, auto-generate: `f"Session {datetime.now().strftime('%Y-%m-%d %H:%M')}"`.
   - INSERT INTO sessions (id, name).
   - Return the session id.

2. `list_sessions(self) -> list[dict]` — List all sessions with event counts.
   - SELECT sessions.*, COUNT(session_events.id) as event_count FROM sessions LEFT JOIN session_events ON sessions.id = session_events.session_id GROUP BY sessions.id ORDER BY sessions.updated_at DESC.
   - Return list of dicts with keys: id, name, created_at, updated_at, event_count.

3. `add_event(self, session_id: str, event_type: str, payload: dict) -> str` — Append event.
   - Generate UUID4 as event id.
   - INSERT INTO session_events (id, session_id, event_type, payload_json).
   - UPDATE sessions SET updated_at = current timestamp WHERE id = session_id.
   - Return event id.
   - Valid event_types: search, view, synthesize, note, error (per schema CHECK constraint).

4. `get_events(self, session_id: str) -> list[dict]` — Get all events for a session.
   - SELECT * FROM session_events WHERE session_id = ? ORDER BY created_at ASC.
   - Parse payload_json back to dict for each row.
   - Return list of dicts with keys: id, session_id, event_type, payload, created_at.

5. `get_session(self, session_id: str) -> dict | None` — Get session metadata.
   - SELECT * FROM sessions WHERE id = ?.
   - Return dict or None.

6. `display_timeline(self, session_id: str, console: Console | None = None) -> None` — Rich-formatted timeline display for resume.
   - Get session metadata and events.
   - Print session header panel (name, created, event count).
   - For each event, display formatted entry:
     - search: "[dim]query:[/dim] {payload.query}" + result count
     - view: "[dim]viewed:[/dim] {payload.filename}"
     - synthesize: "[dim]synthesis:[/dim] {payload.query}" + claim count
     - note: "[italic]{payload.text}[/italic]"
     - error: "[red]error:[/red] {payload.message}"
   - Number each event with timestamp.

7. `export_markdown(self, session_id: str, output_path: Path | None = None) -> Path` — Export session as Markdown.
   - Get session and events.
   - Format as Markdown with:
     - `# Research Session: {name}`
     - `Created: {created_at}`
     - For each event:
       - search: `## Search: "{query}"` + results summary
       - view: `## Viewed: {filename}`
       - synthesize: `## Synthesis: "{query}"` + claims
       - note: `> {text}` (blockquote)
       - error: `**Error:** {message}`
   - If output_path is None, default to `session_{id[:8]}.md` in current directory.
   - Write file and return the path.

8. `delete(self, session_id: str) -> bool` — Delete session and all its events.
   - DELETE FROM session_events WHERE session_id = ?.
   - DELETE FROM sessions WHERE id = ?.
   - Return True if session existed.

Use `with self._conn:` for all write operations (transaction pattern matching existing database.py).

Import sqlite3 at the top. Use `from __future__ import annotations`.
  </action>
  <verify>
Run `python -c "
import sqlite3
from objlib.session.manager import SessionManager

# Use in-memory DB for testing
conn = sqlite3.connect(':memory:')
conn.row_factory = sqlite3.Row
conn.executescript('''
CREATE TABLE sessions (id TEXT PRIMARY KEY, name TEXT, created_at TEXT DEFAULT (strftime('%Y-%m-%dT%H:%M:%f', 'now')), updated_at TEXT DEFAULT (strftime('%Y-%m-%dT%H:%M:%f', 'now')));
CREATE TABLE session_events (id TEXT PRIMARY KEY, session_id TEXT NOT NULL, event_type TEXT NOT NULL CHECK(event_type IN ('search', 'view', 'synthesize', 'note', 'error')), payload_json TEXT NOT NULL, created_at TEXT DEFAULT (strftime('%Y-%m-%dT%H:%M:%f', 'now')), FOREIGN KEY (session_id) REFERENCES sessions(id));
''')

mgr = SessionManager(conn)
sid = mgr.create('Test Session')
print(f'Created session: {sid}')

eid = mgr.add_event(sid, 'search', {'query': 'free will', 'result_count': 10})
print(f'Added event: {eid}')

eid2 = mgr.add_event(sid, 'note', {'text': 'Interesting connection to volition'})
print(f'Added note: {eid2}')

sessions = mgr.list_sessions()
print(f'Sessions: {len(sessions)}, events: {sessions[0][\"event_count\"]}')

events = mgr.get_events(sid)
print(f'Events: {len(events)}')

mgr.display_timeline(sid)
print('Timeline displayed OK')
"` — should create session, add events, list, display timeline without errors.
  </verify>
  <done>SessionManager provides complete CRUD for sessions, append-only event logging (search/view/synthesize/note/error), Rich timeline display, and Markdown export.</done>
</task>

<task type="auto">
  <name>Task 2: Session Markdown export and edge case handling</name>
  <files>src/objlib/session/manager.py</files>
  <action>
Verify and enhance the export_markdown method in SessionManager (from Task 1) with proper formatting and edge cases:

1. **Markdown export format:**
```markdown
# Research Session: {name}

**Created:** {created_at}
**Events:** {event_count}

---

### 1. Search — {timestamp}
**Query:** "{query}"
**Results:** {result_count} passages found
{if expanded_query: **Expanded:** {expanded_query}}

### 2. Note — {timestamp}
> {text}

### 3. Synthesis — {timestamp}
**Query:** "{query}"

{for each claim:}
- {claim_text} [{citation}]

### 4. Error — {timestamp}
**Error:** {message}
**Stage:** {stage}
```

2. **Edge cases to handle:**
   - Session with no events: export should still produce header with "No events recorded."
   - Payload missing expected keys: use `.get()` with sensible defaults throughout.
   - Very long payloads (e.g., full synthesis text): include in export without truncation.
   - Session not found: raise ValueError with clear message.

3. **Add `find_by_prefix(self, prefix: str) -> dict | None` method:**
   - SELECT * FROM sessions WHERE id LIKE ? || '%' LIMIT 2.
   - If exactly 1 match, return it. If 0 or 2+, return None.
   - This lets users type `session resume abc` instead of the full UUID.

4. **Add `get_active_session_id() -> str | None` class-level helper:**
   - Check `os.environ.get("OBJLIB_SESSION")`.
   - If set, return the session id (per locked decision Q5 — auto-attach via env var).
   - If not set, return None.

These additions ensure robust session management for the CLI integration plan (04-05).
  </action>
  <verify>
Run `python -c "
import sqlite3, tempfile, os
from pathlib import Path
from objlib.session.manager import SessionManager

conn = sqlite3.connect(':memory:')
conn.row_factory = sqlite3.Row
conn.executescript('''
CREATE TABLE sessions (id TEXT PRIMARY KEY, name TEXT, created_at TEXT DEFAULT (strftime('%Y-%m-%dT%H:%M:%f', 'now')), updated_at TEXT DEFAULT (strftime('%Y-%m-%dT%H:%M:%f', 'now')));
CREATE TABLE session_events (id TEXT PRIMARY KEY, session_id TEXT NOT NULL, event_type TEXT NOT NULL CHECK(event_type IN ('search', 'view', 'synthesize', 'note', 'error')), payload_json TEXT NOT NULL, created_at TEXT DEFAULT (strftime('%Y-%m-%dT%H:%M:%f', 'now')), FOREIGN KEY (session_id) REFERENCES sessions(id));
''')

mgr = SessionManager(conn)
sid = mgr.create('Export Test')
mgr.add_event(sid, 'search', {'query': 'free will', 'result_count': 5})
mgr.add_event(sid, 'note', {'text': 'Key insight about volition'})

with tempfile.TemporaryDirectory() as tmpdir:
    out = mgr.export_markdown(sid, Path(tmpdir) / 'test.md')
    content = out.read_text()
    print(content[:500])
    assert '# Research Session: Export Test' in content
    assert 'free will' in content
    assert 'Key insight' in content
    print('Export OK')

# Test find_by_prefix
found = mgr.find_by_prefix(sid[:8])
assert found is not None
print(f'Found by prefix: {found[\"name\"]}')

# Test active session
print(f'Active session: {SessionManager.get_active_session_id()}')
"` — should export Markdown correctly, find by prefix, check active session.
  </verify>
  <done>Session export produces well-formatted Markdown. find_by_prefix enables short ID lookups. get_active_session_id checks OBJLIB_SESSION env var. Edge cases handled (empty sessions, missing payload keys).</done>
</task>

</tasks>

<verification>
- `python -c "from objlib.session import SessionManager; print('Import OK')"` passes
- Create session, add events, list sessions, display timeline, export Markdown all work
- find_by_prefix returns unique match or None for ambiguous prefix
- Empty session exports without error
- All event types (search, view, synthesize, note, error) format correctly in timeline and export
</verification>

<success_criteria>
- SessionManager class fully operational with create, list, add_event, get_events, display_timeline, export_markdown, delete, find_by_prefix
- Append-only semantics: events can only be added, never modified
- Markdown export produces readable, well-structured research document
- Active session detection via OBJLIB_SESSION env var
</success_criteria>

<output>
After completion, create `.planning/phases/04-quality-enhancements/04-04-SUMMARY.md`
</output>
