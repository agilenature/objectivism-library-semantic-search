---
phase: 04-quality-enhancements
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/objlib/search/reranker.py
autonomous: true

must_haves:
  truths:
    - "Top-50 Gemini passages are reranked by Gemini Flash into a scored, ordered list"
    - "Difficulty-aware ordering surfaces introductory content first in learn mode"
    - "Research mode preserves pure relevance ordering without difficulty adjustment"
  artifacts:
    - path: "src/objlib/search/reranker.py"
      provides: "LLM-based reranker with difficulty ordering"
      exports: ["rerank_passages", "apply_difficulty_ordering"]
      min_lines: 80
  key_links:
    - from: "src/objlib/search/reranker.py"
      to: "google.genai"
      via: "generate_content with response_schema=RankedResults"
      pattern: "response_schema.*RankedResults"
    - from: "src/objlib/search/reranker.py"
      to: "src/objlib/search/models.py"
      via: "import RankedResults"
      pattern: "from objlib\\.search\\.models import"
---

<objective>
Build the Gemini Flash LLM-based reranker that takes top-50 search passages and produces a precision-ordered result list, plus the difficulty-aware ordering that surfaces introductory content first in learn mode.

Purpose: Gemini File Search returns passages by internal relevance which may not reflect philosophical precision or learning intent. The reranker uses Flash to score passages for the specific query, and difficulty ordering ensures beginners see introductory material first.
Output: reranker.py module with rerank_passages() and apply_difficulty_ordering() functions.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-quality-enhancements/04-CONTEXT.md
@.planning/phases/04-quality-enhancements/CLARIFICATIONS-ANSWERED.md
@.planning/phases/04-quality-enhancements/04-RESEARCH.md
@src/objlib/models.py
@src/objlib/search/client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Gemini Flash LLM-based reranker</name>
  <files>src/objlib/search/reranker.py</files>
  <action>
Create `src/objlib/search/reranker.py` implementing the locked decision: Gemini Flash as LLM-based reranker with structured output.

**Function: `rerank_passages`**

```python
async def rerank_passages(
    client: genai.Client,
    query: str,
    citations: list[Citation],
    model: str = "gemini-2.0-flash",
) -> list[Citation]:
```

Wait — the existing codebase is SYNCHRONOUS (search client uses sync `generate_content`). Keep this synchronous too.

```python
def rerank_passages(
    client,  # genai.Client (untyped to avoid import)
    query: str,
    citations: list[Citation],
    model: str = "gemini-2.0-flash",
) -> list[Citation]:
```

Implementation:
1. If len(citations) <= 1, return as-is (nothing to rerank).
2. Build a structured prompt with numbered passages. For each citation, include:
   - Index (0-based)
   - Passage text (truncated to ~500 chars to save tokens)
   - Metadata context: difficulty, course (if available from citation.metadata)
3. System instruction: "You are a philosophical research assistant specializing in Objectivism. Given a query and a list of passages, score each passage's relevance to the query on a scale of 0-10. Consider: (1) direct relevance to the query topic, (2) depth and specificity of the philosophical content, (3) whether the passage provides substantive explanation versus merely mentioning the topic. Return scores as JSON."
4. Call `client.models.generate_content()` with:
   - model=model (default gemini-2.0-flash for speed/cost)
   - contents=the constructed prompt
   - config=GenerateContentConfig(response_mime_type="application/json", response_schema=RankedResults)
5. Parse the JSON response into RankedResults.
6. Sort citations by score descending.
7. Return the reordered list.

**Error handling (per locked decision Q9):** Wrap the entire Gemini call in try/except. On ANY failure (API error, parse error, timeout), log a warning via `logging.getLogger(__name__).warning(...)` and return the original citation list unchanged. The caller shows a yellow warning in the CLI.

Import RankedResults from `objlib.search.models`. Import Citation from `objlib.models`. Use `from google.genai import types` for GenerateContentConfig.

Do NOT use the FileSearch tool here — this is a plain generate_content call with text input and structured JSON output.
  </action>
  <verify>
Run `python -c "from objlib.search.reranker import rerank_passages; print('rerank_passages imported OK')"` — should import without error.
  </verify>
  <done>rerank_passages function accepts a genai.Client, query, and citation list; calls Gemini Flash with structured output to score and reorder passages; degrades gracefully on failure.</done>
</task>

<task type="auto">
  <name>Task 2: Difficulty-aware ordering with learn/research modes</name>
  <files>src/objlib/search/reranker.py</files>
  <action>
Add `apply_difficulty_ordering` function to `src/objlib/search/reranker.py` (same file as Task 1).

```python
def apply_difficulty_ordering(
    citations: list[Citation],
    mode: str = "learn",
    window: int = 20,
) -> list[Citation]:
```

Implementation per locked decision (ADVN-06, Q7):

1. If mode == "research", return citations unchanged (pure relevance order from reranker).
2. If mode == "learn":
   a. Split citations into two groups: top `window` (first 20) and rest.
   b. For top-window citations, extract difficulty from `citation.metadata.get("difficulty", "")`.
   c. Map difficulty to bucket number: `{"introductory": 0, "intermediate": 1, "advanced": 2}`. Default to 1 (intermediate) for unknown/missing.
   d. Sort top-window by `(difficulty_bucket, -original_index)` — intro first, then intermediate, then advanced. Within same bucket, preserve rerank order (use enumerate to capture original index before sorting).
   e. Concatenate reordered top-window + rest.
3. Return the reordered list.

Also add a module-level constant:
```python
DIFFICULTY_BUCKETS = {"introductory": 0, "intermediate": 1, "advanced": 2}
```

This function is pure logic — no API calls, no imports beyond Citation.
  </action>
  <verify>
Run `python -c "
from objlib.models import Citation
from objlib.search.reranker import apply_difficulty_ordering

# Create test citations with different difficulties
c1 = Citation(index=1, title='a', uri=None, text='t', document_name=None, confidence=0.9, metadata={'difficulty': 'advanced'})
c2 = Citation(index=2, title='b', uri=None, text='t', document_name=None, confidence=0.8, metadata={'difficulty': 'introductory'})
c3 = Citation(index=3, title='c', uri=None, text='t', document_name=None, confidence=0.7, metadata={'difficulty': 'intermediate'})

result = apply_difficulty_ordering([c1, c2, c3], mode='learn')
print([c.metadata['difficulty'] for c in result])
# Should be: ['introductory', 'intermediate', 'advanced']

result2 = apply_difficulty_ordering([c1, c2, c3], mode='research')
print([c.metadata['difficulty'] for c in result2])
# Should be: ['advanced', 'introductory', 'intermediate'] (unchanged)
"` — learn mode should reorder by difficulty, research mode should preserve order.
  </verify>
  <done>apply_difficulty_ordering reorders top-20 citations by difficulty bucket in learn mode (intro first) and preserves pure relevance in research mode.</done>
</task>

</tasks>

<verification>
- `python -c "from objlib.search.reranker import rerank_passages, apply_difficulty_ordering; print('All exports OK')"` passes
- Difficulty ordering correctly sorts introductory before intermediate before advanced
- Research mode returns citations in original order
- rerank_passages returns original list on any API failure (graceful degradation)
</verification>

<success_criteria>
- rerank_passages calls Gemini Flash with RankedResults structured output schema
- apply_difficulty_ordering implements two-stage ordering with learn/research modes
- Both functions handle edge cases (empty list, single citation, missing metadata)
- Graceful degradation: reranker failure returns original order with warning logged
</success_criteria>

<output>
After completion, create `.planning/phases/04-quality-enhancements/04-02-SUMMARY.md`
</output>
