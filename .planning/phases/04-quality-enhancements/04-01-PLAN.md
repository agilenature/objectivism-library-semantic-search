---
phase: 04-quality-enhancements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/objlib/database.py
  - src/objlib/search/models.py
  - src/objlib/search/expansion.py
  - src/objlib/search/synonyms.yml
autonomous: true

must_haves:
  truths:
    - "Database schema V6 includes passages, sessions, and session_events tables"
    - "Query expansion replaces 'egoism' with 'egoism + rational self-interest + ethical egoism'"
    - "Pydantic models exist for reranking, synthesis, and citation structured output"
  artifacts:
    - path: "src/objlib/database.py"
      provides: "Schema V6 migration with passages, sessions, session_events tables"
      contains: "PRAGMA user_version = 6"
    - path: "src/objlib/search/models.py"
      provides: "Pydantic v2 models for reranking and synthesis structured output"
      exports: ["RankedPassage", "RankedResults", "Claim", "CitationRef", "SynthesisOutput"]
    - path: "src/objlib/search/expansion.py"
      provides: "Query expansion engine loading synonyms.yml"
      exports: ["expand_query", "load_glossary"]
    - path: "src/objlib/search/synonyms.yml"
      provides: "Curated Objectivist terminology glossary with ~50 terms"
      min_lines: 50
  key_links:
    - from: "src/objlib/search/expansion.py"
      to: "src/objlib/search/synonyms.yml"
      via: "PyYAML load"
      pattern: "yaml\\.safe_load"
    - from: "src/objlib/database.py"
      to: "passages table"
      via: "CREATE TABLE IF NOT EXISTS passages"
      pattern: "CREATE TABLE IF NOT EXISTS passages"
---

<objective>
Create the data layer foundation for Phase 4: schema V6 migration (passages cache, sessions, session_events tables), Pydantic v2 structured output models for reranking and synthesis, and the query expansion engine with curated Objectivist glossary.

Purpose: All Phase 4 features depend on these foundational artifacts -- the passages table for citation stability, session tables for research persistence, Pydantic models for Gemini Flash structured output, and query expansion for terminology recall improvement.
Output: Database migration, Pydantic models, expansion engine, synonyms glossary.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-quality-enhancements/04-CONTEXT.md
@.planning/phases/04-quality-enhancements/CLARIFICATIONS-ANSWERED.md
@src/objlib/database.py
@src/objlib/models.py
@src/objlib/search/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema V6 migration — passages, sessions, session_events tables</name>
  <files>src/objlib/database.py</files>
  <action>
Add MIGRATION_V6_SQL constant after MIGRATION_V4_SQL with three new tables:

```sql
CREATE TABLE IF NOT EXISTS passages (
    passage_id TEXT PRIMARY KEY,
    file_id TEXT NOT NULL,
    content_hash TEXT,
    passage_text TEXT NOT NULL,
    source TEXT DEFAULT 'gemini_grounding',
    is_stale BOOLEAN DEFAULT 0,
    created_at TEXT DEFAULT (strftime('%Y-%m-%dT%H:%M:%f', 'now')),
    last_seen_at TEXT DEFAULT (strftime('%Y-%m-%dT%H:%M:%f', 'now'))
);
CREATE INDEX IF NOT EXISTS idx_passages_file ON passages(file_id);
CREATE INDEX IF NOT EXISTS idx_passages_hash ON passages(content_hash);

CREATE TABLE IF NOT EXISTS sessions (
    id TEXT PRIMARY KEY,
    name TEXT,
    created_at TEXT DEFAULT (strftime('%Y-%m-%dT%H:%M:%f', 'now')),
    updated_at TEXT DEFAULT (strftime('%Y-%m-%dT%H:%M:%f', 'now'))
);

CREATE TABLE IF NOT EXISTS session_events (
    id TEXT PRIMARY KEY,
    session_id TEXT NOT NULL,
    event_type TEXT NOT NULL CHECK(event_type IN ('search', 'view', 'synthesize', 'note', 'error')),
    payload_json TEXT NOT NULL,
    created_at TEXT DEFAULT (strftime('%Y-%m-%dT%H:%M:%f', 'now')),
    FOREIGN KEY (session_id) REFERENCES sessions(id)
);
CREATE INDEX IF NOT EXISTS idx_session_events_session ON session_events(session_id);
```

In `_setup_schema()`, add a `if version < 6:` block after the V5 block:
- Execute MIGRATION_V6_SQL
- Update PRAGMA user_version to 6

Change the final `self.conn.execute("PRAGMA user_version = 5")` to `self.conn.execute("PRAGMA user_version = 6")`.

Add two new database methods:

1. `upsert_passage(self, passage_id: str, file_id: str, content_hash: str, passage_text: str) -> None` — INSERT OR IGNORE into passages, then UPDATE last_seen_at on conflict. Uses `with self.conn:` transaction pattern.

2. `mark_stale_passages(self, file_id: str) -> int` — UPDATE passages SET is_stale=1 WHERE file_id=? AND is_stale=0. Returns rowcount.

Follow the existing migration pattern: try/except for ALTER TABLE (not needed here since all new tables), CREATE TABLE IF NOT EXISTS for idempotency.
  </action>
  <verify>
Run `python -c "from objlib.database import Database; db = Database('data/library.db'); print('V6 OK'); v = db.conn.execute('PRAGMA user_version').fetchone()[0]; print(f'Version: {v}'); db.conn.execute('SELECT * FROM passages LIMIT 0'); db.conn.execute('SELECT * FROM sessions LIMIT 0'); db.conn.execute('SELECT * FROM session_events LIMIT 0'); print('All tables exist')"` — should print V6 OK, Version: 6, All tables exist.
  </verify>
  <done>Database migrated to V6 with passages, sessions, session_events tables. upsert_passage and mark_stale_passages methods work.</done>
</task>

<task type="auto">
  <name>Task 2: Pydantic v2 structured output models for reranking and synthesis</name>
  <files>src/objlib/search/models.py</files>
  <action>
Create a NEW file `src/objlib/search/models.py` (separate from the top-level `src/objlib/models.py` which has dataclasses). This file contains Pydantic v2 BaseModel classes used as `response_schema` for Gemini Flash structured output.

Models to create (per locked decision and research findings):

```python
"""Pydantic v2 models for Gemini Flash structured output.

Used as response_schema in GenerateContentConfig for reranking
and synthesis pipelines. Separate from objlib.models (dataclasses).
"""
from pydantic import BaseModel, Field

class RankedPassage(BaseModel):
    """A single passage with its reranking score."""
    passage_index: int = Field(description="0-based index of the passage in the input list")
    score: float = Field(ge=0, le=10, description="Relevance score 0-10")
    reason: str = Field(description="Brief reason for the score")

class RankedResults(BaseModel):
    """Complete reranking output from Gemini Flash."""
    rankings: list[RankedPassage]

class CitationRef(BaseModel):
    """Reference to a specific passage as evidence for a claim."""
    file_id: str = Field(description="File identifier from the source")
    passage_id: str = Field(description="Passage identifier")
    quote: str = Field(min_length=20, max_length=300, description="Verbatim quote from the passage, 20-60 words")

class Claim(BaseModel):
    """A single factual claim with its citation."""
    claim_text: str = Field(description="One sentence factual assertion")
    citation: CitationRef

class SynthesisOutput(BaseModel):
    """Complete synthesis output with cited claims."""
    claims: list[Claim]
    bridging_intro: str | None = Field(default=None, description="Optional uncited introductory sentence")
    bridging_conclusion: str | None = Field(default=None, description="Optional uncited concluding sentence")

class TierSynthesis(BaseModel):
    """Single-sentence synthesis for one difficulty tier in concept evolution."""
    tier: str = Field(description="Difficulty tier: introductory, intermediate, or advanced")
    summary: str = Field(description="One-sentence synthesis of this tier's content")
```

Do NOT modify `src/objlib/models.py` — that file stays as-is with its dataclasses. The Pydantic models live in the search subpackage because they're specific to the Gemini structured output pipeline.
  </action>
  <verify>
Run `python -c "from objlib.search.models import RankedResults, SynthesisOutput, TierSynthesis, Claim, CitationRef; print('All models imported OK'); r = RankedResults(rankings=[]); print(f'RankedResults: {r}'); s = SynthesisOutput(claims=[], bridging_intro='Test'); print(f'SynthesisOutput: {s}')"` — should import and instantiate without errors.
  </verify>
  <done>Pydantic v2 models created for RankedPassage, RankedResults, CitationRef, Claim, SynthesisOutput, TierSynthesis. All importable from objlib.search.models.</done>
</task>

<task type="auto">
  <name>Task 3: Query expansion engine with curated Objectivist glossary</name>
  <files>src/objlib/search/expansion.py, src/objlib/search/synonyms.yml</files>
  <action>
**File 1: `src/objlib/search/synonyms.yml`**

Create the curated glossary with ~50 core Objectivist terms. Use this YAML structure:

```yaml
# Objectivist Philosophy Glossary for Query Expansion
# Each entry: term -> list of synonyms (top 2 used per expansion)
# Curated to prevent semantic drift in philosophical context

# Metaphysics & Epistemology
existence:
  - being
  - reality
identity:
  - "law of identity"
  - "A is A"
consciousness:
  - awareness
  - cognition
causality:
  - causation
  - "cause and effect"
epistemology:
  - "theory of knowledge"
  - cognition
reason:
  - rationality
  - "rational faculty"
concept formation:
  - abstraction
  - "unit economy"
objectivity:
  - "objective knowledge"
  - "volitional adherence to reality"
free will:
  - volition
  - "volitional consciousness"
axioms:
  - "axiomatic concepts"
  - "self-evident truths"

# Ethics
rational self-interest:
  - egoism
  - "ethical egoism"
egoism:
  - "rational self-interest"
  - selfishness
altruism:
  - self-sacrifice
  - selflessness
virtue:
  - "moral virtue"
  - "moral character"
pride:
  - "moral ambitiousness"
  - "self-esteem"
justice:
  - "moral judgment"
  - "judging character"
honesty:
  - "refusal to fake reality"
  - integrity
independence:
  - "independent judgment"
  - "intellectual independence"
productiveness:
  - "productive work"
  - "productive achievement"
integrity:
  - "loyalty to values"
  - "moral consistency"
selfishness:
  - "rational self-interest"
  - egoism
happiness:
  - "moral purpose"
  - flourishing
rights:
  - "individual rights"
  - "natural rights"

# Politics & Economics
capitalism:
  - "laissez-faire"
  - "free market"
individualism:
  - "individual sovereignty"
  - "individual rights"
collectivism:
  - statism
  - socialism
property rights:
  - "right to property"
  - "private property"
government:
  - "proper government"
  - "limited government"
force:
  - coercion
  - "initiation of force"
trader principle:
  - "voluntary exchange"
  - "mutual benefit"

# Aesthetics
romantic realism:
  - "Objectivist aesthetics"
  - "art as sense of life"
sense of life:
  - "metaphysical value-judgments"
  - "subconscious philosophy"

# Errors & Fallacies
mysticism:
  - "faith-based belief"
  - irrationalism
determinism:
  - "causal determinism"
  - fatalism
subjectivism:
  - relativism
  - "emotionalism"
intrinsicism:
  - "intrinsic value theory"
  - "intrinsic theory"
context dropping:
  - evasion
  - "stolen concept"
stolen concept:
  - "fallacy of the stolen concept"
  - "concept stealing"
package dealing:
  - "false alternative"
  - "false dichotomy"
primacy of consciousness:
  - "consciousness primacy"
  - idealism
primacy of existence:
  - "existence primacy"
  - "metaphysical realism"

# Key Works & Concepts
OPAR:
  - "Objectivism: The Philosophy of Ayn Rand"
  - Peikoff
ITOE:
  - "Introduction to Objectivist Epistemology"
  - "concept formation"
the virtue of selfishness:
  - "Objectivist ethics"
  - "rational selfishness"
atlas shrugged:
  - "Atlas Shrugged"
  - "Who is John Galt"
the fountainhead:
  - "The Fountainhead"
  - "Howard Roark"
```

**File 2: `src/objlib/search/expansion.py`**

```python
"""Query expansion engine using curated Objectivist terminology glossary.

Expands search queries by appending synonyms from synonyms.yml.
Automatic by default (--no-expand to disable). Shows expanded terms
in CLI output for transparency. Original term boosted by duplication.
"""
```

Implement:

1. `load_glossary(path: Path | None = None) -> dict[str, list[str]]` — loads synonyms.yml from default location (same directory as this module) using `importlib.resources` or `Path(__file__).parent / "synonyms.yml"`. Returns dict mapping term -> synonym list. Cache with `@functools.lru_cache` (wrap in a helper since dict isn't hashable — cache the raw load).

2. `expand_query(query: str, glossary: dict[str, list[str]] | None = None, max_synonyms: int = 2) -> tuple[str, list[str]]` — Takes original query string, returns (expanded_query_string, list_of_expansions_applied).
   - Load glossary if not provided.
   - Normalize query to lowercase for matching.
   - Check multi-word phrases first (longer phrases first to avoid partial matches), then single words.
   - For each matched term: take top `max_synonyms` synonyms.
   - Build expanded query: original query + each synonym joined by space. Original term appears twice (boosting per locked decision Q4c).
   - Return tuple of (expanded_string, list of "term -> syn1, syn2" strings for CLI display).
   - Example: query="egoism" -> ("egoism egoism rational self-interest ethical egoism", ["egoism -> rational self-interest, ethical egoism"])

3. `add_term(term: str, synonyms: list[str], glossary_path: Path | None = None) -> None` — Adds a new term to synonyms.yml. Loads existing, adds entry, writes back with yaml.safe_dump. Used by `glossary add` CLI command.

Important: Multi-word phrase matching must check longest phrases first. Use `sorted(glossary.keys(), key=len, reverse=True)` for match order. Match should be case-insensitive and check word boundaries (use `re.search(r'\b' + re.escape(term) + r'\b', query_lower)` for each glossary key).
  </action>
  <verify>
Run `python -c "
from objlib.search.expansion import expand_query, load_glossary
g = load_glossary()
print(f'Glossary loaded: {len(g)} terms')
expanded, applied = expand_query('What is egoism?', g)
print(f'Expanded: {expanded}')
print(f'Applied: {applied}')
expanded2, applied2 = expand_query('concept formation in epistemology', g)
print(f'Expanded2: {expanded2}')
print(f'Applied2: {applied2}')
expanded3, applied3 = expand_query('hello world', g)
print(f'No match: {expanded3}')
print(f'No expansions: {applied3}')
"` — should show glossary loading, expansion of egoism and concept formation, and no expansion for unrecognized terms.
  </verify>
  <done>Query expansion engine loads ~50-term curated glossary, expands queries with top 2 synonyms per matched term, boosts original term, handles multi-word phrases, returns expansion log for CLI display.</done>
</task>

</tasks>

<verification>
- `python -c "from objlib.database import Database; db = Database('data/library.db'); v = db.conn.execute('PRAGMA user_version').fetchone()[0]; assert v == 6, f'Expected V6, got {v}'; print('Schema V6 OK')"` passes
- `python -c "from objlib.search.models import RankedResults, SynthesisOutput; print('Models OK')"` passes
- `python -c "from objlib.search.expansion import expand_query; q, a = expand_query('rational self-interest'); assert len(a) > 0; print('Expansion OK')"` passes
- synonyms.yml exists and contains at least 40 term entries
</verification>

<success_criteria>
- Database at schema V6 with passages, sessions, session_events tables
- Pydantic models importable: RankedResults, SynthesisOutput, Claim, CitationRef, TierSynthesis
- Query expansion works: known terms expand, unknown terms pass through unchanged
- Glossary has ~50 curated Objectivist terms with 2+ synonyms each
- All existing tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/04-quality-enhancements/04-01-SUMMARY.md`
</output>
