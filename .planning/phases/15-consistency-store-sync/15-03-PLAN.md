---
phase: 15-consistency-store-sync
plan: 03
type: execute
wave: 3
depends_on: ["15-02"]
files_modified:
  - scripts/check_stability.py
autonomous: true

must_haves:
  truths:
    - "check_stability.py has a 7th assertion that verifies a random sample of indexed files are actually searchable via targeted per-file queries"
    - "Assertion 7 uses filename-based targeted queries against the Gemini store, NOT the generic DEFAULT_QUERY"
    - "Assertion 7 passes only if all sampled files appear in search results — one miss is UNSTABLE"
    - "The upgrade is backward-compatible: Assertions 1-6 are unchanged; exit codes are unchanged"
    - "check_stability.py --store objectivism-library exits 0 (STABLE) after the upgrade"
  artifacts:
    - path: "scripts/check_stability.py"
      provides: "7-assertion stability checker with per-file searchability sampling"
      contains: "Assertion 7"
  key_links:
    - from: "scripts/check_stability.py"
      to: "data/library.db"
      via: "SELECT 5 random indexed files with gemini_store_doc_id for targeted query construction"
      pattern: "ORDER BY RANDOM"
    - from: "scripts/check_stability.py"
      to: "Gemini File Search API"
      via: "models.generate_content with FileSearch tool (same call as Assertions 5 and 6)"
      pattern: "Assertion 7"
---

<objective>
Upgrade check_stability.py with Assertion 7: per-file searchability sampling.

The gap being closed: Assertions 1–6 prove structural consistency (counts match, no ghosts,
no orphans, no stuck state) and that search returns *some* results. None of them verify that
specific indexed files are actually retrievable via targeted queries. Phase 15 established
that "listed in store" ≠ "searchable via query". Assertion 7 closes that gap for the
STAB-04 gate that Phase 16's full-library upload relies on.

What it adds:
- Sample 5 random gemini_state='indexed' files from DB
- Construct a targeted query per file from its filename stem (+ metadata title if available)
- Run each query via the same generate_content + FileSearch path as Assertion 5
- Match results against gemini_store_doc_id suffix (Phase 11 finding: Document.display_name
  returns file resource ID, not submitted display_name)
- ALL 5 must appear in top-10 results → PASS; any miss → UNSTABLE

Scope:
- check_stability.py only — no other files changed
- Assertions 1–6 untouched — zero regression risk
- New --sample-count flag (default: 5) for flexibility at 1,748-file scale
- Vacuous pass if indexed_count < sample_size (consistent with Assertions 2-6 vacuous pass
  pattern on empty/small stores)
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/15-consistency-store-sync/15-CONTEXT.md
@.planning/phases/15-consistency-store-sync/15-01-SUMMARY.md
@scripts/check_stability.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Assertion 7 to check_stability.py</name>
  <files>scripts/check_stability.py</files>
  <action>
Add Assertion 7 to `scripts/check_stability.py`. The existing file must be read first to
understand the current structure before editing.

**Changes required — read the file before making any edits:**

1. **Module docstring** (line 1-37): Update "Tests six independent assertions" → "Tests seven
   independent assertions". Update the description to add:
   - "7. Per-file searchability: a random sample of N indexed files each appear in top-10
       search results for a targeted query constructed from the file's name"

2. **StabilityChecker class docstring** (line 90): Update to mention 7 assertions.

3. **Add `_check_targeted_searchability()` method** after `_check_citation_resolution()`
   (around line 421, before `# -- Main run`):

```python
# -- Assertion 7: Per-file searchability sample ----------------------------

def _check_targeted_searchability(
    self, indexed_count: int, sample_size: int = 5
) -> None:
    """Sample N indexed files and verify each is searchable via a targeted query.

    This is the critical upgrade from Phase 15: Assertion 5 proves "search
    returns some results", but this assertion proves "specific indexed files
    are retrievable". One miss → UNSTABLE.

    Query construction: uses filename stem (e.g. "B001 Introduction to
    Objectivism" from "B001 Introduction to Objectivism.txt"). For Objectivism
    library files, names are highly unique and specific enough to target one file.

    Result matching: checks retrieved_context.title against gemini_store_doc_id
    (Phase 11 finding: Document.display_name returns file resource ID, not the
    display_name submitted during upload).
    """
    if indexed_count == 0:
        self._pass(
            "Assertion 7 -- Per-file searchability",
            "N/A -- store is empty (0 indexed files)",
        )
        return

    if indexed_count < sample_size:
        self._pass(
            "Assertion 7 -- Per-file searchability",
            f"N/A -- only {indexed_count} indexed file(s), need {sample_size} for sample",
        )
        return

    # Sample N random indexed files from DB
    try:
        conn = sqlite3.connect(self.db_path)
        rows = conn.execute(
            """SELECT filename, gemini_store_doc_id, metadata_json
               FROM files
               WHERE gemini_state = 'indexed'
                 AND gemini_store_doc_id IS NOT NULL
               ORDER BY RANDOM()
               LIMIT ?""",
            (sample_size,),
        ).fetchall()
        conn.close()
    except Exception as e:
        self._fail("Assertion 7 -- Per-file searchability", f"DB error: {e}")
        return

    if not rows:
        self._pass(
            "Assertion 7 -- Per-file searchability",
            "N/A -- no indexed files with store doc IDs",
        )
        return

    missed = []
    for filename, store_doc_id, metadata_json_str in rows:
        # Construct targeted query from filename stem
        stem = Path(filename).stem  # e.g. "B001 Introduction to Objectivism"
        # Optionally enrich with metadata title if present
        title = None
        if metadata_json_str:
            try:
                import json as _json
                meta = _json.loads(metadata_json_str)
                title = meta.get("display_title") or meta.get("title")
            except Exception:
                pass
        subject = title if title else stem
        query = f"What is '{subject}' about?"
        self._verbose(f"Assertion 7: querying for '{filename}' via: {query!r}")

        # Run targeted search
        try:
            response = self.client.models.generate_content(
                model=SEARCH_MODEL,
                contents=query,
                config=genai_types.GenerateContentConfig(
                    tools=[genai_types.Tool(
                        file_search=genai_types.FileSearch(
                            file_search_store_names=[self.store_resource_name]
                        )
                    )]
                ),
            )
        except Exception as e:
            self._fail(
                "Assertion 7 -- Per-file searchability",
                f"API error querying for '{filename}': {e}",
            )
            return

        # Check top-10 grounding chunks for the target file
        found = False
        if response.candidates:
            gm = getattr(response.candidates[0], "grounding_metadata", None)
            if gm:
                chunks = getattr(gm, "grounding_chunks", []) or []
                for chunk in chunks[:10]:
                    rc = getattr(chunk, "retrieved_context", None)
                    if not rc:
                        continue
                    title_in_result = getattr(rc, "title", "") or ""
                    # Match by gemini_store_doc_id suffix (primary)
                    # OR by filename (fallback, in case display_name behavior changes)
                    if store_doc_id and store_doc_id in title_in_result:
                        found = True
                        break
                    if filename in title_in_result:
                        found = True
                        break

        if not found:
            missed.append(filename)
            self._verbose(
                f"Assertion 7: '{filename}' NOT found in top-10 for query {query!r}"
            )

    if not missed:
        self._pass(
            "Assertion 7 -- Per-file searchability",
            f"all {len(rows)}/{sample_size} sampled files retrievable via targeted queries",
        )
    else:
        self._fail(
            "Assertion 7 -- Per-file searchability",
            f"{len(missed)}/{len(rows)} files not found in search: {missed}",
        )
```

4. **Update `run()` method** — add the Assertion 7 call after `_check_citation_resolution`:

In the `run()` method, the section currently reads:
```python
        # Step 4: Search + citation checks
        print(_head("Search + citation resolution..."))
        citations = self._check_search_results(indexed_count)
        self._check_citation_resolution(citations, indexed_count)
```

Change it to:
```python
        # Step 4: Search + citation checks
        print(_head("Search + citation resolution..."))
        citations = self._check_search_results(indexed_count)
        self._check_citation_resolution(citations, indexed_count)

        # Step 5: Per-file searchability sample (Assertion 7)
        print(_head("Per-file searchability sample..."))
        self._check_targeted_searchability(indexed_count, self.sample_size)
```

5. **Add `sample_size` to `__init__`** — update the constructor signature to accept the new
   parameter:

```python
    def __init__(
        self,
        api_key: str,
        store_display_name: str,
        db_path: str,
        sample_query: str,
        verbose: bool = False,
        sample_size: int = 5,          # NEW
    ) -> None:
        ...
        self.sample_size = sample_size  # NEW
```

6. **Add `--sample-count` argument** to the argparse section in `main()`:

```python
    parser.add_argument(
        "--sample-count",
        type=int,
        default=5,
        help="Number of random indexed files to verify in Assertion 7 (default: 5, 0=skip)",
    )
```

7. **Pass `sample_size` to StabilityChecker** in `main()`:
```python
    checker = StabilityChecker(
        ...
        sample_size=args.sample_count,
    )
```

8. **Update header display** in `run()` to show sample_size:
   The line `print(f"  Query:  {self.sample_query!r}")` — add after it:
   `print(f"  Sample: {self.sample_size} indexed files (Assertion 7)")`

**Implementation notes:**
- The `Path` import is not yet in check_stability.py; add it: `from pathlib import Path`
  (check first — it may already be present from `_REPO_ROOT = Path(__file__).parent.parent`)
  Actually it IS already imported on line 50: `from pathlib import Path`. No new import needed.
- `import json` is NOT in check_stability.py. Add it to the top-level imports, alongside
  the existing stdlib imports (argparse, asyncio, sqlite3, sys, time, datetime).
- Handle the `--sample-count 0` case: treat as vacuous pass in
  `_check_targeted_searchability` (if sample_size == 0, skip with a note).
  </action>
  <verify>
1. Syntax check: `python -c "import py_compile; py_compile.compile('scripts/check_stability.py', doraise=True)"`
2. Grep for assertion 7: `grep -n "Assertion 7" scripts/check_stability.py`
3. Grep for sample_size: `grep -n "sample_size\|sample_count\|RANDOM" scripts/check_stability.py`
4. Verify import json added: `grep -n "^import json" scripts/check_stability.py`
5. Run with existing corpus (should still be STABLE):
   `python scripts/check_stability.py --store objectivism-library --verbose`
   Exit code must be 0. Output should show "Assertion 7" passing.
6. Confirm 7 assertions in output: output should show lines for Assertions 1-7
7. Run existing tests still pass: `python -m pytest tests/ -x -q`
  </verify>
  <done>
scripts/check_stability.py passes syntax check. Running against live store shows all 7
assertions pass (STABLE). The per-file searchability sample (Assertion 7) reports which
files were sampled and confirms each was found in top-10 results. Exit code 0. Tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Run upgraded check_stability.py and produce SUMMARY</name>
  <files>scripts/check_stability.py</files>
  <action>
Run the upgraded check_stability.py against the live store and document the results.

**Step 1: Baseline run (verbose)**
```bash
python scripts/check_stability.py --store objectivism-library --verbose
```
Record the complete output verbatim. Verify:
- All 7 assertions pass
- Assertion 7 shows the 5 sampled filenames, the queries used, and a PASS result
- VERDICT: STABLE, exit 0

**Step 2: Run with --sample-count 0 (skip Assertion 7)**
```bash
python scripts/check_stability.py --store objectivism-library --sample-count 0
```
Verify: Still STABLE, 6 assertions (1-6 pass, 7 vacuous/skipped). Backward-compatible.

**Step 3: Run with --sample-count 10**
```bash
python scripts/check_stability.py --store objectivism-library --sample-count 10 --verbose
```
Verify: STABLE with 10-file sample. Confirm all 10 found. Note timing (10 queries ≈ 20s).

**Step 4: Produce SUMMARY**
Create `.planning/phases/15-consistency-store-sync/15-03-SUMMARY.md` with:
- What was changed: Assertion 7 added; Assertions 1-6 unchanged; --sample-count flag added
- Verbatim output from Step 1 (baseline run with 5-file sample)
- Timing comparison: old check (6 assertions) vs new check (7 assertions, 5 queries added)
- Confirmed backward compatibility (--sample-count 0 skips Assertion 7)
- Gap closure statement: "check_stability.py now verifies that specific indexed files are
  retrievable via targeted queries, not just that search returns any results. The STAB-04
  gate used by Phase 16 now validates actual per-file searchability."
- Impact on Phase 16: each stability check at the full 1,748-file scale takes ~5 extra
  queries (regardless of corpus size) — minimal cost, maximum coverage

**Step 5: Update STATE.md**
Add to STATE.md decisions section:
- [15-03]: check_stability.py upgraded to 7 assertions; Assertion 7 samples 5 random indexed
  files via targeted per-file queries; --sample-count flag controls sample size (0=skip)
- [15-03]: Phase 15 COMPLETE -- all 3 plans done; VLID-07 gate status: see 15-02-SUMMARY.md
  (note: 15-03 adds coverage on top of the already-passing gate, does not re-gate)
  </action>
  <verify>
1. `.planning/phases/15-consistency-store-sync/15-03-SUMMARY.md` exists
2. SUMMARY contains verbatim output from Step 1
3. SUMMARY contains "Assertion 7" and "per-file" in the gap closure statement
4. `python scripts/check_stability.py --store objectivism-library` exits 0 (no args = default 5-file sample)
5. STATE.md updated with [15-03] decision
  </verify>
  <done>
15-03 complete. check_stability.py upgraded to 7 assertions. STAB-04 gate now validates
per-file searchability (not just generic search). SUMMARY.md documents the change and its
impact. STATE.md updated. Phase 15 fully complete (all 3 plans done).
  </done>
</task>

</tasks>

<verification>
Phase 15 Plan 03 verification checklist:
1. check_stability.py has exactly 7 assertions (grep for "Assertion [1-7]")
2. Assertion 7 uses per-file targeted queries from filename stems (NOT DEFAULT_QUERY)
3. Assertion 7 matches by gemini_store_doc_id suffix (Phase 11 finding respected)
4. Assertions 1-6 unchanged (diff confirms no modifications to existing assertion methods)
5. New --sample-count flag with default=5 (0 = skip Assertion 7)
6. Vacuous pass if indexed_count < sample_size
7. All existing tests still pass
8. Running against live store exits 0 (STABLE) with all 7 passing
9. 15-03-SUMMARY.md documents gap closure and backward compatibility
</verification>

<success_criteria>
- check_stability.py verifies specific indexed files are searchable, not just that search works
- Assertion 7 is additive — zero impact on Assertions 1-6 or exit codes
- Tool remains fast enough for Phase 16's temporal stability protocol (~10s overhead at default sample=5)
- STAB-04 gate now means: structurally consistent AND per-file searchable
</success_criteria>

<output>
After completion, create `.planning/phases/15-consistency-store-sync/15-03-SUMMARY.md`
</output>
