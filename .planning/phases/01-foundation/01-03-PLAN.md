---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/objlib/cli.py
  - tests/conftest.py
  - tests/test_scanner.py
  - tests/test_metadata.py
  - tests/test_database.py
  - tests/test_integration.py
autonomous: true

must_haves:
  truths:
    - "User can run 'objlib scan --library /path' and see all files discovered with metadata in SQLite"
    - "User can run 'objlib status' and see counts by status and metadata quality"
    - "User can run 'objlib purge' to remove LOCAL_DELETE records older than N days"
    - "Re-running 'objlib scan' on unchanged library shows 0 new/modified/deleted in output"
    - "Test suite passes covering database, metadata extraction, scanner, and end-to-end integration"
  artifacts:
    - path: "src/objlib/cli.py"
      provides: "Typer CLI with scan, status, purge commands"
      exports: ["app"]
    - path: "tests/conftest.py"
      provides: "Shared pytest fixtures (temp DB, temp library tree)"
    - path: "tests/test_database.py"
      provides: "Database schema, CRUD, UPSERT, idempotency tests"
    - path: "tests/test_metadata.py"
      provides: "Regex pattern matching, quality grading tests"
    - path: "tests/test_scanner.py"
      provides: "File discovery, filtering, change detection tests"
    - path: "tests/test_integration.py"
      provides: "End-to-end scan with temp directory tree"
  key_links:
    - from: "src/objlib/cli.py"
      to: "src/objlib/scanner.py"
      via: "creates FileScanner and calls scan()"
      pattern: "FileScanner.*\\.scan\\(\\)"
    - from: "src/objlib/cli.py"
      to: "src/objlib/database.py"
      via: "creates Database for status/purge commands"
      pattern: "Database\\("
    - from: "src/objlib/cli.py"
      to: "src/objlib/config.py"
      via: "loads ScannerConfig for library path and settings"
      pattern: "load_config|ScannerConfig"
    - from: "pyproject.toml"
      to: "src/objlib/cli.py"
      via: "CLI entry point: objlib = objlib.cli:app"
      pattern: "objlib\\.cli:app"
---

<objective>
Build the Typer CLI interface and comprehensive test suite to complete the Phase 1 foundation.

Purpose: Deliver the user-facing CLI commands (scan, status, purge) that make the scanner usable, and a test suite that validates all Phase 1 requirements are met. This is the final plan that makes the foundation complete and verifiable against all 5 success criteria.

Output: Working CLI (`objlib scan`, `objlib status`, `objlib purge`) and a passing test suite covering database, metadata, scanner, and end-to-end integration.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/CLARIFICATIONS-ANSWERED.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Typer CLI with scan, status, and purge commands</name>
  <files>
    src/objlib/cli.py
  </files>
  <action>
    Create the Typer CLI in `src/objlib/cli.py` using modern Annotated syntax (per research):

    **Setup:**
    ```python
    import typer
    from typing import Annotated
    from rich.console import Console
    from rich.table import Table
    from rich.panel import Panel
    from pathlib import Path

    app = typer.Typer(
        help="Objectivism Library Scanner - Scan, track, and manage your philosophical library",
        rich_markup_mode="rich",
    )
    console = Console()
    ```

    **`scan` command:**
    ```python
    @app.command()
    def scan(
        library_path: Annotated[Path, typer.Option(
            "--library", "-l",
            help="Path to library root directory",
            exists=True, file_okay=False, resolve_path=True,
        )] = None,
        db_path: Annotated[Path, typer.Option(
            "--db", "-d",
            help="Path to SQLite database file",
        )] = Path("data/library.db"),
        config_path: Annotated[Path, typer.Option(
            "--config", "-c",
            help="Path to scanner config JSON",
        )] = Path("config/scanner_config.json"),
        verbose: Annotated[bool, typer.Option("--verbose", "-v")] = False,
    ):
    ```
    - Load config from config_path, override library_path if provided via CLI
    - Create Database, MetadataExtractor, FileScanner
    - Call `scanner.scan()` to get ChangeSet
    - Display results using Rich:
      - Panel header with library path and total files discovered
      - Table showing: New files, Modified files, Deleted files, Unchanged files
      - If verbose: list each new/modified/deleted file path
      - Summary statistics: total files in DB, files by status, files by metadata quality
    - Handle errors: if library path doesn't exist, print error and exit(1)
    - Handle errors: if config file missing, use defaults

    **`status` command:**
    ```python
    @app.command()
    def status(
        db_path: Annotated[Path, typer.Option("--db", "-d")] = Path("data/library.db"),
    ):
    ```
    - Open Database (read-only conceptually)
    - Display Rich Table with:
      - Total file count
      - Status breakdown (pending, uploading, uploaded, failed, LOCAL_DELETE)
      - Metadata quality breakdown (complete, partial, minimal, none, unknown)
      - Last scan timestamp (from max(updated_at))
    - If database doesn't exist, print informative message suggesting `objlib scan` first

    **`purge` command:**
    ```python
    @app.command()
    def purge(
        db_path: Annotated[Path, typer.Option("--db", "-d")] = Path("data/library.db"),
        older_than_days: Annotated[int, typer.Option(
            "--older-than",
            help="Only purge LOCAL_DELETE records older than N days",
        )] = 30,
        confirm: Annotated[bool, typer.Option(
            "--yes", "-y",
            help="Skip confirmation prompt",
        )] = False,
    ):
    ```
    - Query LOCAL_DELETE records older than `older_than_days`
    - Show count of records to be purged
    - If not --yes: prompt for confirmation with `typer.confirm()`
    - Delete confirmed records from files table (hard delete)
    - Display count of purged records

    **Output formatting:**
    - Use Rich Console for all output (no bare print statements)
    - Use `console.print()` with Rich markup for emphasis
    - Use Rich Table for tabular data
    - Use Rich Panel for section headers
    - Colors: green for success counts, yellow for warnings, red for errors

    IMPORTANT: The CLI should work end-to-end with the scanner pipeline. A user should be able to run `objlib scan -l /path/to/library` and see meaningful output immediately.
  </action>
  <verify>
    Run from project root:
    ```bash
    # Test help output
    python -m objlib --help
    python -m objlib scan --help
    python -m objlib status --help
    python -m objlib purge --help

    # Test scan with a temp directory (creates small test library)
    python -c "
    import tempfile, os
    from pathlib import Path

    with tempfile.TemporaryDirectory() as tmpdir:
        root = Path(tmpdir)
        courses = root / 'Courses' / 'Test Course'
        courses.mkdir(parents=True)
        for i in range(5):
            f = courses / f'Test Course - Lesson {i+1:02d} - Topic {i+1}.txt'
            f.write_text(f'Content for lesson {i+1}. ' * 200)

        db_path = root / 'test.db'
        os.system(f'python -m objlib scan -l \"{root}\" -d \"{db_path}\"')
        os.system(f'python -m objlib status -d \"{db_path}\"')
    "
    ```
    Expected: scan shows 5 new files, status shows 5 pending files with metadata quality breakdown.
  </verify>
  <done>
    - `objlib scan` discovers files, extracts metadata, persists to SQLite, displays Rich summary
    - `objlib status` displays database status with counts by status and metadata quality
    - `objlib purge` removes old LOCAL_DELETE records with confirmation
    - All commands accessible via `python -m objlib` and `objlib` CLI entry point
    - Help text is informative and complete for all commands and options
    - Error handling covers missing library path, missing DB, missing config
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive test suite covering all Phase 1 requirements</name>
  <files>
    tests/conftest.py
    tests/test_database.py
    tests/test_metadata.py
    tests/test_scanner.py
    tests/test_integration.py
  </files>
  <action>
    Create a pytest test suite validating all FOUN-01 through FOUN-09 requirements:

    **tests/conftest.py -- Shared fixtures:**
    - `tmp_db(tmp_path) -> Database`: Creates a temp SQLite database file (not :memory: -- WAL needs file)
    - `tmp_library(tmp_path) -> Path`: Creates a temporary directory tree mimicking the real library:
      ```
      Courses/
        Test Course Alpha/
          Test Course Alpha - Lesson 01 - Introduction to Testing.txt  (>1KB)
          Test Course Alpha - Lesson 02 - Advanced Testing.txt         (>1KB)
          Test Course Alpha - Lesson 10 - Final Exam Review.txt        (>1KB)
        Objectivism Seminar - Foundations/
          Year1/
            Q1/
              Objectivism Seminar - Foundations - Year 1 - Q1 - Week 1 - Philosophy Overview.txt (>1KB)
              Objectivism Seminar - Foundations - Year 1 - Q1 - Week 2 - Metaphysics.txt (>1KB)
        Misc/
          random_notes.txt   (>1KB, unknown pattern)
          .hidden_file.txt   (should be skipped)
          tiny.txt           (<100 bytes, should be skipped)
      ```
    - `scanner_config(tmp_library, tmp_db) -> ScannerConfig`: Config pointing to temp fixtures
    - `metadata_extractor() -> MetadataExtractor`: Fresh extractor instance

    **tests/test_database.py:**
    - `test_wal_mode_enabled(tmp_db)`: Assert PRAGMA journal_mode returns 'wal'
    - `test_tables_exist(tmp_db)`: Assert all 4 tables exist (files, _processing_log, _extraction_failures, _skipped_files)
    - `test_insert_and_retrieve(tmp_db)`: Insert FileRecord, verify retrievable with correct fields
    - `test_upsert_idempotent(tmp_db)`: Insert same record twice, assert count still 1 and created_at unchanged
    - `test_upsert_updates_on_hash_change(tmp_db)`: Insert, then upsert with different hash, verify content_hash updated and status reset to 'pending'
    - `test_upsert_preserves_status_on_same_hash(tmp_db)`: Change status to 'uploaded', re-upsert same hash, verify status stays 'uploaded'
    - `test_mark_deleted(tmp_db)`: Insert records, mark one deleted, verify status = 'LOCAL_DELETE'
    - `test_status_transition_logged(tmp_db)`: Change status, verify _processing_log has entry with old and new status
    - `test_batch_upsert(tmp_db)`: Insert 100 records in batch, verify all inserted
    - `test_content_hash_not_unique(tmp_db)`: Insert two records with SAME content_hash but DIFFERENT paths, verify both exist (CRITICAL -- validates research correction)
    - `test_status_counts(tmp_db)`: Insert records with various statuses, verify get_status_counts() returns correct counts
    - `test_get_all_active_files_excludes_deleted(tmp_db)`: Insert records, mark one deleted, verify get_all_active_files() excludes it

    **tests/test_metadata.py:**
    - `test_simple_pattern_basic(metadata_extractor)`: Parse "Course - Lesson 01 - Topic.txt", verify course, lesson, topic
    - `test_simple_pattern_single_digit(metadata_extractor)`: Parse "Course - Lesson 3 - Topic.txt", verify lesson = "3" (tests `\d+` regex)
    - `test_simple_pattern_triple_digit(metadata_extractor)`: Parse "Course - Lesson 100 - Topic.txt", verify lesson = "100"
    - `test_complex_pattern(metadata_extractor)`: Parse "Course - Year 1 - Q1 - Week 1 - Topic.txt" with Year1/Q1 folder structure
    - `test_quality_complete(metadata_extractor)`: File matching simple pattern gets COMPLETE quality
    - `test_quality_partial(metadata_extractor)`: File with course but no lesson gets PARTIAL quality
    - `test_quality_none(metadata_extractor)`: File matching no pattern gets NONE quality
    - `test_topic_cleanup(metadata_extractor)`: Verify underscores replaced, whitespace stripped in topic
    - `test_folder_course_extraction(metadata_extractor)`: Verify course name extracted from parent folder name
    - `test_category_detection(metadata_extractor)`: Verify "Courses/..." -> category="course"

    **tests/test_scanner.py:**
    - `test_discover_files_finds_txt(tmp_library, scanner_config)`: Discover finds all .txt files above min size
    - `test_discover_skips_hidden(tmp_library, scanner_config)`: Hidden files not in results
    - `test_discover_skips_tiny(tmp_library, scanner_config)`: Files below min_size not in results
    - `test_hash_deterministic()`: Same content produces same hash across calls
    - `test_hash_different_content()`: Different content produces different hashes
    - `test_change_detection_new(tmp_library, scanner_config)`: First scan marks all as new
    - `test_change_detection_unchanged(tmp_library, scanner_config)`: Second scan marks all unchanged
    - `test_change_detection_modified(tmp_library, scanner_config)`: Modify file content, re-scan detects modification
    - `test_change_detection_deleted(tmp_library, scanner_config)`: Delete file, re-scan detects deletion
    - `test_symlink_cycle_detection(tmp_path)`: Create circular symlink, verify scanner doesn't hang (timeout test)

    **tests/test_integration.py:**
    - `test_full_scan_lifecycle(tmp_library)`: End-to-end test:
      1. Create config, database, extractor, scanner
      2. First scan: verify correct new count
      3. Verify all records in DB with metadata
      4. Re-scan: verify zero changes (idempotency -- SUCCESS CRITERION 3)
      5. Add a new file, re-scan: verify 1 new (SUCCESS CRITERION 4)
      6. Modify a file, re-scan: verify 1 modified (SUCCESS CRITERION 4)
      7. Delete a file, re-scan: verify 1 deleted (SUCCESS CRITERION 4)
      8. Verify schema has upload columns (SUCCESS CRITERION 5)
    - `test_metadata_quality_distribution(tmp_library)`: After scan, verify quality counts match expectations (known-pattern files get COMPLETE, random file gets MINIMAL/NONE)

    **pytest configuration in pyproject.toml:**
    - Add `[tool.pytest.ini_options]` section with:
      - `testpaths = ["tests"]`
      - `pythonpath = ["src"]`

    Run all tests with: `pytest tests/ -v`
  </action>
  <verify>
    ```bash
    pytest tests/ -v --tb=short
    ```
    Expected: All tests pass. Coverage should be >80% for objlib package.
  </verify>
  <done>
    - All tests pass with `pytest tests/ -v`
    - test_database.py validates FOUN-01 (WAL mode), FOUN-06 (idempotent UPSERT), FOUN-09 (status transitions)
    - test_metadata.py validates FOUN-04 (folder extraction) and FOUN-05 (filename extraction)
    - test_scanner.py validates FOUN-02 (recursive discovery) and FOUN-03 (hash-based change detection)
    - test_integration.py validates all 5 success criteria in a single end-to-end lifecycle test
    - test_content_hash_not_unique confirms the CRITICAL schema correction (non-unique hash index)
    - Symlink cycle detection test passes without hanging
  </done>
</task>

</tasks>

<verification>
1. `objlib scan --help` shows all options with descriptions
2. `objlib scan -l /tmp/test_lib` runs successfully and shows Rich-formatted output
3. `objlib status` shows correct database statistics
4. `objlib purge --yes --older-than 0` removes LOCAL_DELETE records
5. `pytest tests/ -v` passes all tests
6. End-to-end integration test validates all 5 Phase 1 success criteria
</verification>

<success_criteria>
- CLI is fully functional: scan, status, purge commands work end-to-end
- Test suite passes covering all FOUN requirements (01-09)
- Integration test proves idempotency (success criterion 3) and change detection (success criterion 4)
- Phase 1 is complete: user can scan their 1,749-file library, see metadata in SQLite, re-scan without changes
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
