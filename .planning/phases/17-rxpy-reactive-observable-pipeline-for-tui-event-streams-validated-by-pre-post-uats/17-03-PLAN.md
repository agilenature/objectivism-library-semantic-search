---
phase: 17-rxpy-tui
plan: 03
type: execute
wave: 3
depends_on: ["17-01", "17-02"]
files_modified:
  - src/objlib/tui/rx_pipeline.py
  - src/objlib/tui/widgets/search_bar.py
  - src/objlib/tui/app.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "SearchBar uses Subject/enter_subject instead of _debounce_timer/_debounce_gen/set_timer"
    - "ObjlibApp uses combine_latest(query$, filter$) | switch_map instead of @work(exclusive=True)"
    - "on_filter_changed feeds BehaviorSubject instead of directly calling _run_search"
    - "Empty query clears results immediately without debounce"
    - "Pipeline survives API errors (catch inside switch_map)"
    - "reactivex>=4.0 is declared in pyproject.toml dependencies"
  artifacts:
    - path: "src/objlib/tui/rx_pipeline.py"
      provides: "defer_task() wrapper and search_observable() factory"
      min_lines: 40
    - path: "src/objlib/tui/widgets/search_bar.py"
      provides: "SearchBar with _input_subject, _enter_subject, history nav"
      contains: "Subject"
    - path: "src/objlib/tui/app.py"
      provides: "ObjlibApp with RxPY pipeline in on_mount, _filter_subject, on_unmount disposal"
      contains: "combine_latest"
    - path: "pyproject.toml"
      provides: "reactivex>=4.0 in project dependencies"
      contains: "reactivex"
  key_links:
    - from: "src/objlib/tui/widgets/search_bar.py"
      to: "src/objlib/tui/app.py"
      via: "search_bar.input_subject / search_bar.enter_subject properties"
      pattern: "input_subject|enter_subject"
    - from: "src/objlib/tui/app.py"
      to: "src/objlib/tui/rx_pipeline.py"
      via: "defer_task() called inside _search_observable()"
      pattern: "defer_task"
    - from: "src/objlib/tui/app.py"
      to: "reactivex"
      via: "combine_latest, switch_map, debounce, distinct_until_changed"
      pattern: "ops\\.switch_map|ops\\.debounce|combine_latest"
---

<objective>
Replace SearchBar's manual debounce/generation-tracking and ObjlibApp's
@work(exclusive=True) with a unified RxPY observable pipeline.

Purpose: Declarative reactive pipeline replaces ~60 lines of manual timer,
generation counter, and cancellation logic with ~15 lines of composed operators
plus a ~20-line defer_task wrapper. The pipeline unifies the two search trigger
paths (typing + filter change) into a single combine_latest stream.

Output: Modified search_bar.py, app.py, new rx_pipeline.py, updated pyproject.toml.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-rxpy-reactive-observable-pipeline-for-tui-event-streams-validated-by-pre-post-uats/17-RESEARCH.md
@.planning/phases/17-rxpy-reactive-observable-pipeline-for-tui-event-streams-validated-by-pre-post-uats/17-01-SUMMARY.md
@.planning/phases/17-rxpy-reactive-observable-pipeline-for-tui-event-streams-validated-by-pre-post-uats/17-02-SUMMARY.md
@src/objlib/tui/app.py
@src/objlib/tui/widgets/search_bar.py
@src/objlib/tui/messages.py
@src/objlib/tui/state.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rx_pipeline.py and refactor SearchBar</name>
  <files>
    src/objlib/tui/rx_pipeline.py
    src/objlib/tui/widgets/search_bar.py
    pyproject.toml
  </files>
  <action>
**Step A: Add reactivex to pyproject.toml**

In `pyproject.toml` `[project.dependencies]`, add `"reactivex>=4.0"` after
the existing `"python-statemachine==2.6.0"` entry.

**Step B: Create `src/objlib/tui/rx_pipeline.py`**

New module with two functions:

```python
"""RxPY integration utilities for bridging asyncio tasks to observables.

Provides defer_task() for wrapping async coroutines as cancellable
observables, compatible with reactivex's switch_map operator.
"""

from __future__ import annotations

import asyncio

import reactivex as rx
from reactivex.disposable import Disposable


def defer_task(coro_factory, loop=None):
    """Bridge an async coroutine to an RxPY Observable with task cancellation.

    On subscribe: creates an asyncio.Task from coro_factory().
    On dispose: cancels the Task via asyncio.Task.cancel().
    CancelledError is silently absorbed -- not propagated as on_error.

    This is required because RxPY's subscription disposal does NOT
    automatically cancel asyncio.Tasks. Without this wrapper, switch_map
    would "cancel" the observable subscription but the underlying coroutine
    would continue executing.

    Args:
        coro_factory: Zero-argument callable returning a coroutine object.
        loop: Optional event loop. Defaults to asyncio.get_running_loop().

    Returns:
        Observable that emits exactly one value (the coroutine result)
        then completes, or emits an error if the coroutine raises.
    """
    def subscribe(observer, scheduler=None):
        _loop = loop or asyncio.get_running_loop()
        task = _loop.create_task(coro_factory())

        def on_done(t):
            try:
                if t.cancelled():
                    return  # switch_map cancelled us -- silent
                exc = t.exception()
                if exc:
                    observer.on_error(exc)
                else:
                    observer.on_next(t.result())
                    observer.on_completed()
            except asyncio.CancelledError:
                pass  # Race: task cancelled between checks

        task.add_done_callback(on_done)
        return Disposable(lambda: task.cancel() if not task.done() else None)

    return rx.create(subscribe)
```

**Step C: Refactor `src/objlib/tui/widgets/search_bar.py`**

Read the current file first. Then make these specific changes:

1. **Add imports:**
   ```python
   from reactivex.subject import Subject
   ```

2. **In `__init__`:**
   - REMOVE: `self._debounce_timer = None` and `self._debounce_gen: int = 0`
   - ADD: `self._input_subject = Subject()` and `self._enter_subject = Subject()`
   - KEEP: `self._history` and `self._history_index` (unchanged)

3. **Add properties** (after `__init__`):
   ```python
   @property
   def input_subject(self) -> Subject:
       """Observable stream of input values (emits on every keystroke)."""
       return self._input_subject

   @property
   def enter_subject(self) -> Subject:
       """Observable stream of Enter key submissions (emits input value)."""
       return self._enter_subject
   ```

4. **Replace `on_input_changed`:**
   ```python
   def on_input_changed(self, event: Input.Changed) -> None:
       """Emit input value to the Subject for pipeline processing."""
       if event.input is not self:
           return
       query = event.value.strip()
       self._input_subject.on_next(query)
   ```
   - REMOVED: debounce timer management, generation counter
   - The input_subject now receives ALL input changes (including from history nav).
     The debounce operator in the pipeline handles timing. Empty strings are emitted
     too -- the pipeline's switch_map lambda handles empty-query clearing.

5. **Replace `on_key`:**
   ```python
   def on_key(self, event: events.Key) -> None:
       """Handle history navigation and immediate Enter."""
       if event.key == "up" and self._history:
           if self._history_index == -1:
               self._history_index = len(self._history) - 1
           elif self._history_index > 0:
               self._history_index -= 1
           self.value = self._history[self._history_index]
           get_telemetry().log.info(
               f"history navigate direction=up index={self._history_index} "
               f"query={self.value!r}"
           )
           event.prevent_default()

       elif event.key == "down" and self._history_index >= 0:
           if self._history_index < len(self._history) - 1:
               self._history_index += 1
               self.value = self._history[self._history_index]
           else:
               self._history_index = -1
               self.value = ""
           get_telemetry().log.info(
               f"history navigate direction=down index={self._history_index} "
               f"query={self.value!r}"
           )
           event.prevent_default()

       elif event.key == "enter":
           query = self.value.strip()
           if query:
               self._enter_subject.on_next(query)
               # Record in history
               if not self._history or self._history[-1] != query:
                   self._history.append(query)
               self._history_index = -1
               get_telemetry().log.info(
                   f"search fired query={query!r} history_size={len(self._history)}"
               )
   ```
   - REMOVED: `_debounce_gen` bumping, timer.stop(), _fire_search call
   - Enter now emits directly to `_enter_subject` (pipeline handles dedup)
   - History navigation logic is UNCHANGED (Up/Down set self.value, which
     triggers on_input_changed, which emits to _input_subject)

6. **Remove `_fire_search` method entirely** -- no longer needed. The Subject
   emission replaces it.

7. **Update `clear_and_reset`:**
   ```python
   def clear_and_reset(self) -> None:
       """Clear the search bar and reset history navigation."""
       self.value = ""
       self._history_index = -1
       get_telemetry().log.info("search bar cleared")
   ```
   - REMOVED: `self.post_message(SearchRequested(query=""))` -- the empty string
     is now handled by the pipeline via on_input_changed -> _input_subject.on_next("")

8. **Keep `DEBOUNCE_SECONDS`** as a class variable for documentation, but it is
   no longer used by SearchBar directly (the debounce duration is configured in
   the pipeline assembly in app.py). Add a comment:
   `# Debounce duration is now configured in ObjlibApp.on_mount pipeline assembly`
  </action>
  <verify>
Run: `cd /Users/david/projects/objectivism-library-semantic-search && python -c "from objlib.tui.widgets.search_bar import SearchBar; from objlib.tui.rx_pipeline import defer_task; print('imports OK')"` -- no import errors.

Run: `python -c "import reactivex; print(f'reactivex {reactivex.__version__}')"` -- prints version 4.x.

Run: `grep -c 'reactivex' pyproject.toml` -- returns 1 (dependency added).
  </verify>
  <done>
- rx_pipeline.py created with defer_task() wrapper
- SearchBar refactored: _debounce_timer/_debounce_gen removed, Subject/enter_subject added
- _fire_search method removed
- pyproject.toml updated with reactivex>=4.0
- All imports resolve without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor ObjlibApp to use RxPY pipeline</name>
  <files>src/objlib/tui/app.py</files>
  <action>
Read `src/objlib/tui/app.py` first. Then make these specific changes:

**1. Add imports** (at the top of the file, after existing imports):
```python
import asyncio

import reactivex as rx
from reactivex import operators as ops
from reactivex.scheduler.eventloop import AsyncIOScheduler
from reactivex.subject import BehaviorSubject

from objlib.tui.rx_pipeline import defer_task
```

**2. Remove the `from textual import work` import** (no longer needed).

**3. In `__init__`:**
After `set_telemetry(self.telemetry)`, add:
```python
self._filter_subject = BehaviorSubject(FilterSet())
self._rx_subscription = None  # Set in on_mount
```

**4. Extend `on_mount`** to wire the RxPY pipeline. Add after the existing
`self.telemetry.log.info("app mounted")` line, inside the telemetry span:

```python
# Wire RxPY observable pipeline for search
if self.search_service is not None:
    loop = asyncio.get_running_loop()
    scheduler = AsyncIOScheduler(loop)
    search_bar = self.query_one(SearchBar)

    # Two-stream merge: debounced typing + immediate Enter
    query_stream = rx.merge(
        search_bar.input_subject.pipe(
            ops.filter(lambda q: q != ""),  # Empty handled separately
            ops.debounce(0.3, scheduler=scheduler),
        ),
        search_bar.enter_subject,
    ).pipe(ops.distinct_until_changed())

    # Combine with filter stream (BehaviorSubject provides initial value)
    pipeline = rx.combine_latest(
        query_stream,
        self._filter_subject,
    ).pipe(
        ops.switch_map(lambda pair: self._search_observable(pair[0], pair[1]))
    )

    self._rx_subscription = pipeline.subscribe(
        on_next=self._on_search_result,
    )

    # Also subscribe to empty-query emissions for immediate clearing
    search_bar.input_subject.pipe(
        ops.filter(lambda q: q == ""),
    ).subscribe(
        on_next=lambda _: self._clear_results(),
    )
```

CRITICAL: Empty string is filtered OUT of the debounce path and handled
separately via a direct subscription. This ensures empty query clears
results IMMEDIATELY (no 300ms debounce delay), matching the current behavior.

**5. Remove `on_search_requested` handler entirely.** The SearchBar no longer
posts SearchRequested messages. The pipeline processes input directly.

**6. Remove `@work(exclusive=True)` and `_run_search` method entirely.** The
pipeline's switch_map + defer_task replaces this.

**7. Add `_search_observable` method:**
```python
def _search_observable(self, query: str, filter_set: FilterSet):
    """Create an observable for a single search with error handling.

    Returns an Observable that emits exactly one SearchResult or
    handles the error internally (keeping the outer pipeline alive).
    """
    self.is_searching = True
    self.query = query
    self.query_one(ResultsList).update_status("Searching...")

    filters = None
    if not filter_set.is_empty():
        filters = filter_set.to_filter_strings()

    return defer_task(
        lambda: self.search_service.search(query, filters=filters, top_k=20)
    ).pipe(
        ops.catch(lambda err, source: self._handle_search_error(err, query))
    )
```

**8. Add `_on_search_result` method:**
```python
def _on_search_result(self, result) -> None:
    """Handle a successful search result from the pipeline."""
    self.results = result.citations if hasattr(result, "citations") else []
    results_widget = self.query_one(ResultsList)
    results_widget.update_results(self.results)

    # Return focus to search bar
    self.query_one(SearchBar).focus()

    # Update status bar
    count = len(self.results)
    truncated_query = self.query[:30]
    self.query_one("#status-bar", Static).update(
        f"{count} citations retrieved | {truncated_query} | Ctrl+P: Commands"
    )
    self.telemetry.log.info(
        f"search completed query={self.query!r} result_count={count}"
    )
    self.is_searching = False

    # Log to session if active
    if self.active_session_id and self.session_service:
        import asyncio
        asyncio.get_running_loop().create_task(
            self._log_search_event(self.query, count)
        )
```

**9. Add `_log_search_event` helper (replaces inline session logging):**
```python
async def _log_search_event(self, query: str, count: int) -> None:
    """Log search event to session (fire-and-forget)."""
    try:
        await self.session_service.add_event(
            self.active_session_id,
            "search",
            {"query": query, "result_count": count},
        )
    except Exception:
        pass
```

**10. Add `_handle_search_error` method:**
```python
def _handle_search_error(self, error: Exception, query: str):
    """Handle search error: show notification, reset state, return empty observable."""
    self.query_one(ResultsList).update_status(f"Search error: {error}")
    self.notify("Search error", severity="error")
    self.is_searching = False
    self.telemetry.log.error(f"search error query={query!r} error={error!r}")
    return rx.empty()
```

**11. Add `_clear_results` method:**
```python
def _clear_results(self) -> None:
    """Clear search results and reset UI state."""
    self.telemetry.log.info("search cleared")
    self.query = ""
    self.results = []
    self.selected_index = None
    self.query_one(ResultsList).update_status("Enter a search query")
    self.query_one(PreviewPane).show_placeholder()
    self.query_one("#status-bar", Static).update(
        "Ready | 0 results | Ctrl+P: Commands"
    )
    self.is_searching = False
```

**12. Update `on_filter_changed`:**
```python
def on_filter_changed(self, event: FilterChanged) -> None:
    """Handle filter changes -- feed the filter Subject to re-trigger pipeline."""
    self.active_filters = event.filters
    self.telemetry.log.info(f"filter changed filters={event.filters}")
    self._filter_subject.on_next(event.filters)
```
REMOVED: `if self.query: self._run_search(self.query)` -- the pipeline handles
re-triggering via combine_latest automatically.

**13. Add `on_unmount` for subscription disposal:**
```python
def on_unmount(self) -> None:
    """Dispose RxPY subscriptions on app shutdown."""
    if self._rx_subscription is not None:
        self._rx_subscription.dispose()
        self._rx_subscription = None
```

**14. Update `action_clear_search`:**
```python
def action_clear_search(self) -> None:
    """Clear search input and results."""
    self.query_one(SearchBar).clear_and_reset()
    self._clear_results()
```
REMOVED: Inline result clearing (now uses _clear_results helper).

**15. Keep ALL other methods UNCHANGED:** on_result_selected, on_file_selected,
on_navigation_requested, watch_is_searching, bookmark actions, session actions,
synthesis action, navigation/UI toggle actions. These are not affected by the
RxPY migration.

**IMPORTANT: Do NOT remove the SearchRequested import from messages.py** --
it may still be referenced by existing test code in test_tui.py. The SearchBar
no longer posts it, but the import should remain available.
  </action>
  <verify>
Run: `cd /Users/david/projects/objectivism-library-semantic-search && python -c "from objlib.tui.app import ObjlibApp; print('app imports OK')"` -- no import errors.

Run: `python -m pytest tests/test_tui.py -v -x` -- existing tests pass (some may need
SearchRequested adjustments since SearchBar no longer posts it, but tests that use
post_message directly should still work).

Run: `grep -c '@work' src/objlib/tui/app.py` -- returns 0 (decorator removed).
Run: `grep -c 'switch_map' src/objlib/tui/app.py` -- returns 1 (pipeline present).
Run: `grep -c 'combine_latest' src/objlib/tui/app.py` -- returns 1 (pipeline present).
Run: `grep -c 'defer_task' src/objlib/tui/app.py` -- returns 1 (bridge present).
  </verify>
  <done>
- @work(exclusive=True) and _run_search removed from app.py
- on_search_requested handler removed (pipeline replaces it)
- RxPY pipeline wired in on_mount: merge(debounce, enter) | distinct | combine_latest | switch_map
- _filter_subject (BehaviorSubject) feeds combine_latest
- on_filter_changed feeds BehaviorSubject (not direct _run_search call)
- Empty query handled immediately (no debounce)
- Error handling via ops.catch inside switch_map (pipeline survives errors)
- on_unmount disposes subscription
- reactivex>=4.0 in pyproject.toml
  </done>
</task>

</tasks>

<verification>
- `python -c "from objlib.tui.app import ObjlibApp"` -- no import errors
- `python -c "from objlib.tui.widgets.search_bar import SearchBar"` -- no import errors
- `python -c "from objlib.tui.rx_pipeline import defer_task"` -- no import errors
- `grep -c '@work' src/objlib/tui/app.py` returns 0
- `grep -c 'switch_map' src/objlib/tui/app.py` returns >= 1
- `grep -c '_debounce_timer' src/objlib/tui/widgets/search_bar.py` returns 0
- `grep -c 'Subject' src/objlib/tui/widgets/search_bar.py` returns >= 1
- `python -m pytest tests/test_tui.py -v -x` -- existing tests pass
</verification>

<success_criteria>
SearchBar uses Subjects instead of manual debounce timers. ObjlibApp uses a unified
RxPY pipeline (combine_latest + switch_map) instead of @work(exclusive=True).
Filter changes feed BehaviorSubject. Empty queries clear immediately. Errors are
caught inside switch_map. Subscriptions disposed on unmount. All existing tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/17-rxpy-reactive-observable-pipeline-for-tui-event-streams-validated-by-pre-post-uats/17-03-SUMMARY.md`
</output>
