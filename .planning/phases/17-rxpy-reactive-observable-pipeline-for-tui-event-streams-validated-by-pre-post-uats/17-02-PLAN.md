---
phase: 17-rxpy-tui
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - tests/test_uat_tui_behavioral.py
autonomous: true

must_haves:
  truths:
    - "All 7 behavioral invariants are captured as automated assertions against the CURRENT (pre-RxPY) code"
    - "Each assertion produces a specific measured value (call count, notification text, history list) that becomes the post-UAT contract"
    - "History navigation behavior is precisely measured: does Up arrow trigger a search within 300ms or not?"
  artifacts:
    - path: "tests/test_uat_tui_behavioral.py"
      provides: "7 behavioral invariant tests running against current SearchBar/ObjlibApp code"
      min_lines: 200
  key_links:
    - from: "tests/test_uat_tui_behavioral.py"
      to: "src/objlib/tui/app.py"
      via: "ObjlibApp(search_service=mock)"
      pattern: "make_app|ObjlibApp"
    - from: "tests/test_uat_tui_behavioral.py"
      to: "src/objlib/tui/widgets/search_bar.py"
      via: "pilot.press() driving SearchBar input"
      pattern: "pilot\\.press"
---

<objective>
Pre-implementation UAT baseline capturing all 7 behavioral invariants.

Purpose: Establish the exact behavioral contract of the current (pre-RxPY)
TUI implementation. These tests will be run identically after the RxPY
migration in plan 17-04 to verify behavioral parity. The contract is not
just "pass/fail" -- it captures specific measured values (search call counts,
notification contents, result states) that must match after migration.

Output: tests/test_uat_tui_behavioral.py with all 7 invariant tests passing
against the current codebase.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-rxpy-reactive-observable-pipeline-for-tui-event-streams-validated-by-pre-post-uats/17-RESEARCH.md
@.planning/phases/17-rxpy-reactive-observable-pipeline-for-tui-event-streams-validated-by-pre-post-uats/17-01-SUMMARY.md
@src/objlib/tui/app.py
@src/objlib/tui/widgets/search_bar.py
@src/objlib/tui/messages.py
@src/objlib/tui/state.py
@tests/test_tui.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pre-UAT behavioral test suite for all 7 invariants</name>
  <files>tests/test_uat_tui_behavioral.py</files>
  <action>
Create `tests/test_uat_tui_behavioral.py` with fixtures from `tests/test_tui.py`
patterns (mock_search_service, make_app) and 7 behavioral tests. Use
`asyncio_mode = "auto"` (already in pyproject.toml -- no @pytest.mark.asyncio needed).

**Fixtures** (copy patterns from tests/test_tui.py):
- `sample_citations`: 2 Citation objects
- `mock_search_service`: AsyncMock with .search returning SearchResult
- `make_app()`: ObjlibApp factory with optional services
- `slow_search_service`: AsyncMock where .search sleeps 0.5s before returning
  (for stale cancellation test)

**IMPORTANT: All tests drive input through pilot.press(), NOT through
app.post_message(SearchRequested(...)). The UAT must exercise the full
SearchBar -> debounce -> App pipeline.**

**Test 1: test_uat_debounce_fires_once (Invariant 1)**
```
app = make_app(search_service=mock_search_service)
async with app.run_test(size=(120, 40)) as pilot:
    search_bar = app.query_one(SearchBar)
    search_bar.focus()
    # Type rapidly (each character < 300ms apart)
    await pilot.press("h", "e", "l", "l", "o")
    # Before debounce: no search yet
    await pilot.pause(0.05)
    assert mock_search_service.search.call_count == 0
    # After debounce: exactly 1 search with "hello"
    await pilot.pause(0.35)
    assert mock_search_service.search.call_count == 1
    args = mock_search_service.search.call_args
    assert args[0][0] == "hello" or args.kwargs.get("query") == "hello"
```

**Test 2: test_uat_enter_fires_immediately (Invariant 2)**
```
app = make_app(search_service=mock_search_service)
async with app.run_test(size=(120, 40)) as pilot:
    search_bar = app.query_one(SearchBar)
    search_bar.focus()
    await pilot.press("h", "e", "l", "l", "o")
    await pilot.press("enter")
    # Immediate: search should have fired
    await pilot.pause(0.05)
    assert mock_search_service.search.call_count == 1
    # After debounce window: still only 1 (no double-fire)
    await pilot.pause(0.4)
    assert mock_search_service.search.call_count == 1
```

**Test 3: test_uat_stale_cancellation (Invariant 3)**
This tests that when query B supersedes query A, only B's results are shown.
Use `@work(exclusive=True)` cancellation semantics (current code).
```
call_log = []
async def tracked_search(query, **kwargs):
    call_log.append(("start", query))
    await asyncio.sleep(0.3)  # Simulate slow API
    call_log.append(("end", query))
    return SearchResult(response_text="", citations=sample_citations,
                        query=query, metadata_filter=None)
mock = AsyncMock()
mock.search = tracked_search
app = make_app(search_service=mock)
async with app.run_test(size=(120, 40)) as pilot:
    search_bar = app.query_one(SearchBar)
    search_bar.focus()
    # Fire search A via Enter
    await pilot.press("a", "l", "p", "h", "a")
    await pilot.press("enter")
    await pilot.pause(0.05)  # A is now in-flight
    # Fire search B via Enter (should cancel A)
    search_bar.clear()
    await pilot.press("b", "e", "t", "a")
    await pilot.press("enter")
    await pilot.pause(0.6)  # Wait for B to complete
    # B completed; verify app.query reflects latest
    assert app.query == "beta"
```
Note: The exact cancellation behavior depends on @work(exclusive=True). Record
whatever behavior is observed -- the post-UAT must match it.

**Test 4: test_uat_filter_triggers_search (Invariant 4)**
```
app = make_app(search_service=mock_search_service)
async with app.run_test(size=(120, 40)) as pilot:
    search_bar = app.query_one(SearchBar)
    search_bar.focus()
    # First: do a search
    await pilot.press("v", "i", "r", "t", "u", "e")
    await pilot.press("enter")
    await pilot.pause(0.4)
    initial_count = mock_search_service.search.call_count
    assert initial_count >= 1
    # Now change filter (post FilterChanged message)
    from objlib.tui.messages import FilterChanged
    from objlib.tui.state import FilterSet
    app.post_message(FilterChanged(filters=FilterSet(category="course")))
    await pilot.pause(0.4)
    # Should have triggered another search
    assert mock_search_service.search.call_count > initial_count
```

**Test 5: test_uat_history_navigation (Invariant 5)**
```
app = make_app(search_service=mock_search_service)
async with app.run_test(size=(120, 40)) as pilot:
    search_bar = app.query_one(SearchBar)
    search_bar.focus()
    # Build history: search "alpha", then "beta"
    await pilot.press("a", "l", "p", "h", "a")
    await pilot.press("enter")
    await pilot.pause(0.4)
    # Clear and search "beta"
    search_bar.value = ""
    await pilot.press("b", "e", "t", "a")
    await pilot.press("enter")
    await pilot.pause(0.4)
    # Now navigate history: Up should show "beta" (most recent)
    # then Up again shows "alpha"
    search_count_before = mock_search_service.search.call_count
    await pilot.press("up")
    await pilot.pause(0.05)
    # Record whether Up triggered input change
    assert search_bar.value in ["alpha", "beta"]
    # Up again
    await pilot.press("up")
    await pilot.pause(0.05)
    assert search_bar.value == "alpha"
    # Down past end should clear
    await pilot.press("down")  # beta
    await pilot.press("down")  # past end -> clear
    await pilot.pause(0.05)
    assert search_bar.value == ""
    # CRITICAL MEASUREMENT: Record how many searches fired during
    # history navigation (after the Up/Down sequence)
    await pilot.pause(0.4)  # Wait for any pending debounce
    search_count_after = mock_search_service.search.call_count
    # Record delta -- this becomes the contract for post-UAT
    history_nav_search_delta = search_count_after - search_count_before
    # Assert what we observe (the pre-UAT establishes the baseline)
    # Based on code analysis: debounce timers start on Up/Down but
    # are typically cancelled by subsequent keystrokes. The last
    # position (empty string) fires immediately via empty-query path.
    # Exact count depends on timing -- capture it.
    print(f"HISTORY_NAV_SEARCH_DELTA={history_nav_search_delta}")
```

**Test 6: test_uat_empty_query_clears_immediately (Invariant 6)**
```
app = make_app(search_service=mock_search_service)
async with app.run_test(size=(120, 40)) as pilot:
    search_bar = app.query_one(SearchBar)
    search_bar.focus()
    # Do a search first
    await pilot.press("t", "e", "s", "t")
    await pilot.press("enter")
    await pilot.pause(0.4)
    assert len(app.results) > 0
    # Now clear
    app.action_clear_search()
    await pilot.pause(0.05)  # Should be immediate, NOT debounced
    assert app.results == []
    assert app.query == ""
```

**Test 7: test_uat_error_containment (Invariant 7)**
```
mock_svc = AsyncMock()
mock_svc.search.side_effect = RuntimeError("API failure")
app = make_app(search_service=mock_svc)
async with app.run_test(size=(120, 40), notifications=True) as pilot:
    search_bar = app.query_one(SearchBar)
    search_bar.focus()
    await pilot.press("f", "a", "i", "l")
    await pilot.press("enter")
    await pilot.pause(0.5)
    # is_searching should be reset to False
    assert app.is_searching is False
    # Notification should have been posted
    # (check app._notifications if available, or check status bar)
```

**Add a docstring at the top of the file explaining this is the pre-UAT baseline:**
```python
"""Pre-implementation UAT baseline for TUI behavioral invariants.

These 7 tests capture the exact behavior of the current (pre-RxPY) TUI
implementation. After the RxPY migration (plan 17-03), the identical
assertions must pass to confirm behavioral parity.

The tests drive input through pilot.press() (NOT app.post_message) to
exercise the full SearchBar -> debounce -> App pipeline end-to-end.

Contract values captured here (search call counts, result states, timing)
are the gate for plan 17-04.
"""
```
  </action>
  <verify>
Run: `cd /Users/david/projects/objectivism-library-semantic-search && python -m pytest tests/test_uat_tui_behavioral.py -v -s`

All 7 tests pass. The `-s` flag prints captured values (HISTORY_NAV_SEARCH_DELTA
and any other measured baselines). These printed values become the post-UAT contract.
  </verify>
  <done>
All 7 behavioral invariant tests pass against the current (pre-RxPY) codebase:
1. Debounce: 0 calls at 50ms, exactly 1 call at 350ms with "hello"
2. Enter: 1 call within 50ms, still 1 call at 450ms (no double-fire)
3. Stale cancellation: app.query reflects latest query after concurrent submissions
4. Filter trigger: search count increases after FilterChanged message
5. History navigation: Up/Down cycle correctly, search delta measured
6. Empty query: results cleared within 50ms (no debounce delay)
7. Error containment: is_searching=False after API error
  </done>
</task>

</tasks>

<verification>
- `python -m pytest tests/test_uat_tui_behavioral.py -v` -- all 7 pass
- `python -m pytest tests/test_tui.py -v` -- existing tests still pass (no regressions)
- Pre-UAT baseline captured with specific measured values
</verification>

<success_criteria>
All 7 behavioral invariant tests pass against the current codebase. Measured
baselines (search call counts, timing windows, history navigation search delta)
are captured and will serve as the behavioral parity contract for plan 17-04.
</success_criteria>

<output>
After completion, create `.planning/phases/17-rxpy-reactive-observable-pipeline-for-tui-event-streams-validated-by-pre-post-uats/17-02-SUMMARY.md`
</output>
