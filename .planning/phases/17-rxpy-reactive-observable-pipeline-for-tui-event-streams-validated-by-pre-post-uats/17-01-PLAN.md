---
phase: 17-rxpy-tui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - spike/phase17_spike/test_rxpy_textual.py
autonomous: false

must_haves:
  truths:
    - "AsyncIOScheduler integrates with Textual's asyncio event loop without creating a second loop"
    - "switch_map + defer_task() cancels the asyncio.Task of the previous inner observable when a new value arrives"
    - "combine_latest with BehaviorSubject emits on first query without requiring a filter interaction"
    - "merge(debounced$, enter$) + distinct_until_changed prevents double-submission on Enter"
    - "ops.catch inside switch_map inner observable prevents pipeline termination on API error"
  artifacts:
    - path: "spike/phase17_spike/test_rxpy_textual.py"
      provides: "HOSTILE spike harness with 5 affirmative evidence tests"
      min_lines: 120
  key_links:
    - from: "reactivex.scheduler.eventloop.AsyncIOScheduler"
      to: "textual.App.on_mount"
      via: "asyncio.get_running_loop()"
      pattern: "AsyncIOScheduler.*get_running_loop"
    - from: "defer_task()"
      to: "ops.switch_map"
      via: "Disposable(lambda: task.cancel())"
      pattern: "task\\.cancel"
---

<objective>
RxPY + asyncio + Textual integration spike with HOSTILE gate.

Purpose: Confirm all 5 core integration assumptions are valid with affirmative evidence
before any production code is modified. Each assumption is validated by a runnable
test that produces specific observable output -- not by absence of errors.

Output: spike/phase17_spike/test_rxpy_textual.py with 5 passing tests + human review of results.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-rxpy-reactive-observable-pipeline-for-tui-event-streams-validated-by-pre-post-uats/17-RESEARCH.md
@.planning/phases/17-rxpy-reactive-observable-pipeline-for-tui-event-streams-validated-by-pre-post-uats/17-CONTEXT.md
@src/objlib/tui/app.py
@src/objlib/tui/widgets/search_bar.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HOSTILE spike harness with 5 affirmative evidence tests</name>
  <files>spike/phase17_spike/test_rxpy_textual.py</files>
  <action>
Create `spike/phase17_spike/test_rxpy_textual.py` with the following 5 tests.
Each test must produce AFFIRMATIVE evidence (specific measured values that prove
the integration works), not merely absence of errors.

**All tests use real Textual App + run_test() context**, not standalone asyncio.

Use `reactivex` v4 imports per locked decision:
- `import reactivex as rx`
- `from reactivex import operators as ops`
- `from reactivex.scheduler.eventloop import AsyncIOScheduler`
- `from reactivex.subject import Subject, BehaviorSubject`
- `from reactivex.disposable import Disposable`

**Test 1: AsyncIOScheduler + Textual event loop integration**
Create a minimal Textual App subclass. In `on_mount`, call `asyncio.get_running_loop()`
and construct `AsyncIOScheduler(loop)`. Create a Subject, pipe through
`ops.debounce(0.1, scheduler=scheduler)`, and subscribe. Emit a value from `on_mount`.
Use `await pilot.pause(0.15)`. Assert the subscriber received exactly the emitted value.
AFFIRMATIVE EVIDENCE: `loop.is_running() == True`, received value matches emitted value,
no second event loop created (check `id(loop) == id(asyncio.get_running_loop())`).

**Test 2: switch_map + defer_task() cancels asyncio.Task**
Implement `defer_task(coro_factory, loop=None)` inline in the test file (copy from
17-RESEARCH.md Pattern 1). Create a Textual App. In `on_mount`, create a Subject
and pipe through `ops.switch_map(lambda v: defer_task(lambda: slow_search(v)))`.
`slow_search(v)` is an async function that `await asyncio.sleep(0.5)` then returns v.
Emit value "A", wait 0.05s (A is in-flight), then emit value "B".
Wait 0.6s for B to complete.
AFFIRMATIVE EVIDENCE: subscriber received ["B"] only (not ["A", "B"]).
Also verify via a side-effect list that A's coroutine was cancelled
(set a flag in a finally block of slow_search).

**Test 3: BehaviorSubject + combine_latest emits on first query**
Create a Textual App. In `on_mount`, create `filter_sub = BehaviorSubject("default")`.
Create `query_sub = Subject()`. Wire `rx.combine_latest(query_sub, filter_sub)`.
Subscribe and collect emissions. Emit "hello" on query_sub (do NOT emit on filter_sub).
Wait 0.05s.
AFFIRMATIVE EVIDENCE: received exactly [("hello", "default")].
The first query triggers emission because BehaviorSubject provides its initial value.

**Test 4: merge + distinct_until_changed prevents double-fire**
Create a Textual App. In `on_mount`, create `typing_sub = Subject()` and
`enter_sub = Subject()`. Wire:
```python
merged = rx.merge(
    typing_sub.pipe(ops.debounce(0.3, scheduler=scheduler)),
    enter_sub,
).pipe(ops.distinct_until_changed())
```
Subscribe and collect emissions. Emit "foo" on typing_sub (simulates typing).
Immediately emit "foo" on enter_sub (simulates Enter). Wait 0.5s (past debounce).
AFFIRMATIVE EVIDENCE: received exactly ["foo"] (one emission, not two).
Then emit "bar" on enter_sub. Wait 0.05s.
AFFIRMATIVE EVIDENCE: received ["foo", "bar"] (distinct value passes through).

**Test 5: catch inside switch_map preserves pipeline after error**
Create a Textual App. In `on_mount`, create a Subject and pipe through:
```python
sub.pipe(
    ops.switch_map(lambda v: defer_task(lambda: failing_fn(v)).pipe(
        ops.catch(lambda err, source: rx.of(f"ERROR:{err}"))
    ))
)
```
Where `failing_fn(v)` raises `RuntimeError("boom")` if v == "fail", else returns v.
Emit "good1", wait 0.2s, emit "fail", wait 0.2s, emit "good2", wait 0.2s.
AFFIRMATIVE EVIDENCE: received ["good1", "ERROR:boom", "good2"]. The pipeline
survived the error and processed the third emission normally.

**Critical anti-patterns to avoid:**
- Do NOT pass `scheduler=` to `subscribe()` (breaks synchronous emission).
- Use `ops.catch` (NOT `ops.catch_error` -- does not exist in reactivex v4).
- Use `ops.filter` (NOT `ops.filter_` -- does not exist in reactivex v4).
  </action>
  <verify>
Run: `cd /Users/david/projects/objectivism-library-semantic-search && python -m pytest spike/phase17_spike/test_rxpy_textual.py -v`

All 5 tests pass. Each test prints its affirmative evidence to stdout (use print statements
or capture in assertions). No warnings about event loops, threads, or deprecations.
  </verify>
  <done>
5/5 tests pass. Each test produces specific affirmative evidence:
1. Loop ID match, loop.is_running() True, value received
2. Only "B" received (not "A"), A's coroutine was cancelled
3. ("hello", "default") received without filter emission
4. ["foo"] only (not ["foo", "foo"]), then ["foo", "bar"] after distinct value
5. ["good1", "ERROR:boom", "good2"] -- pipeline survived error
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
HOSTILE spike validating all 5 RxPY + Textual integration assumptions with
affirmative evidence. Each test produces specific measurements, not just "pass."
  </what-built>
  <how-to-verify>
1. Review test output: `python -m pytest spike/phase17_spike/test_rxpy_textual.py -v -s`
2. Confirm each of these 5 evidences in the output:
   - Test 1: "loop.is_running()=True, loop_ids_match=True"
   - Test 2: "received=['B'], task_a_cancelled=True"
   - Test 3: "received=[('hello', 'default')]"
   - Test 4: "received=['foo']" then "received=['foo', 'bar']"
   - Test 5: "received=['good1', 'ERROR:boom', 'good2']"
3. Verify no event loop warnings or thread safety errors in output
4. Decision: PASS (all 5 confirmed) or FAIL (identify which assumption failed)
  </how-to-verify>
  <resume-signal>Type "approved" to unblock plans 17-02/03/04, or describe which assumption failed</resume-signal>
</task>

</tasks>

<verification>
- All 5 tests pass: `python -m pytest spike/phase17_spike/test_rxpy_textual.py -v`
- No event loop conflicts (no RuntimeError about running loops)
- No thread violations
- defer_task() correctly cancels asyncio.Task on switch_map disposal
- Pipeline survives errors without termination
</verification>

<success_criteria>
All 5 integration assumptions confirmed with affirmative evidence. The spike
establishes that the RxPY architecture described in 17-CONTEXT.md and 17-RESEARCH.md
is viable for production implementation. HOSTILE gate requires human review of evidence.
</success_criteria>

<output>
After completion, create `.planning/phases/17-rxpy-reactive-observable-pipeline-for-tui-event-streams-validated-by-pre-post-uats/17-01-SUMMARY.md`
</output>
