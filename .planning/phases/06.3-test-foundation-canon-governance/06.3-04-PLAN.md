---
phase: 06.3-test-foundation-canon-governance
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_sync.py
  - tests/test_session.py
autonomous: true

must_haves:
  truths:
    - "SyncDetector skips files with unchanged mtime (mtime epsilon 1e-6)"
    - "SyncDetector classifies files as new, modified, deleted, or unchanged"
    - "SyncDetector safety guard raises RuntimeError when >50% files are missing"
    - "Disk utility correctly reports mounted vs unmounted states using pyfakefs"
    - "SessionManager creates sessions, appends events, and retrieves by UUID prefix"
    - "SessionManager has no update_event or delete_event methods (append-only semantics)"
    - "find_by_prefix returns None for ambiguous prefixes (0 or 2+ matches)"
  artifacts:
    - path: "tests/test_sync.py"
      provides: "SyncDetector tests: mtime optimization, classification, safety guard, disk utility"
      min_lines: 100
    - path: "tests/test_session.py"
      provides: "SessionManager tests: create, events, prefix lookup, append-only verification"
      min_lines: 80
  key_links:
    - from: "tests/test_sync.py"
      to: "src/objlib/sync/detector.py"
      via: "pyfakefs fs fixture + in_memory_db for filesystem + database state"
      pattern: "SyncDetector"
    - from: "tests/test_session.py"
      to: "src/objlib/session/manager.py"
      via: "SessionManager(conn) with in_memory_db._conn"
      pattern: "SessionManager"
---

<objective>
Create retroactive tests for the sync pipeline (SyncDetector mtime optimization, disk utility) and SessionManager (append-only event semantics, UUID prefix lookup). Uses pyfakefs for filesystem simulation and in-memory SQLite for database state.

Purpose: Sync and session modules are the most recently built features (Phase 5 and Phase 4). Testing them proves the newest code is stable before the TUI depends on it.
Output: test_sync.py (SyncDetector + disk utility), test_session.py (SessionManager).
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06.3-test-foundation-canon-governance/06.3-RESEARCH.md
@src/objlib/sync/detector.py
@src/objlib/sync/disk.py
@src/objlib/session/manager.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: SyncDetector and disk utility tests with pyfakefs</name>
  <files>tests/test_sync.py</files>
  <action>
Read `src/objlib/sync/detector.py` and `src/objlib/sync/disk.py` first to understand:
- SyncDetector class constructor and detect() method signature
- How it uses os.stat, os.path.getsize, file_path.stat()
- The mtime epsilon constant (1e-6 per decision [05-03])
- The safety guard threshold (>50% missing triggers RuntimeError)
- Disk utility function(s) for checking mount point availability

**CRITICAL pyfakefs + SQLite pitfall:** Use `:memory:` SQLite (via `in_memory_db` fixture) inside pyfakefs tests. The `fs` fixture and `in_memory_db` fixture can coexist because `:memory:` SQLite doesn't touch the filesystem.

**CRITICAL SyncDetector safety guard:** If your test sets up 10 files in the DB but only 3 on the fake filesystem, the safety guard triggers (>50% missing). Ensure DB state and filesystem state are consistent unless you're specifically testing the safety guard.

Tests to implement:

**SyncDetector classification:**

1. `test_detect_new_file(fs, in_memory_db)` — Create file on fake filesystem that is NOT in the database. Run detection. Assert file classified as "new" in the changeset.

2. `test_detect_unchanged_file(fs, in_memory_db)` — Create file on fake filesystem. Insert into DB with matching hash, size, and mtime. Run detection. Assert file classified as "unchanged" (or not in any change list).

3. `test_detect_modified_file(fs, in_memory_db)` — Create file, insert into DB. Modify file content on fake filesystem (change bytes). Run detection. Assert file classified as "modified".

4. `test_detect_deleted_file(fs, in_memory_db)` — Insert file into DB. Do NOT create it on fake filesystem (but ensure enough other files exist to avoid safety guard). Run detection. Assert file classified as "deleted" or "missing".

**mtime optimization:**

5. `test_mtime_unchanged_skips_hash(fs, in_memory_db)` — Create file. Record in DB with correct mtime. Run detection. Assert hash was NOT recomputed (file should be skipped). Verify by checking the changeset says "unchanged" or by asserting the skip count.

6. `test_mtime_changed_triggers_hash(fs, in_memory_db)` — Create file. Record in DB with different mtime. Run detection. Assert hash IS computed and file is classified based on hash comparison.

7. `test_mtime_epsilon_tolerance(fs, in_memory_db)` — Create file. Record mtime in DB that differs by less than 1e-6 from actual. Assert file treated as unchanged (epsilon tolerance per decision [05-03]).

**Safety guard:**

8. `test_safety_guard_triggers_on_mass_missing(fs, in_memory_db)` — Insert 10 files into DB. Create only 4 on fake filesystem (<50% present). Assert SyncDetector raises RuntimeError with "SAFETY ABORT" or similar message.

9. `test_safety_guard_ok_when_enough_present(fs, in_memory_db)` — Insert 10 files into DB. Create 8 on fake filesystem (80% present). Assert detection completes without RuntimeError.

**Disk utility:**

10. `test_disk_mounted(fs)` — Create mount point directory with contents using `fs.create_dir()` and `fs.create_file()`. Assert disk utility reports available/mounted.

11. `test_disk_unmounted(fs)` — Do NOT create the mount point directory. Assert disk utility reports unavailable/unmounted.

12. `test_disk_empty_mount_point(fs)` — Create mount point directory but no contents. Assert appropriate response (may report as unmounted/empty depending on implementation).

For SyncDetector tests, you'll need to construct the detector with appropriate arguments. Read the constructor to understand what it needs (database connection, library path, etc.). Use in_memory_db._conn for the database connection and fake filesystem paths for the library.
  </action>
  <verify>
Run `cd /Users/david/projects/objectivism-library-semantic-search && python -m pytest tests/test_sync.py -v --tb=short 2>&1 | tail -30` to confirm all sync tests pass.
  </verify>
  <done>12+ sync tests covering SyncDetector classification (new/unchanged/modified/deleted), mtime optimization with epsilon tolerance, safety guard (triggers on >50% missing, passes when enough present), and disk utility (mounted/unmounted/empty). All pass using pyfakefs + in-memory SQLite.</done>
</task>

<task type="auto">
  <name>Task 2: SessionManager tests</name>
  <files>tests/test_session.py</files>
  <action>
Read `src/objlib/session/manager.py` first to understand:
- SessionManager constructor (takes sqlite3.Connection)
- create(name) method → returns session_id (UUID string)
- get_session(session_id) → returns session row
- get_events(session_id) → returns list of event rows
- add_event(session_id, event_type, payload_data) → returns event_id
- find_by_prefix(prefix) → returns session or None (None if 0 or 2+ matches)
- Valid event_types: search, view, synthesize, note, error (from CHECK constraint)

**CRITICAL:** SessionManager takes `sqlite3.Connection` directly (not Database wrapper). Use `in_memory_db._conn` to get the connection. The connection MUST have `row_factory = sqlite3.Row` set (already done by in_memory_db fixture).

Tests to implement:

**Session CRUD:**

1. `test_create_session(in_memory_db)` — `mgr = SessionManager(in_memory_db._conn)`. Create session with name. Assert returned session_id is a valid UUID string.

2. `test_get_session(in_memory_db)` — Create session, then get_session by ID. Assert name matches.

3. `test_get_session_nonexistent(in_memory_db)` — get_session with random UUID. Assert returns None.

4. `test_create_multiple_sessions(in_memory_db)` — Create 3 sessions. Assert all have unique IDs.

**Event semantics:**

5. `test_add_event(in_memory_db)` — Create session, add_event with type "search" and payload {"query": "free will"}. get_events returns 1 event with correct type and payload.

6. `test_add_multiple_events(in_memory_db)` — Add 3 events to same session. get_events returns 3 events in chronological order.

7. `test_event_types_valid(in_memory_db)` — Add events with each valid type: search, view, synthesize, note, error. All succeed.

8. `test_event_type_invalid(in_memory_db)` — Add event with type "invalid_type". Assert raises ValueError (or IntegrityError from CHECK constraint).

9. `test_append_only_no_update_method(in_memory_db)` — Assert `SessionManager` has NO `update_event` or `delete_event` methods (per decision [04-04] append-only semantics). Use `hasattr()` check.

10. `test_append_only_no_modify_method(in_memory_db)` — Assert `SessionManager` has NO `modify_event` method. Events can only be added.

**UUID prefix lookup:**

11. `test_find_by_prefix_exact(in_memory_db)` — Create session. Use first 8 chars of UUID as prefix. Assert find_by_prefix returns the session.

12. `test_find_by_prefix_ambiguous(in_memory_db)` — Create 2+ sessions. Use a 1-character prefix (likely matches both). Assert find_by_prefix returns None (ambiguous per decision [04-04]).

13. `test_find_by_prefix_no_match(in_memory_db)` — Use a prefix that matches no sessions (e.g., "zzzzzzz"). Assert returns None.

14. `test_find_by_prefix_full_uuid(in_memory_db)` — Use the full UUID as prefix. Assert returns the session.

**Active session detection:**

15. `test_active_session_from_env(in_memory_db, monkeypatch)` — Set OBJLIB_SESSION env var to a session ID. Assert active session detection returns that ID. (Use monkeypatch.setenv.)

16. `test_no_active_session(in_memory_db, monkeypatch)` — Ensure OBJLIB_SESSION is not set. Assert active session detection returns None. (Use monkeypatch.delenv with raising=False.)
  </action>
  <verify>
Run `cd /Users/david/projects/objectivism-library-semantic-search && python -m pytest tests/test_session.py -v --tb=short 2>&1 | tail -30` to confirm all session tests pass.

Then run `python -m pytest tests/ -x -q --tb=short 2>&1 | tail -10` to confirm no regressions.
  </verify>
  <done>16+ session tests covering create/retrieve, event adding (valid types, invalid type rejection), append-only verification (no update/delete methods), UUID prefix lookup (exact, ambiguous, no-match), and active session env var detection. All pass. No regressions.</done>
</task>

</tasks>

<verification>
- `python -m pytest tests/test_sync.py tests/test_session.py -v` — all sync and session tests pass
- `python -m pytest tests/ -x -q` — all existing tests still pass (no regressions)
- No API calls made, no disk I/O (pyfakefs + in-memory SQLite)
</verification>

<success_criteria>
- test_sync.py: 12+ tests for SyncDetector (classification, mtime, safety guard) and disk utility
- test_session.py: 16+ tests for SessionManager (CRUD, events, append-only, prefix lookup, env var)
- pyfakefs + in-memory SQLite coexist cleanly in sync tests
- Append-only semantics verified (no update/delete methods on SessionManager)
- Safety guard tested both triggered and non-triggered states
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/06.3-test-foundation-canon-governance/06.3-04-SUMMARY.md`
</output>
