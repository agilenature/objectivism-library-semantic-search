# CLARIFICATIONS-ANSWERED.md

## Phase 6.3: Test Foundation & Canon Governance ‚Äî Decisions

**Generated:** 2026-02-18
**Mode:** YOLO (balanced strategy ‚Äî consensus options chosen, single-provider recommendations selected when well-reasoned)
**Source:** Auto-generated by discuss-phase-ai --yolo

---

## Decision Summary

**Total questions:** 8
**Tier 1 (Blocking):** 3 answered
**Tier 2 (Important):** 3 answered
**Tier 3 (Polish):** 2 answered

---

## Tier 1: Blocking Decisions

### Q1: Filesystem Simulation Strategy

**YOLO DECISION:** **Option A ‚Äî pyfakefs**

**Rationale:**
- Confidence level: ‚úÖ Consensus (both providers)
- Add `pyfakefs` as a test dependency: `pip install pyfakefs`
- No refactoring of scanner or SyncDetector code needed
- `pyfakefs` integrates natively with pytest via `pyfakefs` fixture
- Correctly handles the mtime epsilon behavior documented in `[05-04]`
- Strategy: Choose least-invasive option for retroactive tests

**Before implementing:** Check `src/objlib/sync/` for any inotify/kqueue calls (these require special handling with pyfakefs). If only `os.stat`/`pathlib.Path` calls are used, pyfakefs works transparently.

**Fixture pattern to use:**
```python
def test_scanner_discovers_files(fs):  # pyfakefs injects `fs` fixture
    fs.create_file("/library/course/file.txt", contents="lecture content")
    scanner = Scanner("/library")
    result = scanner.scan()
    assert len(result.new_files) == 1
```

---

### Q2: API Mocking Level

**YOLO DECISION:** **Option A ‚Äî Mock at API client boundary (unit tests)**

**Rationale:**
- Confidence level: ‚úÖ Consensus (both providers agree on unit test approach)
- No HTTP mock server for this retroactive phase (adds complexity without proportional value)
- Focus tests on the plumbing, not the intelligence

**What to mock and how:**

For search/reranker tests (plan 06.3-03):
```python
from unittest.mock import MagicMock, patch

@pytest.fixture
def mock_gemini_search():
    mock = MagicMock()
    mock.query.return_value = [
        Citation(file_path="course/2023/week01/lecture.txt", excerpt="About reason...", ...),
        Citation(file_path="course/2023/week02/lecture.txt", excerpt="On egoism...", ...),
    ]
    return mock
```

For reranker tests: mock `GenerativeModel.generate_content()` to return deterministic `RankedResults` JSON with known scores.

For citation enrichment tests: mock the raw `retrieved_context` list from Gemini API format (with file IDs like "e0x3xq9wtglq").

For entity fuzzy matching (plan 06.3-04): no mocking needed ‚Äî the fuzzy matcher uses a local algorithm against the canonical person list.

**What NOT to test:** Whether Gemini returns relevant results for a query. That's API quality, not code correctness.

---

### Q3: Schema Migration Test Scope

**YOLO DECISION:** **Option B ‚Äî Test cumulative initialization and idempotency**

**Rationale:**
- Confidence level: ‚úÖ Consensus (both providers recommend this when discrete scripts absent)
- The database uses `CREATE TABLE IF NOT EXISTS` + `try/except ALTER TABLE` pattern (STATE.md `[06-01]`)
- This IS the migration mechanism ‚Äî test it as-is, not hypothetically

**Plan 06.3-01 must start by:** Reading `src/objlib/database.py` to catalog all tables, columns, and the exact initialization sequence. Then write tests verifying:

1. Fresh in-memory DB initializes without error (all 7 schema versions' additions present)
2. Second initialization on existing DB is idempotent (no errors, no data loss)
3. Key columns from each major schema version exist:
   - V1-V2: `files` table with `file_path`, `content_hash`, `status`, `gemini_file_id`
   - V3: AI metadata columns (`metadata_json`, `ai_category`, `ai_confidence`)
   - V4: Entity tables (`persons`, `person_alias`, `transcript_entities`)
   - V5: Enriched upload columns (`upload_attempt_count`, `last_upload_hash`)
   - V6: Passages/sessions tables
   - V7: Sync columns (`library_config` table)
4. Foreign key constraints are enforced (test with PRAGMA foreign_keys = ON)
5. Any triggers fire correctly (if they exist ‚Äî check `database.py`)

---

## Tier 2: Important Decisions

### Q4: Canon.json Template Parameterization

**YOLO DECISION:** **Option A ‚Äî Single template with placeholder variables**

**Rationale:**
- Confidence level: ‚úÖ Synthesis recommendation
- One template to maintain; simpler long-term
- Workflow-specific default rules in `rules/gsd-rules.md`, `rules/ralph-rules.md`, `rules/bmad-rules.md`

**Template variables:**
```
{{PROJECT_TITLE}}        ‚Äî from project detection
{{PROJECT_DESCRIPTION}}  ‚Äî from README or PROJECT.md
{{BRANCH}}               ‚Äî from git branch
{{PUBLIC_FOLDERS}}       ‚Äî from codebase analysis (e.g., "docs/", "src/objlib/services/")
{{EXCLUDE_FOLDERS}}      ‚Äî from codebase analysis (internal pipeline modules)
{{EXCLUDE_FILES}}        ‚Äî specific files to exclude (e.g., "cli.py")
{{RULES}}                ‚Äî from workflow-specific rules file
```

**Additional decision ‚Äî metadata field:** Add `"_canon_workflow": "gsd"` as a non-schema metadata comment at top of Canon.json (using JSON comments via `// _workflow: gsd` is not valid JSON, so use a leading underscore field). This lets `canon-update` know which workflow rules to use without re-detecting.

**Additional decision ‚Äî client-interface.md:** Generate it in the same `canon-init` execution as a separate step. Include a clearly-marked "PLACEHOLDER ‚Äî update when services layer exists" section for `src/objlib/services/`.

---

### Q5: Workflow Detection Algorithm Placement

**YOLO DECISION:** **Option A ‚Äî Algorithm in SKILL.md, signals in reference files**

**Rationale:**
- Confidence level: ‚úÖ Synthesis recommendation
- Clean separation: algorithm is stable, signals are data that changes as research evolves

**Detection priority order (hardcoded in SKILL.md):**
1. Existing `Canon.json` with `_canon_workflow` field ‚Üí use that (highest confidence)
2. BMAD config files ‚Üí signals TBD from plan 06.3-05 research
3. GSD ‚Üí `.planning/STATE.md` + `.planning/ROADMAP.md` both present
4. Ralph ‚Üí signals TBD from plan 06.3-05 research
5. Generic ‚Üí fallback (pyproject.toml or package.json present)

**Ambiguity behavior:** If multiple workflows detected with similar confidence, output a warning:
```
‚ö†Ô∏è Multiple workflow signals detected: GSD + Ralph
Defaulting to GSD (highest confidence signal).
Override: add "_canon_workflow": "ralph" to Canon.json
```
Do NOT silently pick one ‚Äî make it visible.

**Detection results:** Do NOT write detection metadata to Canon.json automatically. Write only if `_canon_workflow` is explicitly set by canon-init after user confirmation.

---

### Q6: canon-update Hook into /update-docs

**YOLO DECISION:** **Option A ‚Äî Integrate Layer 1 audit into /update-docs**

**Rationale:**
- Confidence level: ‚úÖ Synthesis recommendation
- Keeps governance integrated into existing workflow discipline
- `/update-docs` already runs after each phase; Canon audit should too

**Implementation for plan 06.3-07:**

Step 1: Read `.claude/commands/update-docs.md` to understand current structure.

Step 2: Add a final section to `update-docs`:
```
## Step N: Layer 1 Canon Audit

After updating docs, verify Canon.json is still accurate:
1. Check that all folders listed in Canon.json `folders` actually exist
2. Check for new public modules not in `folders` (new `src/objlib/services/` submodules)
3. Check for new internal modules not in `excludeFolders`
4. Check if any `rules` have become outdated (reference removed features/patterns)
5. Report: "Canon.json current" or list specific drifts found
6. If drift found: update Canon.json and note in commit message
```

The full `canon-update` skill does a deeper audit. The `update-docs` integration is a lightweight check that runs automatically. Users can run `/canon-update` explicitly for a comprehensive audit.

---

## Tier 3: Polish Decisions

### Q7: Test Coverage Targets

**YOLO DECISION:** **80% line coverage per module, functional completeness as primary gate**

- Run: `pytest --cov=src/objlib --cov-report=html tests/`
- Exclude `cli.py` from coverage measurement (Typer wiring is integration, not unit)
- Add to `pyproject.toml`:
  ```toml
  [tool.coverage.run]
  omit = ["src/objlib/cli.py", "src/objlib/__pycache__/*"]
  [tool.coverage.report]
  fail_under = 80
  ```
- Branch coverage: measured in HTML report but not a hard gate (retroactive tests can't always hit error branches)
- Primary gate for each plan: functional checklist completion (see each plan's PLAN.md)

---

### Q8: Shared Test Fixture Organization

**YOLO DECISION:** **Shared `tests/conftest.py` with real Database.initialize() call**

```python
# tests/conftest.py

import sqlite3
import pytest
from unittest.mock import MagicMock
from objlib.database import Database

@pytest.fixture
def in_memory_db():
    """Fresh initialized in-memory SQLite database."""
    conn = sqlite3.connect(":memory:")
    conn.execute("PRAGMA foreign_keys = ON")
    db = Database.__new__(Database)  # Skip __init__ path validation
    db._conn = conn
    db.initialize()  # Calls the real initialization ‚Äî tests it works
    yield db
    conn.close()

@pytest.fixture
def populated_db(in_memory_db):
    """In-memory DB with 5 canonical test files."""
    # Insert known test fixtures
    in_memory_db.upsert_file("course/2023/week01/lecture.txt", hash="abc123", size=1000)
    # ... more fixtures
    yield in_memory_db

@pytest.fixture
def mock_gemini_client():
    """Deterministic mock Gemini search client."""
    mock = MagicMock()
    mock.query.return_value = []  # Override per test as needed
    return mock
```

Use `scope="function"` (default) for all fixtures ‚Äî fresh state per test for maximum isolation. This matches the STATE.md `[02-02]` decision: "State writes commit immediately ‚Äî no transactions held across await boundaries."

---

## Implementation Order (YOLO Decisions ‚Üí Planning)

Based on these decisions, the 8 plans should be planned and executed in waves:

**Wave 1 (parallel) ‚Äî Plans 01-04:** Retroactive tests
- All use `pyfakefs` for filesystem simulation
- All use `unittest.mock` at API client boundary
- All share `tests/conftest.py` fixtures
- Schema tests verify cumulative V7 initialization

**Wave 2 (parallel with Wave 1) ‚Äî Plan 05:** Workflow research
- Produces `workflows/gsd.md`, `ralph.md`, `bmad.md` reference files
- Feeds into Wave 3 detection signals

**Wave 3 (after Wave 2) ‚Äî Plans 06-07:** Canon skill implementation
- Single template with `{{PLACEHOLDER}}` variables
- Algorithm in SKILL.md, signals in reference files
- Layer 1 audit integrated into `/update-docs`

**Wave 4 (after Wave 1 + Wave 3) ‚Äî Plan 08:** Apply and verify
- Run full test suite
- Run `/canon-update` on this project
- Verify no regressions

---

## Next Steps

1. ‚úÖ Clarifications answered (YOLO mode ‚Äî 2026-02-18)
2. ‚è≠ Proceed to `/gsd:plan-phase 6.3`
3. üìã Review YOLO decisions before implementation if needed ‚Äî particularly Q3 (audit database.py first) and Q6 (read update-docs.md before modifying)

---

*Auto-generated by discuss-phase-ai --yolo (balanced strategy)*
*Human review recommended before final implementation*
*2026-02-18*
