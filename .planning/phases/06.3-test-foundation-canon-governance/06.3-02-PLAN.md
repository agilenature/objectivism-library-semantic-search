---
phase: 06.3-test-foundation-canon-governance
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_scanner_pyfakefs.py
  - tests/test_metadata_edge.py
autonomous: true

must_haves:
  truths:
    - "Scanner discovers .txt files and skips hidden files, tiny files, and non-.txt files using pyfakefs"
    - "Scanner computes correct SHA-256 hashes on fake filesystem files"
    - "MetadataExtractor handles edge cases: unrecognized filenames, missing folders, malformed patterns"
    - "Scanner change detection correctly identifies new, modified, and deleted files"
  artifacts:
    - path: "tests/test_scanner_pyfakefs.py"
      provides: "pyfakefs-based scanner tests: discovery, hashing, filtering, change detection"
      min_lines: 100
    - path: "tests/test_metadata_edge.py"
      provides: "MetadataExtractor edge cases: graceful degradation, folder parsing failures, boundary patterns"
      min_lines: 80
  key_links:
    - from: "tests/test_scanner_pyfakefs.py"
      to: "src/objlib/scanner.py"
      via: "pyfakefs fs fixture intercepting os.walk/pathlib.Path"
      pattern: "def test_.*\\(fs"
    - from: "tests/test_metadata_edge.py"
      to: "src/objlib/metadata.py"
      via: "MetadataExtractor.extract()"
      pattern: "MetadataExtractor"
---

<objective>
Create retroactive tests for the file scanner (using pyfakefs for filesystem simulation) and metadata extractor edge cases. Tests cover file discovery, hash computation, size filtering, change detection, and metadata extraction for unusual filename patterns.

Purpose: The scanner and metadata extractor are the entry point for all data in the system. Proving they handle edge cases correctly ensures the data layer is trustworthy.
Output: test_scanner_pyfakefs.py (pyfakefs-based scanner tests), test_metadata_edge.py (edge case metadata tests).
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06.3-test-foundation-canon-governance/06.3-RESEARCH.md
@src/objlib/scanner.py
@src/objlib/metadata.py
@src/objlib/config.py
@tests/test_scanner.py
@tests/test_metadata.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: pyfakefs-based scanner tests</name>
  <files>tests/test_scanner_pyfakefs.py</files>
  <action>
Create a NEW test file `tests/test_scanner_pyfakefs.py` for scanner tests using pyfakefs. Do NOT modify the existing `tests/test_scanner.py`.

**CRITICAL pyfakefs + SQLite pitfall:** pyfakefs intercepts `open()` at the builtins level, which can conflict with C-level SQLite file operations. When combining pyfakefs with Database:
- Use `:memory:` SQLite inside pyfakefs tests (via `in_memory_db` fixture from conftest.py)
- The `fs` fixture patches os/pathlib automatically when declared as a parameter

Read `src/objlib/scanner.py` first to get exact class names, method signatures, and the `ScannerConfig` fields. Read `src/objlib/config.py` for `ScannerConfig` definition.

Tests to implement:

1. `test_discover_txt_files(fs)` — Create fake directory tree with 3 .txt files (each >100 bytes). Run `FileScanner.discover_files()` or equivalent. Assert 3 files discovered.

2. `test_skip_hidden_files(fs)` — Create `.hidden_file.txt` alongside normal files. Assert hidden file not in results.

3. `test_skip_tiny_files(fs)` — Create a file with <100 bytes content. Assert it's skipped (below min_file_size).

4. `test_skip_non_txt_files(fs)` — Create `.epub` and `.pdf` files alongside `.txt` files. Assert only `.txt` files discovered.

5. `test_compute_hash_on_fake_file(fs)` — Create a file with known content using `fs.create_file()`. Call `FileScanner.compute_hash()`. Assert hash matches `hashlib.sha256(content.encode()).hexdigest()`.

6. `test_hash_deterministic(fs)` — Same content produces same hash. Different content produces different hash.

7. `test_nested_directory_traversal(fs)` — Create deep nested structure: `/lib/Courses/Course1/Year1/Q1/file.txt`. Assert scanner traverses the full depth.

8. `test_change_detection_new_file(fs)` — Create initial files, populate database with them. Add a new file to fake filesystem. Run change detection. Assert new file detected in changeset.

9. `test_change_detection_modified_file(fs)` — Create file, record in DB. Modify file content (rewrite with different content via pyfakefs). Assert content hash change detected.

10. `test_change_detection_deleted_file(fs)` — Create files, record in DB. Remove one file from fake filesystem using `os.remove()`. Assert deletion detected.

11. `test_empty_directory(fs)` — Create an empty directory tree. Assert 0 files discovered (no crash).

12. `test_file_size_recorded_correctly(fs)` — Create file with known content. Assert reported size matches actual content length.

For tests that need both pyfakefs AND database, use this combined pattern:
```python
def test_example(fs, in_memory_db):
    # fs patches filesystem, in_memory_db provides :memory: SQLite
    fs.create_file("/library/test.txt", contents="x" * 200)
    # ... use in_memory_db for database operations
```

The `in_memory_db` fixture uses `:memory:` SQLite which doesn't touch the filesystem, so it works cleanly alongside pyfakefs.

NOTE: The scanner needs a ScannerConfig. Read `src/objlib/config.py` to understand how to construct one properly for tests. You may need to instantiate it with `library_path` pointing to the fake filesystem path and `db_path` set to `:memory:` or similar.
  </action>
  <verify>
Run `cd /Users/david/projects/objectivism-library-semantic-search && python -m pytest tests/test_scanner_pyfakefs.py -v --tb=short 2>&1 | tail -30` to confirm all pyfakefs scanner tests pass.
  </verify>
  <done>12+ pyfakefs-based scanner tests covering file discovery, hidden/tiny/non-txt filtering, hash computation, nested traversal, change detection (new/modified/deleted), empty directories, and size recording. All pass without touching real disk.</done>
</task>

<task type="auto">
  <name>Task 2: MetadataExtractor edge case tests</name>
  <files>tests/test_metadata_edge.py</files>
  <action>
Create a NEW test file `tests/test_metadata_edge.py` for edge cases not covered by existing `tests/test_metadata.py`.

Read `src/objlib/metadata.py` first to understand:
- The COMPLEX_PATTERN and SIMPLE_PATTERN regexes
- The `extract()` method and what it returns
- Folder metadata extraction logic
- The graceful degradation behavior (unrecognized -> MINIMAL quality)

Tests to implement:

1. `test_unrecognized_filename_gets_minimal_quality()` — Filename like "random_notes.txt". Assert quality is MINIMAL (not NONE). Assert topic is derived from filename stem.

2. `test_simple_pattern_three_parts()` — "Course Name - Lesson 01 - Topic Name.txt". Assert course, lesson_number, topic extracted correctly.

3. `test_complex_pattern_year_quarter_week()` — "Course - Year 1 - Q2 - Week 3 - Topic Name.txt". Assert year=1, quarter=2, week=3 extracted.

4. `test_filename_with_no_dashes()` — "JustAFilename.txt". Assert graceful degradation to MINIMAL.

5. `test_filename_with_extra_dashes()` — "Course - Sub-Topic - Part 1 - Extra - Stuff.txt". Assert it handles extra segments gracefully.

6. `test_folder_metadata_extraction()` — File at path "/Courses/My Course/subfolder/file.txt". Assert course metadata extracted from folder hierarchy.

7. `test_folder_overridden_by_filename()` — If both folder and filename provide course name, filename takes precedence (per decision [01-02]).

8. `test_missing_lesson_number()` — "Course Name - Introduction to Topic.txt" (no lesson number). Assert lesson_number is None or absent, but course and topic still extracted.

9. `test_lesson_number_double_digits()` — "Course - Lesson 10 - Topic.txt". Assert lesson_number=10.

10. `test_lesson_number_triple_digits()` — "Course - Lesson 100 - Topic.txt". Assert lesson_number=100.

11. `test_txt_extension_required()` — "document.pdf" passed to extract(). Assert appropriate handling (extraction still produces metadata from stem).

12. `test_unicode_in_filename()` — Filename with unicode characters. Assert no crash, metadata extracted from what's parseable.

13. `test_extraction_failure_flags()` — Unrecognized filename should have `_unparsed_filename: true` in metadata (per decision [01-02]).

14. `test_whitespace_in_course_name()` — "  Course Name  - Lesson 01 - Topic.txt". Assert course name is trimmed.

Read the existing `tests/test_metadata.py` first to avoid duplicating tests. Focus on edge cases NOT already covered.
  </action>
  <verify>
Run `cd /Users/david/projects/objectivism-library-semantic-search && python -m pytest tests/test_metadata_edge.py -v --tb=short 2>&1 | tail -30` to confirm all metadata edge case tests pass.

Then run `python -m pytest tests/ -x -q --tb=short 2>&1 | tail -10` to confirm no regressions.
  </verify>
  <done>14+ metadata edge case tests covering graceful degradation, pattern boundaries, folder extraction, override precedence, missing fields, unicode handling, and extraction failure flags. All pass. No regressions.</done>
</task>

</tasks>

<verification>
- `python -m pytest tests/test_scanner_pyfakefs.py -v` — all pyfakefs scanner tests pass
- `python -m pytest tests/test_metadata_edge.py -v` — all metadata edge case tests pass
- `python -m pytest tests/ -x -q` — all existing tests still pass (no regressions)
- No tests require disk I/O or API calls
</verification>

<success_criteria>
- test_scanner_pyfakefs.py: 12+ tests covering discovery, filtering, hashing, change detection via pyfakefs
- test_metadata_edge.py: 14+ tests covering edge cases for MetadataExtractor
- pyfakefs + in-memory SQLite coexist without conflicts
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/06.3-test-foundation-canon-governance/06.3-02-SUMMARY.md`
</output>
