---
phase: 06.3-test-foundation-canon-governance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - tests/conftest.py
  - tests/test_schema.py
  - tests/test_database_crud.py
autonomous: true

must_haves:
  truths:
    - "Fresh in-memory Database.initialize() creates all 16 tables and 2 triggers without error"
    - "Second initialize() call on existing DB is idempotent (no errors, no data loss)"
    - "Foreign key constraints are enforced on in-memory connections"
    - "All ~25 CRUD methods work correctly against in-memory SQLite"
    - "Person table is seeded with 15 canonical entries after initialization"
  artifacts:
    - path: "tests/conftest.py"
      provides: "Shared fixtures: in_memory_db, populated_db, mock_gemini_client"
      contains: "Database.__new__"
    - path: "tests/test_schema.py"
      provides: "Schema initialization, idempotency, tables, triggers, foreign keys, seed data"
      min_lines: 80
    - path: "tests/test_database_crud.py"
      provides: "CRUD method tests: upsert, status, sync columns, passages, entities, config"
      min_lines: 150
    - path: "pyproject.toml"
      provides: "pyfakefs dev dependency, coverage configuration"
      contains: "pyfakefs"
  key_links:
    - from: "tests/conftest.py"
      to: "src/objlib/database.py"
      via: "Database.__new__() + initialize()"
      pattern: "Database\\.__new__"
    - from: "tests/test_schema.py"
      to: "src/objlib/database.py"
      via: "PRAGMA user_version and sqlite_master queries"
      pattern: "sqlite_master"
---

<objective>
Establish the test infrastructure (conftest.py fixtures, pyproject.toml config) and create retroactive tests for the database layer: schema initialization V1-V7, idempotency, triggers, foreign keys, seed data, and all ~25 CRUD methods.

Purpose: The in_memory_db fixture is the foundation all other test plans depend on. Schema and CRUD tests prove the data layer is stable before the TUI client is built on top of it.
Output: Updated conftest.py with shared fixtures, pyproject.toml with pyfakefs + coverage config, test_schema.py (schema verification), test_database_crud.py (CRUD method tests).
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06.3-test-foundation-canon-governance/06.3-CONTEXT.md
@.planning/phases/06.3-test-foundation-canon-governance/06.3-RESEARCH.md
@src/objlib/database.py
@tests/conftest.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update pyproject.toml and conftest.py with test infrastructure</name>
  <files>pyproject.toml, tests/conftest.py</files>
  <action>
**pyproject.toml changes:**

1. Add `pyfakefs>=5.7` to the `[project.optional-dependencies] dev` list (after existing entries).

2. Add coverage configuration sections:
```toml
[tool.coverage.run]
omit = ["src/objlib/cli.py", "src/objlib/__pycache__/*"]

[tool.coverage.report]
fail_under = 80
```

**tests/conftest.py changes:**

Add three new fixtures AFTER the existing fixtures (do NOT modify or remove existing `tmp_db`, `tmp_library`, `scanner_config`, `metadata_extractor` fixtures):

```python
import sqlite3
from unittest.mock import MagicMock

@pytest.fixture
def in_memory_db():
    """Fresh initialized in-memory SQLite database.

    Uses Database.__new__() to bypass __init__ path validation.
    Calls real Database.initialize() to test actual schema setup.
    """
    conn = sqlite3.connect(":memory:")
    conn.row_factory = sqlite3.Row
    conn.execute("PRAGMA foreign_keys = ON")
    db = Database.__new__(Database)  # Skip __init__ path validation
    db._conn = conn
    db.db_path = ":memory:"
    db.initialize()
    yield db
    conn.close()


@pytest.fixture
def populated_db(in_memory_db):
    """In-memory database pre-populated with 5 test files and known metadata.

    Inserts files with different statuses and metadata for testing queries.
    """
    test_files = [
        ("/library/Courses/OPAR/OPAR - Lesson 01 - Metaphysics.txt", "hash_a", 5000, "pending"),
        ("/library/Courses/OPAR/OPAR - Lesson 02 - Epistemology.txt", "hash_b", 6000, "uploaded"),
        ("/library/Courses/ITOE/ITOE - Lesson 01 - Concepts.txt", "hash_c", 4000, "uploaded"),
        ("/library/Courses/HOP/HOP - Lesson 01 - Ancient Greece.txt", "hash_d", 7000, "pending"),
        ("/library/Courses/Ethics/Ethics - Lesson 01 - Virtue.txt", "hash_e", 3000, "failed"),
    ]
    for file_path, content_hash, size, status in test_files:
        in_memory_db.upsert_file(file_path, content_hash, size)
        if status != "pending":
            in_memory_db.update_file_status(file_path, status)
    yield in_memory_db


@pytest.fixture
def mock_gemini_client():
    """Mock Google GenAI client with deterministic responses.

    Provides MagicMock with .models.generate_content() returning
    a response with .parsed attribute for Pydantic structured output.
    """
    mock = MagicMock()
    mock.models.generate_content.return_value = MagicMock(parsed=None)
    return mock
```

CRITICAL: The `in_memory_db` fixture uses `Database.__new__(Database)` to skip `__init__` which validates filesystem paths. The `conn.row_factory = sqlite3.Row` MUST be set before `initialize()`. `PRAGMA foreign_keys = ON` MUST be set explicitly on in-memory connections.

Verify existing tests still pass after adding new fixtures (names don't conflict).
  </action>
  <verify>
Run `cd /Users/david/projects/objectivism-library-semantic-search && python -m pytest tests/ -x -q --tb=short 2>&1 | tail -20` to confirm existing tests still pass with updated conftest.py.
  </verify>
  <done>pyproject.toml has pyfakefs + coverage config. conftest.py has in_memory_db, populated_db, mock_gemini_client fixtures alongside existing fixtures. All existing tests still pass.</done>
</task>

<task type="auto">
  <name>Task 2: Schema verification tests and CRUD method tests</name>
  <files>tests/test_schema.py, tests/test_database_crud.py</files>
  <action>
**File 1: `tests/test_schema.py`** — Schema initialization and structural verification.

Tests to implement:

1. `test_fresh_schema_all_16_tables(in_memory_db)` — Query `sqlite_master WHERE type='table'`. Assert all 16 tables exist: files, _processing_log, _extraction_failures, _skipped_files, upload_operations, upload_batches, upload_locks, file_metadata_ai, file_primary_topics, wave1_results, person, person_alias, transcript_entity, passages, sessions, session_events, library_config. (Note: files_v7 is a transient table that gets renamed, so it should NOT exist after initialization.)

2. `test_schema_idempotency(in_memory_db)` — Call `in_memory_db.initialize()` a second time. Assert no errors and all 16 tables still present. Query row counts to ensure seed data not duplicated.

3. `test_triggers_exist(in_memory_db)` — Query `sqlite_master WHERE type='trigger'`. Assert `update_files_timestamp` and `log_status_change` triggers exist.

4. `test_trigger_update_files_timestamp(in_memory_db)` — Insert a file, record its `updated_at`. Update the file's status. Assert `updated_at` changed (trigger fired).

5. `test_trigger_log_status_change(in_memory_db)` — Insert a file (status='pending'). Update status to 'uploaded'. Query `_processing_log` for the file. Assert a log entry exists with old_status='pending', new_status='uploaded'.

6. `test_foreign_keys_enforced(in_memory_db)` — Attempt to INSERT into `_processing_log` with a `file_path` that doesn't exist in `files`. Assert `sqlite3.IntegrityError` is raised. Test at least 2 FK relationships (e.g., _processing_log.file_path, session_events.session_id).

7. `test_person_seed_data(in_memory_db)` — Query `person` table. Assert exactly 15 rows. Assert known entries exist: "Ayn Rand", "Leonard Peikoff", "Yaron Brook" (check `canonical_name` column).

8. `test_user_version_is_7(in_memory_db)` — `PRAGMA user_version` returns 7.

9. `test_files_table_v7_columns(in_memory_db)` — `PRAGMA table_info(files)` includes V7 columns: mtime, orphaned_gemini_file_id, enrichment_version, last_sync_at, sync_hash.

10. `test_upload_locks_single_row_constraint(in_memory_db)` — Insert into `upload_locks(lock_id, ...)` with lock_id=1 succeeds. Insert with lock_id=2 should fail due to CHECK(lock_id = 1).

**File 2: `tests/test_database_crud.py`** — CRUD method tests against in-memory database.

Tests to implement (use `in_memory_db` or `populated_db` fixture as appropriate):

1. `test_upsert_file_insert(in_memory_db)` — upsert_file with a new path. Assert row exists in files table with correct hash/size. Status should be 'pending'.

2. `test_upsert_file_update_changed_hash(in_memory_db)` — upsert_file twice with different hashes. Assert status resets to 'pending' on hash change.

3. `test_upsert_file_unchanged_hash(in_memory_db)` — upsert_file, change status to 'uploaded', upsert again with same hash. Assert status stays 'uploaded' (not reset).

4. `test_upsert_files_batch(in_memory_db)` — upsert_files with list of 3 file tuples. Assert all 3 exist.

5. `test_get_all_active_files(populated_db)` — Assert returns all 5 files (none deleted).

6. `test_mark_deleted(populated_db)` — mark_deleted on one file. Assert get_all_active_files returns 4 files.

7. `test_get_status_counts(populated_db)` — Assert counts match: pending=2, uploaded=2, failed=1.

8. `test_log_skipped_file(in_memory_db)` — log_skipped_file. Assert row in _skipped_files.

9. `test_log_extraction_failure(in_memory_db)` — After inserting a file, log_extraction_failure. Assert row in _extraction_failures.

10. `test_get_pending_files(populated_db)` — Assert returns only the 2 pending files.

11. `test_update_file_status(in_memory_db)` — Insert file, update to 'uploaded'. Assert new status.

12. `test_filter_files_by_metadata(populated_db)` — After setting metadata on files with upsert, test filter_files_by_metadata with a known filter.

13. `test_upsert_passage(in_memory_db)` — upsert_passage. Assert row in passages table. Call again with same passage_id — assert last_seen_at updated.

14. `test_mark_stale_passages(in_memory_db)` — Insert file, upsert 2 passages. mark_stale_passages for file. Assert both passages have is_stale=1.

15. `test_save_transcript_entities(in_memory_db)` — Insert a file. save_transcript_entities with entity data. Assert rows in transcript_entity. Call again (idempotent delete-then-insert). Assert same count.

16. `test_get_entity_stats(in_memory_db)` — After saving entities, get_entity_stats returns correct counts.

17. `test_mark_missing_and_get_missing(in_memory_db)` — Insert file, mark_missing. get_missing_files returns it.

18. `test_get_orphaned_files_and_clear(in_memory_db)` — Insert file with orphaned_gemini_file_id. get_orphaned_files returns it. clear_orphan removes the orphaned ID.

19. `test_set_and_get_library_config(in_memory_db)` — set_library_config("key", "value"). get_library_config("key") returns "value". set_library_config("key", "new_value") updates it.

20. `test_update_file_sync_columns(in_memory_db)` — Insert file. update_file_sync_columns with mtime, sync_hash, last_sync_at. get_file_with_sync_data returns correct values.

21. `test_get_all_active_files_with_mtime(populated_db)` — After setting mtime on files, assert method returns files with mtime data.

Read `src/objlib/database.py` first to get exact method signatures and parameter names. Each test should use the real method names and correct argument patterns from the actual Database class.
  </action>
  <verify>
Run `cd /Users/david/projects/objectivism-library-semantic-search && python -m pytest tests/test_schema.py tests/test_database_crud.py -v --tb=short 2>&1 | tail -40` to confirm all new tests pass.

Then run `python -m pytest tests/ -x -q --tb=short 2>&1 | tail -10` to confirm no regressions in existing tests.
  </verify>
  <done>test_schema.py has 10+ tests covering all 16 tables, 2 triggers (including fire verification), FK enforcement, seed data, V7 columns, user_version, and idempotency. test_database_crud.py has 20+ tests covering all major CRUD methods. All tests pass. No regressions.</done>
</task>

</tasks>

<verification>
- `python -m pytest tests/test_schema.py -v` — all schema tests pass
- `python -m pytest tests/test_database_crud.py -v` — all CRUD tests pass
- `python -m pytest tests/ -x -q` — all existing tests still pass (no regressions)
- `grep "pyfakefs" pyproject.toml` — dependency present
- `grep "fail_under" pyproject.toml` — coverage gate present
</verification>

<success_criteria>
- conftest.py has in_memory_db, populated_db, mock_gemini_client fixtures
- pyproject.toml has pyfakefs>=5.7 in dev deps and coverage config
- test_schema.py verifies all 16 tables, 2 triggers, 9 FK relationships, seed data, V7 columns, user_version=7, idempotency
- test_database_crud.py covers upsert_file, upsert_files, get_all_active_files, mark_deleted, get_status_counts, log_skipped_file, log_extraction_failure, get_pending_files, update_file_status, filter_files_by_metadata, upsert_passage, mark_stale_passages, save_transcript_entities, get_entity_stats, mark_missing, get_orphaned_files, clear_orphan, set/get_library_config, update_file_sync_columns, get_file_with_sync_data, get_all_active_files_with_mtime
- All tests green, zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/06.3-test-foundation-canon-governance/06.3-01-SUMMARY.md`
</output>
