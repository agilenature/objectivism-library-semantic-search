# CLARIFICATIONS-NEEDED.md

## Phase 13: State Column Retirement ‚Äî Stakeholder Decisions Required

**Generated:** 2026-02-22
**Mode:** Multi-provider synthesis (OpenAI gpt-5.2, Gemini Pro, Perplexity Sonar Deep Research)
**Source:** 3 AI providers analyzed Phase 13 requirements

---

## Decision Summary

**Total questions:** 7
**Tier 1 (Blocking):** 4 questions ‚Äî must answer before planning
**Tier 2 (Important):** 2 questions ‚Äî should answer for quality
**Tier 3 (Polish):** 1 question ‚Äî can defer to implementation

---

## Tier 1: Blocking Decisions (‚úÖ Consensus)

### Q1: Status Value Mapping ‚Äî What Legacy Values Exist?

**Question:** What are the actual `DISTINCT status` values currently stored in `data/library.db`, and what is the definitive mapping of each to a `gemini_state` value?

**Why it matters:** The mapping dict is the core artifact of plan `13-01`. Without knowing the actual live values, any mapping is speculative. The mapping determines what the audit script must handle.

**Options identified by providers:**

**A. Known v1 pipeline values (most likely)**
- `'uploaded'` ‚Üí `'indexed'` (or `'untracked'` if Phase 8 reset means they're no longer truly indexed)
- `'pending'` ‚Üí `'untracked'`
- `'failed'` ‚Üí `'failed'`
- `'skipped'` ‚Üí `'untracked'`
- `NULL` ‚Üí `'untracked'`
_(Proposed by: OpenAI, Gemini, Perplexity)_

**B. Status reflects v1 state, not Gemini state**
- `'uploaded'` maps to `'untracked'` NOT `'indexed'` because Phase 8 reset all gemini_state to `'untracked'`, meaning a file's legacy `status='uploaded'` means it WAS uploaded to the old store, but the current `gemini_state` already reflects the true current state
- In this case, `status` values are irrelevant ‚Äî only `gemini_state` matters
_(Proposed by: Gemini analysis of Phase 8 pre-reset)_

**Synthesis recommendation:** ‚úÖ **Option B** ‚Äî `gemini_state` is already authoritative. The `status` column is legacy metadata about v1 upload state, not current Gemini state. The inventory should discover what values exist, but the mapping is: all `status` values ‚Üí "irrelevant, `gemini_state` is truth."

**Sub-questions:**
- Run `sqlite3 data/library.db "SELECT DISTINCT status FROM files"` to see actual values before planning
- Do any code paths use `status` values to drive logic (not just display them)?

---

### Q2: Are Any Code Paths Still Writing to `status`?

**Question:** Does any current code path write to the `status` column, or has it been write-frozen since Phase 8?

**Why it matters:** If writes still happen, the migration window is truly "open." If writes stopped at Phase 8, the window is already effectively closed and Phase 13 only needs to clean up reads.

**Options identified by providers:**

**A. Status column is already write-frozen**
- FSM is the sole write path for all gemini-related state since Phase 8
- `status` was not updated during Phase 12 FSM upload
- Retirement is purely a read-site cleanup
_(Proposed by: OpenAI, Perplexity)_

**B. Some legacy code path still writes `status`**
- Scanner, sync, or CLI might still update `status` as part of their normal operation
- Requires explicitly stopping those writes before retiring reads
_(Risk flagged by: Gemini)_

**Synthesis recommendation:** ‚ö†Ô∏è **Option A is assumed correct** ‚Äî the FSM audit in Phase 12 (SC-4) confirmed all gemini_state write sites go through FSM transition methods. But plan `13-01` must grep for any remaining `status` writes to verify.

---

### Q3: SC-1 Inventory Format ‚Äî What Constitutes the "Complete List"?

**Question:** What format and location should the SC-1 status-to-gemini_state query mapping inventory take, and how granular must it be?

**Why it matters:** SC-1 requires "a complete list committed to the repository showing the old query, the new query, and which module/function it lives in." This must be defined before implementation so the deliverable is clear.

**Options identified by providers:**

**A. Markdown doc with table format**
- File: `docs/migrations/phase13-status-inventory.md`
- Columns: file path, line number, old code, new code, status
- Generated by script, committed manually
_(Proposed by: OpenAI, Perplexity)_

**B. Inline commit of the mapping + test gate**
- Python dict in `src/objlib/migration/` that maps each site
- CI test that fails if `grep -r '"status"' src/ tests/` finds any results
- Committed as part of 13-02 execution
_(Proposed by: OpenAI)_

**Synthesis recommendation:** ‚úÖ **Option A** for the committed artifact (satisfies SC-1 literally), plus a grep verification in 13-02 to confirm zero remaining reads post-migration.

---

### Q4: Migration Window End ‚Äî Drop Column or Keep as Zombie?

**Question:** Should `status` be physically `DROP COLUMN`'d in Phase 13, or kept as a frozen/ignored zombie column?

**Why it matters:** SC-3 requires "an explicit defined scope ... when `status` will be dropped or made derived." The choice determines the DB migration complexity.

**Options identified by providers:**

**A. Physical DROP COLUMN in Phase 13 plan 13-02** _(Proposed by: OpenAI)_
- Cleanest outcome; requires SQLite table rewrite
- Any missed code path causes runtime column-not-found error (good: forces discovery)
- After drop, there is no migration window ‚Äî it's closed

**B. Soft Deprecation: make `status` a Python property computed from `gemini_state`** _(Proposed by: Gemini)_
- Keep physical column; stop writing it; any read returns derived value
- Safer but leaves a zombie column indefinitely
- DROP deferred to Phase 14

**C. Rename to `status_legacy` with a note** _(Proposed by: Perplexity)_
- One-release safety net before hard drop
- Adds complexity without much benefit if inventory is complete

**Synthesis recommendation:** ‚úÖ **Option A (DROP in 13-02)** ‚Äî The expand-migrate-contract cycle is effectively done (Phase 8 added gemini_state, Phase 12 proved FSM works). Phase 13 is the "contract" phase. A clean DROP eliminates ambiguity and satisfies SC-3's "no open-ended dual-write period." SQLite's table rewrite is fast for 1,748 rows.

---

## Tier 2: Important Decisions

### Q5: DB CHECK Constraint for `gemini_state`?

**Question:** Should a `CHECK (gemini_state IN ('untracked','uploading','processing','indexed','failed'))` constraint be added to the `files` table as part of Phase 13?

**Why it matters:** FSM-03 requires plain string enum storage "stable across library version upgrades." A DB constraint enforces this even if application code changes.

**Options identified by providers:**

**A. Add CHECK constraint via new DB migration** _(Proposed by: OpenAI, Perplexity)_
- Enforced at DB level forever
- SQLite CHECK constraints are validated on INSERT/UPDATE only (not retroactively)
- Requires a V11 migration

**B. Enforce in application code only** _(Proposed by: Gemini)_
- TypeDecorator or StrEnum validation at write boundary
- No DB migration needed; FSM already provides this enforcement
- Simpler

**Synthesis recommendation:** ‚ö†Ô∏è **Option A** ‚Äî add CHECK constraint in the DB migration that also drops `status`. Defense-in-depth. SQLite CHECK is cheap and the constraint is permanent protection.

---

### Q6: Plan Granularity ‚Äî Two Plans or Three?

**Question:** The roadmap specifies 2 plans (13-01 audit, 13-02 migration). Is that the right granularity given the scope?

**Why it matters:** If the audit in 13-01 reveals many query sites, 13-02 could be large. If the audit shows few sites (likely given FSM isolation), the plans might be combinable.

**Options identified by providers:**

**A. Keep 2 plans as designed** _(Roadmap spec)_
- 13-01: audit, inventory, document mapping
- 13-02: migration execution, DROP, test pass

**B. Add a 13-03 if migration scope is larger than expected**
- Reserve as contingency
- Decision deferred until 13-01 audit results are known

**Synthesis recommendation:** ‚úÖ **Option A (2 plans)** ‚Äî The FSM architecture makes `status` reads likely concentrated in a small number of sites. 2 plans is appropriate. If 13-01 reveals unexpected scope, a plan can be added.

---

## Tier 3: Polish

### Q7: TUI Label Compatibility

**Question:** Should TUI status displays translate `gemini_state` values to user-friendly labels (e.g., 'indexed' ‚Üí 'Uploaded & Indexed')?

**Options:**

**A. Display gemini_state values as-is** ‚Äî Simple; consistent with internal model
**B. Add presentation layer** ‚Äî Decouple storage from display; more UX work

**Synthesis recommendation:** üîç **Option A** ‚Äî The TUI shows search results and file names, not raw status. Any filter UI can use the gemini_state values directly ('indexed', 'failed' etc. are already user-meaningful). No label translation layer warranted for Phase 13.

---

## Next Steps (YOLO Mode)

YOLO mode is active ‚Äî answers will be auto-generated in CLARIFICATIONS-ANSWERED.md.

---

*Multi-provider synthesis: OpenAI gpt-5.2 + Gemini Pro + Perplexity Sonar Deep Research*
*Generated: 2026-02-22*
*YOLO mode: Auto-answers generated automatically*
