---
phase: 16.5-strategy4-rarest-aspect-exhaustive-audit
plan: 04
subsystem: stability
model_profile: quality
autonomous: false

requires:
  - phase: 16.5-03
    provides: "metadata audit exits 0; all 1,749 files verified"
  - phase: 16.5-02
    provides: "0/1,749 misses with S1→S4a→S4b; per-file optimal queries documented"
provides:
  - "check_stability.py A7 updated: S4a fallback, max_misses=0, no exclusions"
  - "Two consecutive fresh-session STABLE runs confirmed"
  - "Phase 16.4 gate PASSED: check_stability exits 0 with zero tolerance"
  - "Phase 16-02 temporal stability protocol UNBLOCKED"
affects: [16-02]

autonomous: false  # Temporal stability runs require fresh sessions -- user must run these

goal: |
  Update check_stability.py A7 to use the S4a fallback strategy with max_misses=0
  and no exclusion filters. Achieve two consecutive fresh-session STABLE runs
  separated by at least 1 hour. This is the BLOCKING gate for Phase 16-02.

tech-stack:
  added: []
  patterns:
    - "A7 S4a fallback: build corpus_freq_map once, use per-file rarest-3-aspects query for S1 misses"
    - "max_misses=0: any miss is an UNSTABLE verdict (not tolerance-based)"
    - "No exclusion filters: all 1,749 indexed files are in scope for sampling"
---

# Phase 16.5 Plan 04: A7 Update + Zero-Tolerance Gate

## Context

Plans 16.5-01/02/03 proved that all 1,749 indexed files are retrievable via S1→S4a→S4b.
This plan updates check_stability.py A7 to use the same strategy and validates the
zero-tolerance gate.

**NOTE: Temporal stability runs require fresh Claude Code sessions.** This plan is
autonomous=false. The user must `/clear` before each stability run.

## Locked Decisions

1. **A7 uses S1 primary + S4a fallback** (S4b is needed for only ~1-2 files; add it if S4a still misses)
2. **max_misses = 0** (any miss = UNSTABLE verdict)
3. **No exclusion filters** (all indexed files eligible for sampling)
4. **sample_size = 20** (preserved from Phase 16.3-03 baseline)
5. **Corpus frequency map built once at start of A7 (O(n) DB query)**
6. **Two consecutive STABLE runs required, separated by ≥ 1 hour**
7. **Each run must be a fresh session** (user must /clear before each)

## Tasks

### Task 1: Update check_stability.py A7

Read `scripts/check_stability.py`. In the A7 assertion section:

**Current A7 behavior:**
- Builds S1 query: `"What is '{stem}' about?"`
- Checks top-K (currently top-10 or top-5?)
- Has exclusion filters (Episodes excluded, OH excluded)
- Has tolerance (max_misses = 2)

**New A7 behavior:**
1. Remove exclusion filters (all 1,749 indexed files eligible for sampling)
2. Set max_misses = 0
3. Add corpus frequency map construction at start of A7 assertion:
   ```python
   # Build corpus aspect frequency map for S4a fallback
   corpus_freq: dict[str, int] = {}
   rows = conn.execute("SELECT metadata_json FROM file_metadata_ai WHERE is_current=1").fetchall()
   for (mj,) in rows:
       try:
           for a in json.loads(mj).get("topic_aspects", []):
               corpus_freq[a] = corpus_freq.get(a, 0) + 1
       except:
           pass
   ```
4. For each sampled file, try S1 first, then S4a if S1 misses:
   ```python
   # S1: stem-only query
   stem = Path(filename).stem
   s1_query = f"What is '{stem}' about?"

   # Run S1 query...
   if not found_s1:
       # S4a fallback: rarest 3 aspects, no preamble
       ai_row = conn.execute(
           "SELECT metadata_json FROM file_metadata_ai WHERE file_path = ? AND is_current = 1",
           (file_path,)
       ).fetchone()
       aspects = []
       if ai_row and ai_row[0]:
           try:
               aspects = json.loads(ai_row[0]).get("topic_aspects", []) or []
           except:
               pass
       sorted_aspects = sorted(aspects, key=lambda a: corpus_freq.get(a, 0))
       cleaned = [re.sub(r"[*_`]", "", a) for a in sorted_aspects[:3]]
       s4a_query = " ".join(cleaned)
       # Run S4a query...
       # Mark as found if S4a returns the file in top-5
   ```
5. Add `import re` if not present
6. Set TOP_K for A7 = 5 (consistent with Phase 16.5-02 audit)

**Important:** Read the full A7 section before modifying to understand the exact code structure.
Do not change other assertions (A1-A6).

### Task 2: Run T=0 STABLE check (can be this session)

```bash
python scripts/check_stability.py --store objectivism-library --db data/library.db --sample-count 20 --verbose
```

Expected: All 7 assertions PASS, exit 0, A7: 20/20 (0 misses).

Capture full output for the temporal stability log.

**If A7 fails:**
- Identify which specific file(s) are missed
- Determine if S4b fallback is needed (add it if so)
- Re-run until A7: 20/20

### Task 3: Run T+1h STABLE check (fresh session required)

**User must /clear before this step.**

In a fresh session:
```bash
python scripts/check_stability.py --store objectivism-library --db data/library.db --sample-count 20 --verbose
```

Expected: STABLE again (exit 0, all 7 assertions PASS).

### Temporal Stability Protocol

- **Run 1 (T=0):** This session, immediately after A7 update
- **Run 2 (T+1h):** Fresh session, /clear required, at least 1 hour after Run 1
- **Both must be STABLE** — if either fails, investigate and fix before declaring gate passed

## Validation Gates

- [ ] check_stability.py A7 updated: no exclusions, max_misses=0, S4a fallback
- [ ] Run 1 (T=0): STABLE (all 7 assertions PASS, A7: 20/20)
- [ ] Run 2 (T+1h, fresh session): STABLE (all 7 assertions PASS, A7: 20/20)
- [ ] Phase 16.4 gate declared PASSED (max_misses=0 verified in production)
- [ ] STATE.md temporal stability log updated with both run timestamps

## After Gate PASSES

Update STATE.md:
- Phase 16.4 → COMPLETE (3/3 relevant plans + Phase 16.5 completed the gate)
- Phase 16.5 → IN PROGRESS → COMPLETE
- Phase 16-02 → UNBLOCKED
- Temporal stability log entries added for both STABLE runs

## Commit

Commit Task 1 (A7 update):
```
feat(stability): update A7 to S4a fallback, max_misses=0, no exclusions
```

Commit after gate passes:
```
docs(planning): Phase 16.5 gate PASSED - zero-tolerance A7 confirmed (2 consecutive STABLE)
```
