---
phase: 09-async-fsm-spike
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - .planning/phases/09-async-fsm-spike/APPROACH-SELECTION.md
  - spike/phase9_spike/integration/__init__.py
  - spike/phase9_spike/integration/scaffold.py
  - spike/phase9_spike/integration/test_scaffold.py
autonomous: true

must_haves:
  truths:
    - "The approach selection document contains candidates tested, test matrix with pass/fail per criterion, evidence artifacts, and rationale for the final choice"
    - "The approach selection document is committed to the repository at .planning/phases/09-async-fsm-spike/APPROACH-SELECTION.md before Phase 10 begins"
    - "An integration scaffold demonstrates how the chosen FSM approach will integrate with the existing AsyncUploadStateManager pattern in Phase 10"
  artifacts:
    - path: ".planning/phases/09-async-fsm-spike/APPROACH-SELECTION.md"
      provides: "Approach selection documentation with candidates, test matrix, evidence, and rationale"
      contains: "Test Matrix"
      min_lines: 80
    - path: "spike/phase9_spike/integration/scaffold.py"
      provides: "Integration scaffold showing FSM-to-AsyncUploadStateManager bridge pattern"
      contains: "FileTransitionManager"
      min_lines: 40
    - path: "spike/phase9_spike/integration/test_scaffold.py"
      provides: "Integration scaffold tests proving the bridge pattern works"
      min_lines: 30
  key_links:
    - from: ".planning/phases/09-async-fsm-spike/APPROACH-SELECTION.md"
      to: "spike/phase9_spike/harness.py"
      via: "references harness output as evidence"
      pattern: "harness"
    - from: "spike/phase9_spike/integration/scaffold.py"
      to: "spike/phase9_spike/protocol.py"
      via: "uses FileStateMachineProtocol for adapter instantiation"
      pattern: "FileStateMachineProtocol"
    - from: "spike/phase9_spike/integration/scaffold.py"
      to: "src/objlib/upload/state.py"
      via: "demonstrates how FSM replaces direct state writes in Phase 10"
      pattern: "AsyncUploadStateManager"
---

<objective>
Document the FSM approach selection with full evidence and create an integration scaffold showing how the chosen approach will bridge into the existing upload pipeline for Phase 10.

Purpose: Phase 9 success criterion #3 requires committed documentation comparing candidates with evidence. Additionally, Phase 10 needs a clear integration pattern showing how the FSM adapter connects to the existing `AsyncUploadStateManager` -- providing that scaffold now de-risks Phase 10 planning.

Output: APPROACH-SELECTION.md committed to the repository with full test matrix and evidence. Integration scaffold with `FileTransitionManager` class bridging FSM adapter to the upload pipeline pattern.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-async-fsm-spike/09-CONTEXT.md
@.planning/phases/09-async-fsm-spike/09-RESEARCH.md
@.planning/phases/09-async-fsm-spike/09-01-SUMMARY.md
@src/objlib/upload/state.py
@src/objlib/upload/orchestrator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write APPROACH-SELECTION.md with full test matrix and evidence</name>
  <files>.planning/phases/09-async-fsm-spike/APPROACH-SELECTION.md</files>
  <action>
Create the approach selection document at `.planning/phases/09-async-fsm-spike/APPROACH-SELECTION.md`. This document satisfies Phase 9 success criterion #3.

The document MUST contain these sections:

**1. Executive Summary:**
- Which approach was selected (python-statemachine or hand-rolled)
- One-sentence rationale
- Confidence level

**2. Candidates Tested:**

For each candidate that was actually tested (1 or 2 depending on whether a pivot occurred):
- Name and version
- What it provides
- How it was tested (reference specific test files)

If only python-statemachine was tested (no pivot), still include a "Hand-Rolled (not tested)" entry explaining why the fallback was not needed.

If a pivot occurred, include both candidates with the failure evidence for the first and success evidence for the second.

**3. Test Matrix:**

Create a table showing pass/fail results for each criterion against each candidate:

| Criterion | python-statemachine 2.6.0 | Hand-Rolled |
|-----------|---------------------------|-------------|
| Async guard with DB query | PASS/FAIL | PASS/FAIL/N/A |
| start_value string support | PASS/FAIL | N/A |
| Trigger argument injection | PASS/FAIL | PASS/FAIL/N/A |
| No internal event loop creation | PASS/FAIL | PASS/FAIL/N/A |
| 10 concurrent transitions (diff files) | X/10 success | X/10 success/N/A |
| Same-file rejection (10 attempts) | 1 success, 9 rejected | 1/9/N/A |
| Pre-commit error recovery | state unchanged: PASS/FAIL | PASS/FAIL/N/A |
| Post-commit error recovery | state=failed: PASS/FAIL | PASS/FAIL/N/A |
| Guard error recovery | state unchanged: PASS/FAIL | PASS/FAIL/N/A |
| Thread leak check | before/after counts | counts/N/A |
| Task leak check | before/after counts | counts/N/A |
| DB invariants after all tests | 0 violations: PASS/FAIL | 0/N/A |

Fill in with ACTUAL values from the Plan 09-01 test runs. Do not use placeholders. Read the 09-01-SUMMARY.md for the actual results.

**4. Evidence Artifacts:**

Reference the actual outputs from the Plan 09-01 harness run:
- JSON event log: describe the total number of events, breakdown by outcome (success/rejected/failed)
- DB invariant check: list violations (should be 0)
- Thread/task counts: before and after values
- Paste or reference key excerpts from the harness output

**5. Observations and Pitfalls Encountered:**

Document anything unexpected during the spike:
- Did `start_value` work with strings? (Open question from RESEARCH.md)
- Did guard exceptions propagate correctly? (Open question from RESEARCH.md)
- Did `on_enter_state` exceptions cause library rollback? (Open question from RESEARCH.md)
- Was `activate_initial_state()` required? When?
- Any aiosqlite edge cases discovered?

**6. Rationale for Final Choice:**

Explain WHY the selected approach is correct for production integration:
- How it satisfies FSM-01 (concurrent async transitions proven)
- How it satisfies VLID-01 (documented with evidence)
- How it satisfies FSM-03 (gemini_state as plain string, not library-native serialization)
- How it maps to Phase 10 requirements (write-ahead intent, recovery paths)
- Risk assessment for production use

**7. Integration Notes for Phase 10:**

Brief guidance for the Phase 10 executor:
- Which adapter to use and how to instantiate it
- Connection factory pattern to follow
- Per-file lock pattern for the upload manager
- How error recovery maps to Phase 10's write-ahead intent pattern
  </action>
  <verify>
1. File exists: `ls -la .planning/phases/09-async-fsm-spike/APPROACH-SELECTION.md`
2. Contains required sections: `grep -c "## " .planning/phases/09-async-fsm-spike/APPROACH-SELECTION.md` -- should be >= 7 sections
3. Contains test matrix: `grep "Criterion" .planning/phases/09-async-fsm-spike/APPROACH-SELECTION.md`
4. Contains actual evidence values (no placeholders): `grep -c "PASS\|FAIL\|N/A" .planning/phases/09-async-fsm-spike/APPROACH-SELECTION.md` -- should be >= 10
5. References specific test files: `grep "test_async_guards\|test_concurrent\|test_error_injection\|test_db_invariants\|test_leak_check\|harness" .planning/phases/09-async-fsm-spike/APPROACH-SELECTION.md`
6. All open questions from RESEARCH.md are answered with observed behavior
  </verify>
  <done>
APPROACH-SELECTION.md exists with all 7 required sections. Test matrix uses actual values from Plan 09-01 runs (no placeholders). Evidence artifacts are referenced with real counts and outcomes. All open questions from RESEARCH.md are answered. The rationale maps to FSM-01, VLID-01, and FSM-03 requirements.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration scaffold bridging FSM adapter to AsyncUploadStateManager pattern</name>
  <files>
    spike/phase9_spike/integration/__init__.py
    spike/phase9_spike/integration/scaffold.py
    spike/phase9_spike/integration/test_scaffold.py
  </files>
  <action>
Create an integration scaffold that demonstrates how the chosen FSM adapter will connect to the existing upload pipeline in Phase 10. This is NOT production code -- it is a proof-of-concept that de-risks Phase 10 planning.

**1. Read the existing upload pipeline:**

Examine `src/objlib/upload/state.py` (AsyncUploadStateManager) and `src/objlib/upload/orchestrator.py` (EnrichedUploadOrchestrator) to understand:
- How state writes currently happen (direct DB writes in AsyncUploadStateManager methods like `record_upload_start`, `record_upload_complete`, etc.)
- How `_reset_existing_files()` currently works (deletes raw file but NOT store document -- the bug that FSM-05 will fix)
- What the upload pipeline flow looks like (scan -> upload -> import -> verify)

**2. `integration/scaffold.py` -- FileTransitionManager:**

Create a `FileTransitionManager` class that shows the Phase 10 integration pattern:

```python
class FileTransitionManager:
    """Demonstrates how FSM transitions replace direct state writes.

    In Phase 10, this becomes the real interface. For now, it proves
    the pattern works with the spike DB and chosen adapter.
    """

    def __init__(self, db_path: str, adapter_factory=None):
        """
        Args:
            db_path: Path to the database file
            adapter_factory: Callable that creates a FileStateMachineProtocol
                           instance from (file_id, db_path, current_state, version)
        """
        self._db_path = db_path
        self._adapter_factory = adapter_factory or self._default_factory
        self._locks: dict[str, asyncio.Lock] = defaultdict(asyncio.Lock)

    async def transition(self, file_id: str, event: str, **kwargs) -> str:
        """Execute a state transition for a file.

        1. Acquire per-file lock (locked decision #3)
        2. Read current state from DB (locked decision #5: DB is authority)
        3. Create ephemeral adapter (locked decision #6)
        4. Trigger transition
        5. Return new state
        """
        async with self._locks[file_id]:
            state, version = await read_file_state(self._db_path, file_id)
            adapter = self._adapter_factory(file_id, self._db_path, state, version)
            await adapter.trigger(event, **kwargs)
            # Re-read from DB (never trust in-memory after transition)
            new_state, _ = await read_file_state(self._db_path, file_id)
            return new_state
```

The key insight this demonstrates: `FileTransitionManager.transition()` replaces what are currently direct SQL writes in `AsyncUploadStateManager`. In Phase 10, methods like `record_upload_start()` will become `await transition_manager.transition(file_id, "start_upload")`.

Also show how `_reset_existing_files()` would be fixed (FSM-05 scaffolding):
```python
async def reset_file(self, file_id: str) -> None:
    """Reset a file to untracked state.

    Phase 10 implementation will:
    1. delete_store_document() (the missing step that caused orphan accumulation)
    2. delete_file() (the existing step)
    3. FSM transition to 'untracked' via DB write
    """
    # Scaffold only -- actual API calls are Phase 10/12
    async with self._locks[file_id]:
        state, version = await read_file_state(self._db_path, file_id)
        # In production: await delete_store_document(store_doc_id)
        # In production: await delete_file(gemini_file_id)
        # For scaffold: just reset the DB state
        rowcount = await execute_with_retry(
            self._db_path,
            "UPDATE files SET gemini_state='untracked', version=version+1 WHERE file_path=? AND version=?",
            (file_id, version)
        )
        if rowcount == 0:
            raise StaleTransitionError(f"Reset conflict for {file_id}")
```

**3. `integration/test_scaffold.py`:**

Test the integration scaffold:

a. `test_transition_manager_basic_flow` -- Create FileTransitionManager, seed a file, execute start_upload -> complete_upload -> complete_processing. Assert final state is "indexed".

b. `test_transition_manager_concurrent_safety` -- Use FileTransitionManager with 5 concurrent transitions on the same file. Assert exactly 1 succeeds (the per-file lock serializes access).

c. `test_reset_file_scaffold` -- Seed a file in "indexed" state with version=3. Call reset_file. Assert state is "untracked" and version is 4.

d. `test_adapter_factory_creates_correct_adapter` -- Verify the factory creates an adapter that satisfies `FileStateMachineProtocol` via `isinstance` check.

Run:
```bash
python -m pytest spike/phase9_spike/integration/test_scaffold.py -v --tb=long
```
  </action>
  <verify>
1. `python -m pytest spike/phase9_spike/integration/test_scaffold.py -v --tb=long` -- all integration scaffold tests pass
2. `python -c "from spike.phase9_spike.integration.scaffold import FileTransitionManager; print('Scaffold OK')"` -- imports successfully
3. The scaffold demonstrates: per-file locking, ephemeral adapter creation, DB-as-authority re-reads, and the reset_file pattern for FSM-05
4. No production code in `src/objlib/` was modified (this is purely in the spike directory)
  </verify>
  <done>
APPROACH-SELECTION.md is committed with full evidence. The integration scaffold demonstrates the Phase 10 pattern: FileTransitionManager replaces direct state writes with FSM-mediated transitions, per-file locks ensure safe concurrency, and the reset_file pattern shows how FSM-05 (delete_store_document before delete_file) will be integrated. All scaffold tests pass.
  </done>
</task>

</tasks>

<verification>
1. `.planning/phases/09-async-fsm-spike/APPROACH-SELECTION.md` exists with all 7 required sections and actual test results (no placeholders)
2. Test matrix contains pass/fail for all 12 criteria
3. Evidence artifacts reference real harness output values
4. All RESEARCH.md open questions are answered with observed behavior
5. Integration scaffold tests pass: `python -m pytest spike/phase9_spike/integration/ -v`
6. FileTransitionManager demonstrates per-file locking, ephemeral adapter creation, DB-as-authority pattern
7. reset_file scaffold shows FSM-05 pattern (comments indicate where delete_store_document will go)
8. No production code modified (all changes in spike/ and .planning/)
9. All Phase 9 success criteria are addressable:
   - SC1: Proven by Plan 09-01 harness results (referenced in APPROACH-SELECTION.md)
   - SC2: Proven by adversarial test results (referenced in APPROACH-SELECTION.md)
   - SC3: Satisfied by APPROACH-SELECTION.md itself (committed documentation)
</verification>

<success_criteria>
- APPROACH-SELECTION.md committed with candidates, test matrix, evidence, and rationale
- Integration scaffold demonstrates the Phase 10 integration pattern
- All scaffold tests pass
- Phase 9 success criterion #3 is explicitly satisfied (documented comparison committed to repo)
- No production code modified
</success_criteria>

<output>
After completion, create `.planning/phases/09-async-fsm-spike/09-02-SUMMARY.md`
</output>
