---
phase: 07-interactive-tui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/objlib/services/__init__.py
  - src/objlib/services/search.py
  - src/objlib/services/library.py
  - src/objlib/services/session.py
autonomous: true

must_haves:
  truths:
    - "SearchService.search() is async and wraps the synchronous GeminiSearchClient via asyncio.to_thread()"
    - "LibraryService provides async methods for browse/filter/view without Gemini API calls"
    - "SessionService provides async CRUD for sessions with append-only event logging"
    - "All three services import from internal modules (search/, session/, database.py) -- TUI will import only from services/"
    - "Textual >= 5.0 is declared as a project dependency"
  artifacts:
    - path: "src/objlib/services/__init__.py"
      provides: "Re-exports SearchService, LibraryService, SessionService"
      contains: "__all__"
    - path: "src/objlib/services/search.py"
      provides: "SearchService with async search(), synthesize() methods"
      contains: "asyncio.to_thread"
    - path: "src/objlib/services/library.py"
      provides: "LibraryService with async browse/filter/view methods"
      contains: "asyncio.to_thread"
    - path: "src/objlib/services/session.py"
      provides: "SessionService with async create/add_event/list/get methods"
      contains: "asyncio.to_thread"
    - path: "pyproject.toml"
      provides: "textual dependency"
      contains: "textual"
  key_links:
    - from: "src/objlib/services/search.py"
      to: "src/objlib/search/client.py"
      via: "import GeminiSearchClient"
      pattern: "from objlib\\.search\\.client import"
    - from: "src/objlib/services/library.py"
      to: "src/objlib/database.py"
      via: "import Database"
      pattern: "from objlib\\.database import Database"
    - from: "src/objlib/services/session.py"
      to: "src/objlib/session/manager.py"
      via: "import SessionManager"
      pattern: "from objlib\\.session\\.manager import SessionManager"
---

<objective>
Create the services facade layer (`src/objlib/services/`) that wraps existing internal modules into async-friendly service classes. Add Textual as a project dependency.

Purpose: The services facade is the Canon.json-mandated public API boundary. The TUI (and any future client) imports ONLY from `objlib.services`. This decouples the TUI from internal implementation details of search, session, and database modules. Every other Phase 7 plan depends on this.

Output: Three service classes (SearchService, LibraryService, SessionService) with async methods wrapping synchronous internals via `asyncio.to_thread()`, plus `textual>=5.0` in pyproject.toml.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-interactive-tui/07-CONTEXT.md
@.planning/phases/07-interactive-tui/07-RESEARCH.md

Key source files to reference:
@src/objlib/search/client.py (GeminiSearchClient, query_with_retry, resolve_store_name)
@src/objlib/search/citations.py (extract_citations, enrich_citations, build_metadata_filter)
@src/objlib/search/reranker.py (rerank_passages, apply_difficulty_ordering)
@src/objlib/search/expansion.py (expand_query)
@src/objlib/search/synthesizer.py (synthesize_answer, apply_mmr_diversity)
@src/objlib/database.py (Database context manager, get_categories_with_counts, get_courses_with_counts, get_files_by_course, get_items_by_category, filter_files_by_metadata)
@src/objlib/session/manager.py (SessionManager, VALID_EVENT_TYPES)
@src/objlib/models.py (Citation, SearchResult, AppState)
@Canon.json (rules governing import boundaries)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Textual dependency and create services package with SearchService</name>
  <files>
    pyproject.toml
    src/objlib/services/__init__.py
    src/objlib/services/search.py
  </files>
  <action>
1. Add `"textual>=5.0"` to the `dependencies` list in `pyproject.toml`.

2. Create `src/objlib/services/__init__.py`:
   - Re-export `SearchService`, `LibraryService`, `SessionService`
   - Define `__all__ = ["SearchService", "LibraryService", "SessionService"]`

3. Create `src/objlib/services/search.py` with class `SearchService`:
   - Constructor takes `api_key: str`, `store_resource_name: str`, `db_path: str`
   - Lazily creates `genai.Client` and `GeminiSearchClient` on first use (deferred import of `google.genai`)
   - `async def search(self, query: str, filters: list[str] | None = None, expand: bool = True, rerank: bool = True, mode: str = "learn") -> SearchResult`:
     - Expand query via `expand_query()` if expand=True (CPU-only, fast, can run inline)
     - Build metadata filter via `build_metadata_filter(filters)` if filters provided
     - Wrap `self._search_client.query_with_retry(search_query, metadata_filter=...)` in `asyncio.to_thread()`
     - Extract citations from grounding metadata via `extract_citations()`
     - Enrich citations in a separate `asyncio.to_thread()` call using short-lived Database connection (Canon rule #6: `with Database(self._db_path) as db: enrich_citations(citations, db)`)
     - Rerank via `asyncio.to_thread(rerank_passages, self._client, query, citations)` if rerank=True and len(citations) > 1
     - Apply difficulty ordering via `apply_difficulty_ordering(citations, mode=mode)`
     - Return `SearchResult(response_text=..., citations=..., query=query, metadata_filter=...)`
   - `async def synthesize(self, query: str, citations: list[Citation]) -> SynthesisOutput | None`:
     - Apply MMR diversity via `apply_mmr_diversity(citations)` (CPU-only, inline)
     - Wrap `synthesize_answer(self._client, query, diverse_citations)` in `asyncio.to_thread()`
     - Return the SynthesisOutput or None on failure
   - Private `_ensure_client(self)` method that initializes genai.Client and GeminiSearchClient on first call

CRITICAL: Every method that calls Gemini or SQLite MUST use `asyncio.to_thread()`. Database connections are opened and closed within the sync function passed to `to_thread()`, never held across await boundaries.
  </action>
  <verify>
    `python -c "from objlib.services import SearchService, LibraryService, SessionService; print('OK')"` prints OK (imports work, no circular dependencies).
    `python -c "import inspect; from objlib.services.search import SearchService; assert inspect.iscoroutinefunction(SearchService.search); print('async OK')"` confirms search is async.
  </verify>
  <done>SearchService class exists with async search() and synthesize() methods. All heavy I/O wrapped in asyncio.to_thread(). Textual added to dependencies.</done>
</task>

<task type="auto">
  <name>Task 2: Create LibraryService and SessionService facades</name>
  <files>
    src/objlib/services/library.py
    src/objlib/services/session.py
  </files>
  <action>
1. Create `src/objlib/services/library.py` with class `LibraryService`:
   - Constructor takes `db_path: str`
   - All methods follow the pattern: define inner sync function that opens/closes Database, wrap with `asyncio.to_thread()`
   - Methods (each is `async def`):
     - `get_categories() -> list[tuple[str, int]]` -- calls `db.get_categories_with_counts()`
     - `get_courses() -> list[tuple[str, int]]` -- calls `db.get_courses_with_counts()`
     - `get_files_by_course(course: str, year: str | None = None) -> list[dict]` -- calls `db.get_files_by_course()`
     - `get_items_by_category(category: str) -> list[dict]` -- calls `db.get_items_by_category()`
     - `filter_files(filters: list[str], limit: int = 50) -> list[dict]` -- builds filter dict from "field:value" strings, calls `db.filter_files_by_metadata()`
     - `get_file_content(file_path: str) -> str | None` -- reads file from disk, returns None on FileNotFoundError/PermissionError (graceful degradation when disk not mounted)
     - `get_file_count() -> int` -- calls `db.get_file_count()`
   - Note: `filter_files` takes `list[str]` in CLI "field:value" format (e.g., ["course:OPAR", "year:>=2020"]). Parse these into the dict format that `filter_files_by_metadata` expects. Look at `build_metadata_filter` in citations.py for the existing parsing pattern -- but here we call the Database method not the Gemini filter builder.

2. Create `src/objlib/services/session.py` with class `SessionService`:
   - Constructor takes `db_path: str`
   - All methods follow same pattern: inner sync function with Database context manager + asyncio.to_thread()
   - Methods (each is `async def`):
     - `create_session(name: str | None = None) -> str` -- returns session UUID
     - `add_event(session_id: str, event_type: str, payload: dict) -> str` -- returns event UUID. Add "bookmark" to VALID_EVENT_TYPES in session/manager.py (open question #3 from research)
     - `list_sessions() -> list[dict]` -- returns list of session dicts
     - `get_events(session_id: str) -> list[dict]` -- returns events for a session
     - `get_session(session_id: str) -> dict | None` -- get single session by UUID (or prefix)
   - IMPORTANT: Also update `src/objlib/session/manager.py` to add "bookmark" to the `VALID_EVENT_TYPES` frozenset. This enables TUI bookmarking without schema migration.

CRITICAL: Every Database usage pattern must be: `with Database(self._db_path) as db:` inside the sync function, never across an await.
  </action>
  <verify>
    `python -c "from objlib.services.library import LibraryService; import inspect; assert inspect.iscoroutinefunction(LibraryService.get_categories); print('async OK')"` confirms async.
    `python -c "from objlib.services.session import SessionService; import inspect; assert inspect.iscoroutinefunction(SessionService.create_session); print('async OK')"` confirms async.
    `python -c "from objlib.session.manager import VALID_EVENT_TYPES; assert 'bookmark' in VALID_EVENT_TYPES; print('bookmark OK')"` confirms bookmark event type added.
  </verify>
  <done>LibraryService and SessionService classes exist with async methods. All Database connections are short-lived within sync closures. "bookmark" added to VALID_EVENT_TYPES. The complete services facade (3 classes) is importable from `objlib.services`.</done>
</task>

</tasks>

<verification>
1. `python -c "from objlib.services import SearchService, LibraryService, SessionService; print('All services importable')"` -- passes
2. `python -c "import asyncio; from objlib.services import LibraryService; svc = LibraryService('data/library.db'); print(asyncio.run(svc.get_file_count()))"` -- returns file count from DB
3. `grep 'textual' pyproject.toml` -- shows textual in dependencies
4. `python -c "from objlib.session.manager import VALID_EVENT_TYPES; print(VALID_EVENT_TYPES)"` -- includes "bookmark"
5. Existing tests still pass: `pytest tests/ -x -q`
</verification>

<success_criteria>
- Three service classes (SearchService, LibraryService, SessionService) accessible via `from objlib.services import ...`
- Every async method wraps synchronous I/O with `asyncio.to_thread()`
- No Database connection held across await boundaries
- "bookmark" added to VALID_EVENT_TYPES
- `textual>=5.0` in pyproject.toml dependencies
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-interactive-tui/07-01-SUMMARY.md`
</output>
