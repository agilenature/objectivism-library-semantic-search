---
phase: 07-interactive-tui
plan: 05
type: execute
wave: 3
depends_on: ["07-01", "07-02", "07-03", "07-04"]
files_modified:
  - src/objlib/tui/widgets/filter_panel.py
  - src/objlib/tui/app.py
  - src/objlib/tui/widgets/__init__.py
  - src/objlib/cli.py
autonomous: true

must_haves:
  truths:
    - "FilterPanel provides interactive category/course/difficulty selection via Select widgets"
    - "App.compose() uses real widget classes (NavTree, SearchBar, ResultsList, PreviewPane, FilterPanel) instead of placeholders"
    - "Search flow works end-to-end: type query -> debounce -> SearchService -> results -> click result -> preview"
    - "Filter changes re-trigger search with updated filters"
    - "Navigation tree selection loads files into results list or preview"
    - "`objlib tui` CLI command launches the Textual app"
  artifacts:
    - path: "src/objlib/tui/widgets/filter_panel.py"
      provides: "FilterPanel widget with category, course, difficulty selectors"
      contains: "class FilterPanel"
    - path: "src/objlib/tui/app.py"
      provides: "Complete App with all widgets, message handlers, and wiring"
      contains: "compose"
    - path: "src/objlib/cli.py"
      provides: "tui command entry point"
      contains: "def tui"
  key_links:
    - from: "src/objlib/tui/app.py"
      to: "src/objlib/tui/widgets/nav_tree.py"
      via: "compose() yields NavTree"
      pattern: "NavTree"
    - from: "src/objlib/tui/app.py"
      to: "src/objlib/tui/widgets/results.py"
      via: "compose() yields ResultsList"
      pattern: "ResultsList"
    - from: "src/objlib/tui/app.py"
      to: "src/objlib/tui/widgets/preview.py"
      via: "compose() yields PreviewPane"
      pattern: "PreviewPane"
    - from: "src/objlib/tui/app.py"
      to: "src/objlib/services/search.py"
      via: "_run_search calls search_service.search()"
      pattern: "self\\.search_service\\.search"
    - from: "src/objlib/cli.py"
      to: "src/objlib/tui/__init__.py"
      via: "tui command calls run_tui()"
      pattern: "run_tui"
---

<objective>
Wire all widgets together in the App, create the filter panel, implement all message handlers for end-to-end search/browse/preview flow, and add the `objlib tui` CLI entry point.

Purpose: This plan transforms the placeholder skeleton (07-02) and independent widgets (07-03, 07-04) into a working integrated TUI. After this plan, `objlib tui` launches a functional app where the user can search, browse the nav tree, see results, preview documents, and filter by metadata. This is the integration plan that makes the TUI usable.

Output: Complete working TUI with all panes wired together and a CLI entry point.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-interactive-tui/07-CONTEXT.md
@.planning/phases/07-interactive-tui/07-RESEARCH.md
@.planning/phases/07-interactive-tui/07-01-SUMMARY.md
@.planning/phases/07-interactive-tui/07-02-SUMMARY.md
@.planning/phases/07-interactive-tui/07-03-SUMMARY.md
@.planning/phases/07-interactive-tui/07-04-SUMMARY.md

Key files being modified:
@src/objlib/tui/app.py (from 07-02, replacing placeholders)
@src/objlib/cli.py (adding tui command)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FilterPanel and update widgets __init__.py</name>
  <files>
    src/objlib/tui/widgets/filter_panel.py
    src/objlib/tui/widgets/__init__.py
  </files>
  <action>
1. Create `src/objlib/tui/widgets/filter_panel.py` with class `FilterPanel(Vertical)`:

   **DEFAULT_CSS**:
   ```
   FilterPanel {
       height: auto;
       max-height: 15;
       padding: 1;
       border-bottom: solid $primary;
       background: $surface;
   }
   ```

   **Constructor**: `__init__(self)` -- calls `super().__init__(id="filter-panel")`

   **compose()** method yields:
   - `Static("Filters", classes="filter-header")`
   - `Select` widget for category (id="filter-category"): options populated on mount from LibraryService
   - `Select` widget for difficulty (id="filter-difficulty"): static options ["introductory", "intermediate", "advanced"]
   - `Select` widget for course (id="filter-course"): options populated on mount from LibraryService
   - Use Textual's `Select` widget with `allow_blank=True` and `prompt="All"` for clear state

   **`async def on_mount(self)`**:
   - Populate category and course Select options from `self.app.library_service`:
     - `categories = await self.app.library_service.get_categories()`
     - `courses = await self.app.library_service.get_courses()`
     - Update Select options: `self.query_one("#filter-category", Select).set_options([(name, name) for name, _ in categories])`
     - Same for courses

   **`on_select_changed(self, event: Select.Changed)`**:
   - Build a `FilterSet` from current state of all three Select widgets
   - Post `FilterChanged(filters=filter_set)` message

   **`def reset_filters(self)`**:
   - Reset all Select widgets to blank/default
   - Post `FilterChanged(filters=FilterSet())` to clear filters

   Import `Vertical` from `textual.containers`, `Static, Select` from `textual.widgets`, `FilterSet` from `objlib.tui.state`, `FilterChanged` from `objlib.tui.messages`.

2. Update `src/objlib/tui/widgets/__init__.py`:
   - Re-export all widget classes: `from .nav_tree import NavTree`, `from .search_bar import SearchBar`, `from .results import ResultsList`, `from .preview import PreviewPane`, `from .filter_panel import FilterPanel`
  </action>
  <verify>
    `python -c "from objlib.tui.widgets import NavTree, SearchBar, ResultsList, PreviewPane, FilterPanel; print('All widgets importable')"` -- passes
  </verify>
  <done>FilterPanel provides category/course/difficulty selection via Select widgets. All TUI widgets re-exported from widgets package.</done>
</task>

<task type="auto">
  <name>Task 2: Wire all widgets in App, implement message handlers, add CLI entry point</name>
  <files>
    src/objlib/tui/app.py
    src/objlib/cli.py
  </files>
  <action>
1. **Update `src/objlib/tui/app.py`** -- replace placeholder widgets with real ones and wire message handlers:

   **compose()** -- replace placeholder Static widgets:
   ```python
   def compose(self) -> ComposeResult:
       yield Header(show_clock=True)
       yield SearchBar()  # replaces Input placeholder
       with Horizontal(id="main"):
           with Vertical(id="nav-pane"):
               yield FilterPanel()
               yield NavTree()
           yield ResultsList(id="results-pane")  # center pane
           yield PreviewPane()  # right pane, id="preview-pane" set in widget
       yield Static("Ready | Ctrl+P: Commands | Tab: Switch Pane", id="status-bar")
       yield Footer()
   ```

   **on_mount()** -- initialize:
   - Populate NavTree: `await self.query_one(NavTree).populate(self.library_service)`
   - Show placeholder in PreviewPane: `self.query_one(PreviewPane).show_placeholder()`

   **Message Handlers** (complete implementations):

   a. **SearchRequested handler** (`on_search_requested`):
      - `self.query = message.query`
      - If query is empty: clear results, show placeholder in preview, return
      - Build filter strings from `self.active_filters`
      - Call `self._run_search(message.query)` (the exclusive worker)

   b. **_run_search worker** (update from stub):
      - Set `self.is_searching = True`
      - Update status: `self.query_one(ResultsList).update_status("Searching...")`
      - `filters = self.active_filters.to_filter_strings() if not self.active_filters.is_empty() else None`
      - `result = await self.search_service.search(self.query, filters=filters)`
      - `self.results = result.citations`
      - `self.query_one(ResultsList).update_results(result.citations)`
      - If result.response_text: show it in preview as synthesis overview
      - Set `self.is_searching = False`
      - Update status bar with result count
      - Log search event to session if active: `await self.session_service.add_event(self.active_session_id, "search", {"query": self.query, "result_count": len(result.citations)})`
      - On exception: show error in status, `self.notify(f"Search error: {e}", severity="error")`

   c. **ResultSelected handler** (`on_result_selected`):
      - `self.selected_index = message.index`
      - Select the result in results list: `self.query_one(ResultsList).select_index(message.index)`
      - Load document for preview:
        - If `message.citation.file_path`: load content via `await self.library_service.get_file_content(message.citation.file_path)`
        - If content: `self.query_one(PreviewPane).show_document(content, message.citation.file_path, highlight_terms=[self.query])`
        - If no content (disk not mounted): `self.query_one(PreviewPane).show_unavailable()`
        - If no file_path: show citation detail view: `self.query_one(PreviewPane).show_citation_detail(message.citation)`
      - Log view event to session if active

   d. **FileSelected handler** (`on_file_selected`):
      - Load file content via LibraryService
      - Show in preview pane
      - If unavailable: show_unavailable()

   e. **NavigationRequested handler** (`on_navigation_requested`):
      - If category: filter results by category via LibraryService
      - If course: filter results by course via LibraryService
      - Update ResultsList with filtered file list

   f. **FilterChanged handler** (`on_filter_changed`):
      - `self.active_filters = message.filters`
      - If there's an active query: re-run search with new filters
      - If no query: filter browse results via LibraryService

   g. **watch_is_searching(self, value: bool)** -- reactive watcher:
      - Update status bar: "Searching..." or result count

   **action_focus_search**: focus the SearchBar widget
   **action_toggle_nav**: toggle nav-pane display class
   **action_clear_search**: clear SearchBar and results

2. **Update `src/objlib/cli.py`** -- add `tui` command:
   - Add to imports at top: nothing new needed (deferred import inside command)
   - Add command function after the existing commands:
     ```python
     @app.command()
     def tui() -> None:
         """Launch interactive TUI for library exploration."""
         from objlib.tui import run_tui
         run_tui()
     ```
   - This is a minimal entry point -- all logic lives in `run_tui()`. The deferred import keeps CLI startup fast.
   - NOTE: `tui` is NOT in `_GEMINI_COMMANDS` -- it handles its own initialization in `run_tui()`

Import all widget classes from `objlib.tui.widgets` in app.py. Import messages from `objlib.tui.messages`.
  </action>
  <verify>
    1. `python -c "from objlib.tui.app import ObjlibApp; print('App with real widgets importable')"` -- passes
    2. `python -m objlib tui --help` -- shows help text for the tui command (does NOT launch app)
    3. `python -m objlib --help` -- shows tui in command list
    4. `grep 'def tui' src/objlib/cli.py` -- found
    5. `grep 'NavTree' src/objlib/tui/app.py` -- found (real widgets in compose)
    6. Existing tests still pass: `pytest tests/ -x -q`
  </verify>
  <done>All widgets wired in App compose(). Message handlers implement full search -> results -> preview flow. Filter changes re-trigger search. Nav tree selection loads files. `objlib tui` CLI command exists. End-to-end TUI is functional.</done>
</task>

</tasks>

<verification>
1. `python -m objlib --help` -- shows `tui` command in the list
2. `python -c "from objlib.tui.app import ObjlibApp; print('wired app OK')"` -- imports succeed
3. `grep 'on_search_requested\|on_result_selected\|on_filter_changed\|on_file_selected\|on_navigation_requested' src/objlib/tui/app.py` -- all handlers present
4. `grep 'run_tui' src/objlib/cli.py` -- found in tui command
5. Existing tests still pass: `pytest tests/ -x -q`
</verification>

<success_criteria>
- `objlib tui` command exists and calls run_tui()
- App compose() uses real NavTree, SearchBar, ResultsList, PreviewPane, FilterPanel widgets
- Search flow: type query -> debounce -> exclusive worker -> SearchService -> results rendered -> click -> preview loaded
- Filter changes re-trigger search with active filters
- Nav tree file selection loads document in preview
- Graceful degradation when disk not mounted (show_unavailable)
- Session events logged for search and view actions
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-interactive-tui/07-05-SUMMARY.md`
</output>
