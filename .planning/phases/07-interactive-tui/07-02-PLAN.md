---
phase: 07-interactive-tui
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/objlib/tui/__init__.py
  - src/objlib/tui/app.py
  - src/objlib/tui/state.py
  - src/objlib/tui/messages.py
autonomous: true

must_haves:
  truths:
    - "ObjlibApp is a Textual App subclass with inline CSS defining three-pane layout"
    - "AppState uses Textual reactive properties for query, results, selected_index, filters"
    - "Custom Message subclasses exist for all inter-widget communication patterns"
    - "run_tui() function initializes services and launches the app"
    - "App uses compose() with Header, Input, Horizontal(nav/results/preview), Footer"
  artifacts:
    - path: "src/objlib/tui/__init__.py"
      provides: "run_tui() entry point function"
      contains: "def run_tui"
    - path: "src/objlib/tui/app.py"
      provides: "ObjlibApp class with CSS, compose(), bindings, reactive state"
      contains: "class ObjlibApp"
    - path: "src/objlib/tui/state.py"
      provides: "FilterSet and Bookmark dataclasses"
      contains: "class FilterSet"
    - path: "src/objlib/tui/messages.py"
      provides: "SearchRequested, ResultSelected, FileSelected, FilterChanged, BookmarkToggled messages"
      contains: "class SearchRequested"
  key_links:
    - from: "src/objlib/tui/app.py"
      to: "src/objlib/tui/state.py"
      via: "imports FilterSet, Bookmark"
      pattern: "from objlib\\.tui\\.state import"
    - from: "src/objlib/tui/app.py"
      to: "src/objlib/tui/messages.py"
      via: "handles custom messages"
      pattern: "from objlib\\.tui\\.messages import"
---

<objective>
Create the Textual application skeleton with App subclass, centralized state management using reactive properties, and custom message types for inter-widget communication.

Purpose: This is the structural foundation of the TUI. The App defines the three-pane layout via inline CSS, holds reactive state that pane widgets will read from, and defines the message protocol widgets use to communicate through the App. Pane widgets (Wave 2) depend on this skeleton.

Output: `ObjlibApp` class with compose(), CSS, bindings, and reactive state. `FilterSet`/`Bookmark` dataclasses. Custom `Message` subclasses for search, selection, filter, and bookmark events.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-interactive-tui/07-CONTEXT.md
@.planning/phases/07-interactive-tui/07-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state dataclasses and message types</name>
  <files>
    src/objlib/tui/__init__.py
    src/objlib/tui/state.py
    src/objlib/tui/messages.py
  </files>
  <action>
1. Create `src/objlib/tui/__init__.py`:
   - Define `run_tui()` function that:
     - Imports keyring, gets API key via `keyring.get_password("objlib-gemini", "api_key")`
     - If no API key, prints error and raises SystemExit
     - Resolves store name via `GeminiSearchClient.resolve_store_name()` (network call at startup -- acceptable per research open question #2)
     - Creates SearchService, LibraryService, SessionService instances
     - Creates ObjlibApp(search_service, library_service, session_service)
     - Calls `app.run()`
   - Use `db_path = "data/library.db"` and store_display_name `"objectivism-library-test"` as defaults
   - Use deferred imports: `from google import genai` and service imports inside the function body for fast module load

2. Create `src/objlib/tui/state.py`:
   - `@dataclass` class `FilterSet`:
     - `category: str | None = None`
     - `course: str | None = None`
     - `difficulty: str | None = None`
     - `year_min: int | None = None`
     - `year_max: int | None = None`
     - `def to_filter_strings(self) -> list[str]`: converts non-None fields to CLI "field:value" format list for passing to LibraryService/SearchService
     - `def is_empty(self) -> bool`: returns True if all fields are None
   - `@dataclass` class `Bookmark`:
     - `file_path: str`
     - `filename: str`
     - `note: str = ""`

3. Create `src/objlib/tui/messages.py`:
   - All messages inherit from `textual.message.Message`
   - `class SearchRequested(Message)`: `query: str` -- fired by search input after debounce
   - `class ResultSelected(Message)`: `index: int`, `citation: Citation | None` -- fired when user selects a result
   - `class FileSelected(Message)`: `file_path: str`, `filename: str` -- fired from nav tree
   - `class FilterChanged(Message)`: `filters: FilterSet` -- fired from filter panel
   - `class BookmarkToggled(Message)`: `file_path: str`, `filename: str` -- toggle bookmark on current document
   - `class NavigationRequested(Message)`: `category: str | None = None`, `course: str | None = None` -- fired from tree node selection
   - Each message has `__init__` that calls `super().__init__()` and stores attributes
  </action>
  <verify>
    `python -c "from objlib.tui.state import FilterSet, Bookmark; f = FilterSet(category='course'); print(f.to_filter_strings())"` -- prints ["category:course"]
    `python -c "from objlib.tui.messages import SearchRequested, ResultSelected, FileSelected, FilterChanged, BookmarkToggled, NavigationRequested; print('All messages importable')"` -- passes
  </verify>
  <done>State dataclasses and all message types exist and are importable. FilterSet can serialize to filter strings.</done>
</task>

<task type="auto">
  <name>Task 2: Create ObjlibApp with three-pane layout, CSS, bindings, and reactive state</name>
  <files>
    src/objlib/tui/app.py
    src/objlib/tui/widgets/__init__.py
  </files>
  <action>
1. Create `src/objlib/tui/widgets/__init__.py` as empty file (placeholder for Wave 2 widget modules).

2. Create `src/objlib/tui/app.py` with class `ObjlibApp(App)`:

   **Inline CSS** (class variable `CSS`):
   - `#search-bar`: dock top, height 3, padding 0 1
   - `#main`: layout horizontal, height 1fr
   - `#nav-pane`: width 1fr, min-width 25, max-width 40, border-right solid $primary
   - `#results-pane`: width 2fr, min-width 30, border-right solid $accent
   - `#preview-pane`: width 3fr, min-width 40
   - `#status-bar`: dock bottom, height 1, background $primary-background
   - Layout class overrides for responsive breakpoints (details in 07-06 plan):
     - `.layout-medium #nav-pane { display: none; }` with adjusted widths
     - `.layout-narrow #main { layout: vertical; }` with all panes 100% width

   **BINDINGS** list:
   - `("ctrl+p", "command_palette", "Commands")`
   - `("ctrl+f", "focus_search", "Search")`
   - `("tab", "focus_next", "Next Pane")`
   - `("shift+tab", "focus_previous", "Previous Pane")`
   - `("ctrl+b", "toggle_nav", "Toggle Nav")`
   - `("ctrl+s", "save_session", "Save Session")`
   - `("escape", "clear_search", "Clear")`

   **Reactive state** (on the App class):
   - `query = reactive("")`
   - `results = reactive(list)` -- list of Citation objects
   - `selected_index = reactive(None)` -- int | None
   - `search_history = reactive(list)` -- list of str
   - `active_filters = reactive(FilterSet)` -- from state.py
   - `bookmarks = reactive(list)` -- list of Bookmark
   - `is_searching = reactive(False)` -- for spinner display
   - `active_session_id = reactive(None)` -- str | None

   **Constructor** `__init__(self, search_service, library_service, session_service)`:
   - Store services as instance attributes
   - Call `super().__init__()`
   - Initialize `_search_timer = None`

   **compose()** method:
   - For now, use placeholder `Static` widgets for the three panes (Wave 2 will replace with real widgets):
     ```python
     yield Header(show_clock=True)
     yield Input(placeholder="Search the library... (Ctrl+F)", id="search-bar")
     with Horizontal(id="main"):
         yield Static("Navigation", id="nav-pane")
         yield Static("Results", id="results-pane")
         yield Static("Preview", id="preview-pane")
     yield Static("Ready | Ctrl+P: Commands | Tab: Switch Pane", id="status-bar")
     yield Footer()
     ```

   **Message handlers** (stubs for now, full implementation in Wave 3):
   - `on_input_changed(self, event: Input.Changed)` -- if search-bar, cancel previous timer, set 300ms debounce timer
   - `action_focus_search(self)` -- focus the search-bar input
   - `action_toggle_nav(self)` -- toggle nav-pane visibility
   - `action_clear_search(self)` -- clear search input and results

   **Search worker** (stub):
   - `@work(exclusive=True) async def _run_search(self, query: str)` -- set `is_searching = True`, call `await self.search_service.search(query)`, set `self.results = result.citations`, set `is_searching = False`. Wrap in try/except to handle errors gracefully.

Import from textual: `App, ComposeResult`, `reactive`, `work`, `events`, `Horizontal, Vertical`, `Header, Footer, Input, Static`
Import from objlib.tui: `state`, `messages`

NOTE: Do NOT import SearchService/LibraryService/SessionService at module level in app.py -- they are passed as constructor arguments. This avoids import-time Gemini SDK loading.
  </action>
  <verify>
    `python -c "from objlib.tui.app import ObjlibApp; print('App importable')"` -- passes
    `python -c "from objlib.tui import run_tui; print('run_tui importable')"` -- passes (but don't call it -- requires API key)
    Verify the app can be instantiated with mock services: `python -c "from objlib.tui.app import ObjlibApp; app = ObjlibApp(None, None, None); print('App created')"` -- passes (services are stored, not used at init)
  </verify>
  <done>ObjlibApp class exists with three-pane CSS layout, keyboard bindings, reactive state properties, debounce timer, exclusive search worker, and compose() with placeholder widgets. run_tui() entry point is ready. Widget package directory created for Wave 2.</done>
</task>

</tasks>

<verification>
1. `python -c "from objlib.tui.app import ObjlibApp; from objlib.tui.state import FilterSet; from objlib.tui.messages import SearchRequested; print('All TUI modules importable')"` -- passes
2. `python -c "from objlib.tui.app import ObjlibApp; app = ObjlibApp(None, None, None); print(type(app))"` -- shows ObjlibApp type
3. Verify CSS is inline: `grep -c 'CSS =' src/objlib/tui/app.py` -- returns 1 (no CSS_PATH)
4. Verify reactive state: `grep -c 'reactive' src/objlib/tui/app.py` -- returns 8+ (one per reactive property)
5. Existing tests still pass: `pytest tests/ -x -q`
</verification>

<success_criteria>
- ObjlibApp is a Textual App subclass with inline CSS for three-pane layout
- Reactive state covers query, results, selected_index, filters, bookmarks, session
- Custom messages exist for all inter-widget communication patterns
- run_tui() initializes services and launches the app
- compose() produces a working layout (even with placeholder widgets)
- Debounce timer and exclusive search worker are wired up
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-interactive-tui/07-02-SUMMARY.md`
</output>
