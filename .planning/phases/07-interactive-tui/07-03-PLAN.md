---
phase: 07-interactive-tui
plan: 03
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - src/objlib/tui/widgets/nav_tree.py
  - src/objlib/tui/widgets/search_bar.py
autonomous: true

must_haves:
  truths:
    - "NavTree displays categories -> courses -> files hierarchy with file count badges"
    - "NavTree populates asynchronously from LibraryService on mount"
    - "SearchBar fires SearchRequested message after 300ms debounce"
    - "SearchBar supports search history navigation with up/down arrows"
    - "Tree nodes carry data attributes for type and name used in navigation"
  artifacts:
    - path: "src/objlib/tui/widgets/nav_tree.py"
      provides: "NavTree widget extending textual.widgets.Tree"
      contains: "class NavTree"
    - path: "src/objlib/tui/widgets/search_bar.py"
      provides: "SearchBar widget with debounce and history"
      contains: "class SearchBar"
  key_links:
    - from: "src/objlib/tui/widgets/nav_tree.py"
      to: "src/objlib/tui/messages.py"
      via: "posts NavigationRequested and FileSelected messages"
      pattern: "NavigationRequested|FileSelected"
    - from: "src/objlib/tui/widgets/search_bar.py"
      to: "src/objlib/tui/messages.py"
      via: "posts SearchRequested message"
      pattern: "SearchRequested"
---

<objective>
Build the navigation tree and search bar widgets -- the left pane and top search input of the TUI.

Purpose: NavTree provides visual library exploration (TUI-02: categories -> courses -> files with badges). SearchBar provides the live search experience (TUI-01: type-as-you-search with debounce). Together they are the two primary input mechanisms for the TUI.

Output: `NavTree` widget that populates from LibraryService and posts navigation messages. `SearchBar` widget with 300ms debounce, search history, and message posting.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-interactive-tui/07-CONTEXT.md
@.planning/phases/07-interactive-tui/07-RESEARCH.md
@.planning/phases/07-interactive-tui/07-01-SUMMARY.md
@.planning/phases/07-interactive-tui/07-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NavTree widget with category/course/file hierarchy</name>
  <files>src/objlib/tui/widgets/nav_tree.py</files>
  <action>
Create `src/objlib/tui/widgets/nav_tree.py` with class `NavTree(Tree)`:

1. **DEFAULT_CSS** class variable:
   - `NavTree { width: 100%; height: 1fr; background: $surface; scrollbar-gutter: stable; }`

2. **Constructor**: `__init__(self)` -- calls `super().__init__("Library", id="nav-tree")`

3. **`async def populate(self, library_service)`**:
   - Clear the tree: `self.clear()`
   - Fetch categories: `categories = await library_service.get_categories()`
   - For each (category_name, count):
     - Add top-level node: `cat_node = self.root.add(f"{cat_name} ({count})", data={"type": "category", "name": cat_name})`
     - If category is "course", also fetch courses: `courses = await library_service.get_courses()`
     - For each course, add child node: `cat_node.add(f"{course_name} ({course_count})", data={"type": "course", "name": course_name})`
   - Expand the root node by default
   - Add a "Bookmarks" top-level node with data `{"type": "bookmarks"}`

4. **`async def expand_course(self, course_name: str, library_service)`**:
   - Called lazily when a course node is expanded
   - Fetch files: `files = await library_service.get_files_by_course(course_name)`
   - For each file dict, add leaf node: `node.add_leaf(filename, data={"type": "file", "file_path": file_path, "filename": filename})`

5. **`on_tree_node_selected(self, event: Tree.NodeSelected)`**:
   - Read `event.node.data`
   - If type is "file": post `FileSelected(file_path=..., filename=...)` message
   - If type is "category": post `NavigationRequested(category=...)` message
   - If type is "course": post `NavigationRequested(course=...)` message

6. **`on_tree_node_expanded(self, event: Tree.NodeExpanded)`**:
   - If node data type is "course" and node has no children (not yet populated):
     - Use `self.app.library_service` to call `expand_course()`
     - This enables lazy loading -- course files are only fetched when the user expands that course node

Import `Tree` from `textual.widgets`, import `FileSelected`, `NavigationRequested` from `objlib.tui.messages`.

NOTE: The NavTree does NOT hold a reference to LibraryService. It accesses it via `self.app.library_service` (the App stores services). The `populate()` method is called during `App.on_mount()`.
  </action>
  <verify>
    `python -c "from objlib.tui.widgets.nav_tree import NavTree; print('NavTree importable')"` -- passes
    `python -c "from objlib.tui.widgets.nav_tree import NavTree; tree = NavTree(); print(tree.id)"` -- prints "nav-tree"
  </verify>
  <done>NavTree widget exists with category/course/file hierarchy, lazy expansion, file count badges, and proper message posting for navigation and file selection events.</done>
</task>

<task type="auto">
  <name>Task 2: Create SearchBar widget with debounce, history, and clear</name>
  <files>src/objlib/tui/widgets/search_bar.py</files>
  <action>
Create `src/objlib/tui/widgets/search_bar.py` with class `SearchBar(Input)`:

1. **DEFAULT_CSS** class variable:
   - `SearchBar { dock: top; height: 3; padding: 0 1; border-bottom: solid $primary; }`

2. **Constructor**: `__init__(self)` -- calls `super().__init__(placeholder="Search the library... (Ctrl+F to focus)", id="search-bar")`
   - `self._debounce_timer: Timer | None = None`
   - `self._history: list[str] = []` -- past search queries
   - `self._history_index: int = -1` -- current position in history (-1 = not browsing)
   - `self.DEBOUNCE_SECONDS = 0.3`

3. **`on_input_changed(self, event: Input.Changed)`**:
   - Only process if `event.input is self` (avoid bubbled events from other inputs)
   - Cancel previous debounce timer if exists: `if self._debounce_timer: self._debounce_timer.stop()`
   - If `event.value.strip()` is empty: post `SearchRequested(query="")` immediately (clear results), return
   - Set new timer: `self._debounce_timer = self.set_timer(self.DEBOUNCE_SECONDS, lambda: self._fire_search(event.value))`

4. **`def _fire_search(self, query: str)`**:
   - Post `SearchRequested(query=query)` message
   - Add to history if different from last entry: `if not self._history or self._history[-1] != query: self._history.append(query)`
   - Reset history index: `self._history_index = -1`

5. **`on_key(self, event: events.Key)`**:
   - Handle Up arrow: navigate backward in history
     - If `self._history` and key is "up":
       - `self._history_index = min(self._history_index + 1, len(self._history) - 1)`
       - `self.value = self._history[-(self._history_index + 1)]`
       - `event.prevent_default()`
   - Handle Down arrow: navigate forward in history
     - If key is "down" and `self._history_index > 0`:
       - `self._history_index -= 1`
       - `self.value = self._history[-(self._history_index + 1)]`
       - `event.prevent_default()`
     - If `self._history_index == 0`:
       - `self._history_index = -1`
       - `self.value = ""`
       - `event.prevent_default()`
   - Handle Enter: fire search immediately (skip debounce)
     - Cancel debounce timer
     - If `self.value.strip()`: `self._fire_search(self.value)`

6. **`def clear_and_reset(self)`**:
   - `self.value = ""`
   - `self._history_index = -1`
   - Post `SearchRequested(query="")` to clear results

Import `Input` from `textual.widgets`, `Timer` from `textual.timer`, `events` from `textual`, `SearchRequested` from `objlib.tui.messages`.
  </action>
  <verify>
    `python -c "from objlib.tui.widgets.search_bar import SearchBar; print('SearchBar importable')"` -- passes
    `python -c "from objlib.tui.widgets.search_bar import SearchBar; sb = SearchBar(); print(sb.id)"` -- prints "search-bar"
  </verify>
  <done>SearchBar widget exists with 300ms debounce, search history navigation (up/down arrows), Enter for immediate search, and clear functionality. Posts SearchRequested messages for the App to handle.</done>
</task>

</tasks>

<verification>
1. `python -c "from objlib.tui.widgets.nav_tree import NavTree; from objlib.tui.widgets.search_bar import SearchBar; print('Both widgets importable')"` -- passes
2. NavTree has DEFAULT_CSS: `grep 'DEFAULT_CSS' src/objlib/tui/widgets/nav_tree.py` -- found
3. SearchBar has DEBOUNCE_SECONDS: `grep 'DEBOUNCE_SECONDS' src/objlib/tui/widgets/search_bar.py` -- found
4. Both import from messages.py: `grep 'from objlib.tui.messages' src/objlib/tui/widgets/*.py` -- both files
5. Existing tests still pass: `pytest tests/ -x -q`
</verification>

<success_criteria>
- NavTree displays category/course/file tree with count badges
- NavTree lazy-loads course files on expand
- NavTree posts FileSelected and NavigationRequested messages
- SearchBar debounces at 300ms before firing SearchRequested
- SearchBar supports up/down arrow history navigation
- SearchBar Enter key fires immediately (skips debounce)
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-interactive-tui/07-03-SUMMARY.md`
</output>
