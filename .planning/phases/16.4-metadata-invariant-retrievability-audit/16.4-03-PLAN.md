---
phase: 16.4-metadata-invariant-retrievability-audit
plan: 03
type: execute
wave: 3
depends_on: ["16.4-02"]
files_modified:
  - scripts/retrievability_audit.py
  - .planning/phases/16.4-metadata-invariant-retrievability-audit/16.4-03-hit-rates.md
autonomous: true

must_haves:
  truths:
    - "All 1,749 indexed files tested with 3 query strategies (5,247 total queries)"
    - "Per-series hit rate tables produced for each strategy with top-5 threshold"
    - "Minimum viable query strategy identified (highest global hit rate)"
    - "Residual failures documented with affirmative evidence of why they fail"
    - "Audit is resumable via JSON progress file keyed by {file_path}_{strategy_num}"
    - "Episodes included in audit (NOT pre-excluded) per locked decision #2"
  artifacts:
    - path: "scripts/retrievability_audit.py"
      provides: "Comprehensive retrievability audit script with 3 strategies"
      contains: "strategy"
    - path: ".planning/phases/16.4-metadata-invariant-retrievability-audit/16.4-03-results.json"
      provides: "Raw audit results (resumable progress file)"
    - path: ".planning/phases/16.4-metadata-invariant-retrievability-audit/16.4-03-hit-rates.md"
      provides: "Per-series hit rate tables and minimum viable strategy analysis"
  key_links:
    - from: "scripts/retrievability_audit.py"
      to: "data/library.db"
      via: "sqlite3 queries for file metadata + topic_aspects + primary_topics"
      pattern: "file_primary_topics|file_metadata_ai"
    - from: "scripts/retrievability_audit.py"
      to: "Gemini API"
      via: "generate_content with FileSearch tool"
      pattern: "generate_content"
---

<objective>
Build and run a comprehensive retrievability audit that tests all 1,749 indexed files against 3 query strategies, producing per-series hit rate tables and identifying the minimum viable query strategy for A7.

Purpose: Provide empirical evidence for which query strategy achieves zero-tolerance retrievability, or document with affirmative evidence which file categories cannot achieve it and why. This data drives Plan 16.4-04's A7 update.

Output: `scripts/retrievability_audit.py`, raw results JSON, per-series hit rate analysis committed to repo.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16.4-metadata-invariant-retrievability-audit/16.4-CONTEXT.md
@.planning/phases/16.4-metadata-invariant-retrievability-audit/16.4-RESEARCH.md
@.planning/phases/16.4-metadata-invariant-retrievability-audit/16.4-01-SUMMARY.md
@.planning/phases/16.4-metadata-invariant-retrievability-audit/16.4-02-SUMMARY.md
@scripts/check_stability.py
@src/objlib/upload/header_builder.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build retrievability audit script</name>
  <files>scripts/retrievability_audit.py</files>
  <action>
  Create `scripts/retrievability_audit.py` -- a standalone async script that tests every indexed file's retrievability across 3 query strategies.

  The script is architecturally identical to check_stability.py's A7 (lines 444-634) but runs exhaustively on all files with 3 strategies and resumability.

  **CLI interface:**
  ```
  python scripts/retrievability_audit.py \
    --store objectivism-library \
    --db data/library.db \
    --strategy {1,2,3,all} \
    --progress .planning/phases/16.4-metadata-invariant-retrievability-audit/16.4-03-results.json \
    --concurrency 10 \
    [--verbose]
  ```

  **Core design:**

  1. Load all indexed files from DB:
  ```sql
  SELECT file_path, filename, gemini_store_doc_id, gemini_file_id, metadata_json
  FROM files
  WHERE gemini_state = 'indexed'
    AND gemini_store_doc_id IS NOT NULL
  ORDER BY file_path
  ```
  No exclusions -- all 1,749 files included (per locked decision #2: Episodes included).

  2. For each file, build queries using 3 strategies (per locked decision #4):

  **Strategy 1 (Stem-only):**
  ```python
  stem = Path(filename).stem
  query = f"{stem} about"
  ```
  Note: Per locked decision, format is "{stem} about" (not "What is '{stem}' about?").

  **Strategy 2 (Stem + aspects):**
  ```python
  stem = Path(filename).stem
  # Get top-3 topic_aspects from file_metadata_ai
  ai_row = conn.execute(
      "SELECT metadata_json FROM file_metadata_ai WHERE file_path = ? AND is_current = 1",
      (file_path,),
  ).fetchone()
  aspects = []
  if ai_row and ai_row[0]:
      meta = json.loads(ai_row[0])
      aspects = (meta.get("topic_aspects") or [])[:3]
  aspect_str = " ".join(aspects)
  query = f"{stem} {aspect_str}"
  ```

  **Strategy 3 (Topics + course):**
  ```python
  course = Path(file_path).parent.name
  topics = conn.execute(
      "SELECT topic_tag FROM file_primary_topics WHERE file_path = ? LIMIT 3",
      (file_path,),
  ).fetchall()
  topic_str = " ".join(r[0] for r in topics)
  query = f"{course} {topic_str}"
  ```

  3. Query Gemini File Search (same pattern as check_stability.py lines 554-608):
  ```python
  response = client.models.generate_content(
      model="gemini-2.5-flash",
      contents=query,
      config=genai_types.GenerateContentConfig(
          tools=[genai_types.Tool(
              file_search=genai_types.FileSearch(
                  file_search_store_names=[store_resource_name]
              )
          )]
      ),
  )
  ```

  4. Match using top-5 threshold (per locked decision #4):
  Check `response.candidates[0].grounding_metadata.grounding_chunks[:5]` for the target file.
  Match via:
  - Primary: `store_doc_prefix = store_doc_id.split("-")[0]`; match `retrieved_context.title == store_doc_prefix`
  - Secondary: `expected_file_id = (gemini_file_id or "").replace("files/", "")`; match `title == expected_file_id`
  - Tertiary: `filename in title_in_result` (fallback)

  Record rank (1-5) if found, or None if not found.

  5. Rate limiting and resumability:
  - Use `asyncio.Semaphore(concurrency)` (default 10) for concurrent requests
  - On 429 or 5xx: exponential backoff (1s, 2s, 4s, 8s, 16s) with up to 5 retries
  - Save results after every file to the JSON progress file
  - On startup, load existing progress file and skip completed entries
  - Progress key format: `{file_path}_{strategy_num}` (per locked decision #6)

  6. Progress file format (per RESEARCH.md):
  ```json
  {
    "metadata": {
      "store": "objectivism-library",
      "started_at": "2026-02-26T10:00:00Z",
      "total_files": 1749
    },
    "results": {
      "/path/to/file.txt_1": {
        "filename": "file.txt",
        "file_path": "/path/to/file.txt",
        "strategy": 1,
        "found": true,
        "rank": 3,
        "query": "Objectivist Logic Class 09-02 about",
        "top_5_ids": ["abc123", "def456", ...],
        "timestamp": "2026-02-26T10:01:23Z"
      }
    }
  }
  ```

  7. Output at completion: print per-series hit rate summary table (using Rich).
  Series detection (same CASE logic as Plan 16.4-02 audit):
  ```python
  def detect_series(file_path: str) -> str:
      if "/ITOE Addenda/" in file_path and "Office Hour" in file_path:
          return "ITOE AT OH"
      elif "/ITOE Addenda/" in file_path:
          return "ITOE AT"
      elif "/ITOE/" in file_path and "Office Hour" in file_path:
          return "ITOE OH"
      elif "/ITOE/" in file_path:
          return "ITOE"
      elif "/Objectivist Logic/" in file_path:
          return "OL"
      elif "/MOTM/" in file_path:
          return "MOTM"
      elif "Episode" in Path(file_path).name:
          return "Episodes"
      elif "/Books/" in file_path:
          return "Books"
      else:
          return "Other"
  ```

  **Imports needed:**
  - google.genai, google.genai.types
  - sqlite3, json, asyncio, argparse, logging, time
  - pathlib.Path, datetime
  - rich.console, rich.table (for output tables)
  - keyring (for API key)

  **Structure the script as:**
  - `class RetrievabilityAuditor` with methods: `load_files()`, `build_query()`, `check_file()`, `run_strategy()`, `run()`, `print_summary()`
  - `async def main()` with argparse
  - Use `asyncio.run(main())` entry point

  IMPORTANT design considerations:
  - The script must NOT modify any data. It is read-only (queries only).
  - API key from keyring: `keyring.get_password("objlib-gemini", "api-key")`
  - Store resource name resolution: follow check_stability.py pattern (list stores, find by display_name match)
  </action>
  <verify>
  - `python scripts/retrievability_audit.py --help` shows usage with --store, --db, --strategy, --progress, --concurrency flags
  - `python scripts/retrievability_audit.py --store objectivism-library --db data/library.db --strategy 1 --progress /tmp/test-audit.json --concurrency 1 --verbose 2>&1 | head -20` runs without import errors and starts querying files (interrupt after confirming first few work)
  - The progress file `/tmp/test-audit.json` is created with valid JSON after the brief test run
  </verify>
  <done>scripts/retrievability_audit.py exists, runs without errors, queries Gemini API with correct pattern, saves resumable progress, matches files via store_doc_id prefix.</done>
</task>

<task type="auto">
  <name>Task 2: Run all 3 strategies and produce hit rate analysis</name>
  <files>.planning/phases/16.4-metadata-invariant-retrievability-audit/16.4-03-hit-rates.md, .planning/phases/16.4-metadata-invariant-retrievability-audit/16.4-03-results.json</files>
  <action>
  Run the retrievability audit for all 3 strategies. Use --strategy flag to run one at a time for reliability. These are long-running operations (~30-90 min each depending on rate limits).

  ```bash
  # Strategy 1 (Stem-only)
  python scripts/retrievability_audit.py \
    --store objectivism-library --db data/library.db \
    --strategy 1 \
    --progress .planning/phases/16.4-metadata-invariant-retrievability-audit/16.4-03-results.json \
    --concurrency 10

  # Strategy 2 (Stem + aspects)
  python scripts/retrievability_audit.py \
    --store objectivism-library --db data/library.db \
    --strategy 2 \
    --progress .planning/phases/16.4-metadata-invariant-retrievability-audit/16.4-03-results.json \
    --concurrency 10

  # Strategy 3 (Topics + course)
  python scripts/retrievability_audit.py \
    --store objectivism-library --db data/library.db \
    --strategy 3 \
    --progress .planning/phases/16.4-metadata-invariant-retrievability-audit/16.4-03-results.json \
    --concurrency 10
  ```

  If a strategy run is interrupted (rate limits, timeout, etc.), re-run the same command -- the progress file provides resumability, skipping already-completed entries.

  After all 3 strategies complete, produce the hit rate analysis document:

  Create `.planning/phases/16.4-metadata-invariant-retrievability-audit/16.4-03-hit-rates.md` with:

  1. **Summary table** (global hit rates):
  ```
  | Strategy | Total Files | Hits | Misses | Hit Rate |
  |----------|-------------|------|--------|----------|
  | 1 (Stem-only) | 1749 | ? | ? | ?% |
  | 2 (Stem+aspects) | 1749 | ? | ? | ?% |
  | 3 (Topics+course) | 1749 | ? | ? | ?% |
  ```

  2. **Per-series breakdown** for each strategy:
  ```
  | Series | Total | S1 Hits | S1% | S2 Hits | S2% | S3 Hits | S3% |
  |--------|-------|---------|-----|---------|-----|---------|-----|
  | ITOE | ? | ? | ?% | ? | ?% | ? | ?% |
  | ITOE AT | ? | ? | ?% | ? | ?% | ? | ?% |
  | ITOE OH | ? | ? | ?% | ? | ?% | ? | ?% |
  | OL | ? | ? | ?% | ? | ?% | ? | ?% |
  | Episodes | ? | ? | ?% | ? | ?% | ? | ?% |
  | MOTM | ? | ? | ?% | ? | ?% | ? | ?% |
  | Books | ? | ? | ?% | ? | ?% | ? | ?% |
  | Other | ? | ? | ?% | ? | ?% | ? | ?% |
  ```

  3. **Minimum viable strategy recommendation:**
  - Which strategy has the highest global hit rate?
  - If no single strategy achieves 100%, which achieves the highest?
  - If a file fails ALL 3 strategies, list it explicitly with the queries used and top-5 results returned. This is the "affirmative evidence of what would be needed to fix them" required by ROADMAP SC4.

  4. **Residual failure analysis** (for files failing all 3 strategies):
  - File path and filename
  - Series
  - All 3 queries used
  - For each query: top-5 file IDs returned (or "no grounding chunks")
  - Hypothesis: why this file is not retrievable (semantic homogeneity? identical content to another file? missing discriminating metadata?)

  5. **A7 recommendation:**
  Based on the data: which strategy should A7 use? If the best single strategy achieves 100%, recommend that one. If no single strategy achieves 100% but combining strategies (e.g., "try strategy 1, if miss try strategy 2") would, document this as an option for Plan 16.4-04.

  Per locked decision #2: Do NOT pre-exclude Episodes. If Episodes cannot achieve zero misses with any strategy, document the affirmative evidence (specific files, queries, returned results) rather than excluding them.
  </action>
  <verify>
  1. Progress file contains 5,247 entries (1749 files x 3 strategies)
  2. Hit rate analysis document exists with all 5 sections
  3. Every series appears in the per-series breakdown
  4. The minimum viable strategy recommendation is explicit and data-driven
  5. Any residual failures list specific files with affirmative evidence
  </verify>
  <done>
  - All 1,749 files tested with 3 strategies (5,247 queries)
  - Per-series hit rate tables produced
  - Minimum viable query strategy identified with global and per-series hit rates
  - Residual failures (if any) documented with affirmative evidence
  - A7 recommendation made based on empirical data
  - Results JSON and hit-rates.md committed to repo
  </done>
</task>

</tasks>

<verification>
Phase 16.4-03 retrievability audit is complete when:
1. scripts/retrievability_audit.py exists and runs
2. Progress file contains all 5,247 results (1749 x 3)
3. Hit rate analysis committed with per-series breakdown for all 3 strategies
4. Minimum viable strategy identified or residual failures documented with evidence
5. No pre-exclusions applied -- Episodes and all series included
6. A7 recommendation made
</verification>

<success_criteria>
- Comprehensive audit of all 1,749 indexed files across 3 query strategies
- Per-series hit rate tables produced for each strategy
- Minimum viable query strategy identified with empirical evidence
- Residual failures (if any) documented with specific files, queries, and affirmative evidence
- Data sufficient for Plan 16.4-04 to update A7 with confidence
</success_criteria>

<output>
After completion, create `.planning/phases/16.4-metadata-invariant-retrievability-audit/16.4-03-SUMMARY.md`
</output>
