---
phase: 16.3-retrievability-research
plan: 02
type: execute
wave: 2
depends_on:
  - 16.3-01
files_modified:
  - src/objlib/upload/header_builder.py
  - .planning/phases/16.3-retrievability-research/16.3-INTERVENTION.md
autonomous: true

must_haves:
  truths:
    - "The metadata header function exists and produces a structured header under 200 tokens for both Category A (class-number) and Category B (MOTM) files"
    - "An ephemeral test store objectivism-library-retrieval-test exists (or existed and was deleted after tests)"
    - "Category A files WITH headers retrieve in top-10 for their class-number query (>80% hit rate across the A condition)"
    - "Category A/B files WITHOUT headers fail to retrieve in top-10 for their class-number query (control confirms baseline failure)"
    - "Working files WITH headers maintain their hit rate (>95% regression check)"
    - "Test store deleted after validation; production store untouched"
    - "16.3-INTERVENTION.md documents evidence that H1 fix works on failing files before production rollout"
  artifacts:
    - path: "src/objlib/upload/header_builder.py"
      provides: "_build_metadata_header(file_path, conn) function"
      contains: "DOCUMENT METADATA"
      exports: ["build_metadata_header"]
    - path: ".planning/phases/16.3-retrievability-research/16.3-INTERVENTION.md"
      provides: "Intervention evidence with quantitative hit rates by condition"
      contains: "Category A WITH header"
  key_links:
    - from: "header_builder.py"
      to: "data/library.db file_primary_topics table"
      via: "SELECT topic FROM file_primary_topics WHERE file_path = ?"
      pattern: "primary_topics joined as space-separated Tags line"
    - from: "ephemeral test store"
      to: "targeted A7 queries"
      via: "run queries against objectivism-library-retrieval-test store only"
      pattern: "NOT touching production store objectivism-library"
---

<objective>
Apply the confirmed H1 fix (metadata header injection) to 6 known-failing files in an isolated ephemeral test store. Verify that previously-failing Category A and B files now appear in top-10 for their targeted queries. Document evidence before any production rollout.

Purpose: Before re-uploading ~454 production files, prove empirically that injecting a metadata header changes retrieval outcomes for files that were previously unretrievable. This is the only way to avoid a costly production rollout that fails to improve A7.

Output: `src/objlib/upload/header_builder.py` (reusable for Plan 16.3-03) and `16.3-INTERVENTION.md` documenting hit rates by condition.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16.3-retrievability-research/16.3-CONTEXT.md
@.planning/phases/16.3-retrievability-research/CLARIFICATIONS-ANSWERED.md
@.planning/phases/16.3-retrievability-research/16.3-01-SUMMARY.md
@src/objlib/upload/client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build metadata header function</name>
  <files>src/objlib/upload/header_builder.py</files>
  <action>
    Create `src/objlib/upload/header_builder.py` with the `build_metadata_header()` function. This function reads from SQLite and constructs the structured metadata header per the CLARIFICATIONS-ANSWERED.md decisions (Q3: structured format, Q6: Category A+B only).

    ```python
    """Metadata header builder for Gemini File Search content injection.

    Per Phase 16.3 CLARIFICATIONS-ANSWERED.md (Q3): structured header format
    optimized for Gemini's embedding model. Applied to Category A (Other-stem
    course files) and Category B (MOTM files with generic topics) only.

    Header format (<200 tokens):
        --- DOCUMENT METADATA ---
        Title: {filename_stem}
        Course: {parent_directory_name}
        Class: {class_identifier_if_present}
        Topic: {scanner_topic_from_metadata_json}
        Tags: {primary_topics_space_separated}
        --- TRANSCRIPT ---
    """
    from __future__ import annotations

    import json
    import re
    import sqlite3
    from pathlib import Path


    def build_metadata_header(file_path: str, conn: sqlite3.Connection) -> str:
        """Build a structured metadata header for a file to prepend before upload.

        Reads primary_topics from file_primary_topics table and scanner topic
        from metadata_json. Constructs a <200-token structured header.

        Args:
            file_path: Absolute path to the file (primary key in files table).
            conn: Open sqlite3.Connection to data/library.db.

        Returns:
            Header string ending with "--- TRANSCRIPT ---\\n".
            Returns empty string if file not found in DB.
        """
        row = conn.execute(
            "SELECT filename, metadata_json FROM files WHERE file_path = ?",
            (file_path,),
        ).fetchone()
        if not row:
            return ""

        filename, metadata_json_str = row
        stem = Path(filename).stem

        # Scanner topic from metadata_json (single discriminating field)
        scanner_topic = ""
        if metadata_json_str:
            try:
                meta = json.loads(metadata_json_str)
                scanner_topic = meta.get("topic") or ""
            except Exception:
                pass

        # primary_topics from file_primary_topics table (all 8 tags)
        topic_rows = conn.execute(
            "SELECT topic FROM file_primary_topics WHERE file_path = ? ORDER BY rank",
            (file_path,),
        ).fetchall()
        primary_topics = [r[0] for r in topic_rows]

        # Parent directory name as Course (one level up from file)
        course = Path(file_path).parent.name

        # Extract class identifier from stem (e.g., "Class 09-02" or "09-02")
        # Handles: "Objectivist Logic - Class 09-02", "ITOE Advanced Topics - Class 02-02 - Office Hours"
        class_id = ""
        m = re.search(r"Class\s+(\d{2}-\d{2}(?:\s+\S+)*)", stem)
        if m:
            class_id = m.group(0)  # "Class 09-02" or "Class 02-02 - Office Hours"
        else:
            # Try bare NN-NN pattern for non-"Class" filenames
            m2 = re.search(r"\b(\d{2}-\d{2})\b", stem)
            if m2:
                class_id = m2.group(1)

        lines = ["--- DOCUMENT METADATA ---"]
        lines.append(f"Title: {stem}")
        lines.append(f"Course: {course}")
        if class_id:
            lines.append(f"Class: {class_id}")
        if scanner_topic:
            lines.append(f"Topic: {scanner_topic}")
        if primary_topics:
            lines.append(f"Tags: {' '.join(primary_topics)}")
        lines.append("--- TRANSCRIPT ---")
        return "\n".join(lines) + "\n"
    ```

    After writing, verify the function produces correct output for two test cases using a quick inline test:
    ```bash
    python3 -c "
    import sqlite3
    from src.objlib.upload.header_builder import build_metadata_header
    conn = sqlite3.connect('data/library.db')
    # Find a Category A file
    row = conn.execute(\"SELECT file_path FROM files WHERE filename LIKE 'Objectivist Logic - Class 09-02%'\").fetchone()
    if row:
        print(build_metadata_header(row[0], conn))
    # Find a Category B file
    row2 = conn.execute(\"SELECT file_path FROM files WHERE filename LIKE 'MOTM_2019-03-03%'\").fetchone()
    if row2:
        print(build_metadata_header(row2[0], conn))
    conn.close()
    "
    ```

    Confirm the output includes:
    - Title line with filename stem
    - Class line with the class identifier (e.g., "Class 09-02")
    - Tags line with 8 space-separated primary_topics
    - Total header is under 200 tokens (rough count: ~15 words per line * 6 lines ≈ 90 tokens)
  </action>
  <verify>
    `python3 -c "from src.objlib.upload.header_builder import build_metadata_header; print('OK')"` exits 0.
    Manual test output shows "Class: Class 09-02" line present for the Objectivist Logic file.
    Manual test output shows "Tags:" line with 8 space-separated topics.
    Header ends with "--- TRANSCRIPT ---".
  </verify>
  <done>header_builder.py exists with build_metadata_header(). Function produces correct structured headers for Category A and B files. Import works without error.</done>
</task>

<task type="auto">
  <name>Task 2: Create ephemeral test store and upload test files in 4 conditions</name>
  <files>
    .planning/phases/16.3-retrievability-research/16.3-INTERVENTION.md
  </files>
  <action>
    **Create ephemeral test store and upload test files in 4 conditions.**

    The test design (from CLARIFICATIONS-ANSWERED.md Q2, extended Perplexity design):
    - Condition E-A: 5 Category A files WITH headers (experimental — class-number files)
    - Condition C-A: 3 Category A files WITHOUT headers (control — baseline failure)
    - Condition E-B: 5 Category B files WITH headers (experimental — MOTM generic)
    - Condition C-B: 2 Category B files WITHOUT headers (control — baseline failure)
    - Condition W-H: 5 working files WITH headers (regression check)

    Total: 20 files. (Adjusted from CLARIFICATIONS-ANSWERED.md to keep count round.)

    Write a standalone Python script (do NOT use objlib CLI — it uses production store by default):

    ```python
    # scripts/phase163_intervention_test.py
    """
    Phase 16.3 Intervention Test: Upload 20 files to ephemeral test store
    in 4 conditions (with/without metadata header) and run targeted queries.

    SAFETY: Uses ONLY objectivism-library-retrieval-test store. Never touches
    objectivism-library (production). Deletes test store after validation.
    """
    import asyncio
    import json
    import sqlite3
    import tempfile
    from pathlib import Path
    import keyring
    from google import genai
    from google.genai import types as genai_types

    DB_PATH = "data/library.db"
    TEST_STORE_NAME = "objectivism-library-retrieval-test"
    SEARCH_MODEL = "gemini-2.5-flash"

    # [implementation: select files from DB, build content with/without header,
    #  upload to test store, run queries, record results, delete test store]
    ```

    Rather than writing a long one-shot script that is hard to debug, implement this as a step-by-step sequence using the genai SDK directly:

    **Step 1: Create test store.**
    ```python
    import asyncio, keyring
    from google import genai
    api_key = keyring.get_password("objlib-gemini", "api_key")
    client = genai.Client(api_key=api_key)
    store = asyncio.run(client.aio.file_search_stores.create(config={"display_name": TEST_STORE_NAME}))
    print(f"Test store created: {store.name}")
    ```

    **Step 2: Select test files from DB.**
    SQL to select Category A files (Other-stem, class-number pattern):
    ```sql
    SELECT filename, file_path, metadata_json
    FROM files
    WHERE gemini_state = 'indexed'
      AND filename LIKE '% - Class %-%%.txt'
      AND json_extract(metadata_json, '$.topic') IS NOT NULL
    ORDER BY RANDOM()
    LIMIT 8
    ```

    SQL to select Category B files (MOTM files that failed A7):
    Use the specific filenames from T0-BASELINE.md that failed:
    - `MOTM_2019-03-03_Passages-from-and-positions-of-Ayn-Rand.txt`
    - `MOTM_2021-06-13_History-of-the-Objectivist-movement-a-personal-account-part.txt`
    - `MOTM_2022-08-21_Thinking-In-Examples.txt`
    Plus 4 more random MOTM files.

    SQL to select working files (non-Episode, non-class-number, non-MOTM files):
    ```sql
    SELECT filename, file_path, metadata_json
    FROM files
    WHERE gemini_state = 'indexed'
      AND filename NOT LIKE 'Episode %'
      AND filename NOT LIKE 'MOTM_%'
      AND filename NOT LIKE '% - Class %'
      AND json_extract(metadata_json, '$.topic') IS NOT NULL
      AND json_extract(metadata_json, '$.topic') != ''
    ORDER BY RANDOM()
    LIMIT 5
    ```

    **Step 3: For each file, build content and upload.**
    For experimental condition (WITH header):
    - Build header using `build_metadata_header(file_path, conn)`
    - Read raw transcript content
    - Write `header + "\n" + transcript_content` to a temp file
    - Upload temp file to test store via Files API -> poll ACTIVE -> import to test store

    For control condition (WITHOUT header):
    - Read raw transcript content as-is
    - Upload raw content to test store

    Batch sequentially with 3-second delays between uploads (per Q5 decision).

    Wait for all import operations to complete (poll `operation.done`).

    Wait an additional 10 seconds for search index propagation before running queries.

    **Step 4: Run targeted queries for all 20 files.**
    For each file, construct the query the same way `check_stability.py` does:
    - Use `topic` from `metadata_json` as the subject
    - Query: `f"What is '{topic}' about?"`

    Check if file appears in top-10 grounding chunks (match by store_doc_id prefix — note: these new uploads will have new Gemini file IDs, so match by the `display_name` we set equal to the filename).

    **IMPORTANT MATCHING:** For test store documents, match by checking if `retrieved_context.title` matches the new file's resource ID. Record the new file ID returned by upload for each test file, then check for it in top-10.

    **Step 5: Record results.**
    For each file, record:
    - filename
    - condition (E-A, C-A, E-B, C-B, W-H)
    - query used
    - found in top-10? (yes/no)
    - rank position (1-10, or None)

    Print results in a table, then write `16.3-INTERVENTION.md`.

    **Step 6: Delete test store.**
    ```python
    # Delete all documents first (required for non-empty store deletion)
    docs = await client.aio.file_search_stores.documents.list(parent=test_store_resource_name)
    async for doc in docs:
        await client.aio.file_search_stores.documents.delete(
            name=doc.name,
            config=genai_types.DeleteDocumentConfig(force=True)
        )
    # Then delete store
    await client.aio.file_search_stores.delete(name=test_store_resource_name, config={"force": True})
    ```

    Write `16.3-INTERVENTION.md` with:
    ```markdown
    # 16.3-INTERVENTION.md

    **Date:** [date]
    **Test store:** objectivism-library-retrieval-test (deleted after test)

    ## Test Design
    | Condition | Files | Description |
    |-----------|-------|-------------|
    | E-A | 5 | Category A WITH header |
    | C-A | 3 | Category A WITHOUT header (control) |
    | E-B | 5 | Category B WITH header |
    | C-B | 2 | Category B WITHOUT header (control) |
    | W-H | 5 | Working files WITH header |

    ## Results

    | Filename | Condition | Query | Found? | Rank |
    |----------|-----------|-------|--------|------|
    | ...      |           |       |        |      |

    ## Hit Rate by Condition

    | Condition | Hit Rate | Target |
    |-----------|----------|--------|
    | E-A (Cat A WITH header) | N/M | >80% |
    | C-A (Cat A WITHOUT header) | N/M | <20% |
    | E-B (Cat B WITH header) | N/M | >80% |
    | C-B (Cat B WITHOUT header) | N/M | <20% |
    | W-H (Working WITH header) | N/M | >95% |

    ## Conclusion

    H1 fix [WORKS / DOES NOT WORK]:
    [Category A files with headers retrieved successfully: YES/NO]
    [Control without headers failed as expected: YES/NO]
    [Working files maintained hit rate: YES/NO]

    Plan 16.3-03 production rollout: [GO / NO-GO]
    ```

    If hit rate for E-A (Category A WITH header) is <60%:
    - Record as PARTIAL EVIDENCE
    - Check if headers were actually different from control (verify header was in uploaded content)
    - Note: Gemini indexing may have a delay — consider noting this as a possible explanation
    - Still proceed to 16.3-03 with the caveat documented

    If hit rate for E-A is <40%:
    - Record as NEGATIVE RESULT
    - Investigate whether H4 (document_name) is the more viable fix
    - Pause before Plan 16.3-03 and surface for user decision
  </action>
  <verify>
    Ephemeral test store created and then deleted (not present in `client.file_search_stores.list()` after test).
    16.3-INTERVENTION.md exists with hit rate table by condition.
    E-A hit rate > 80% (Category A WITH header) — confirms H1 fix works.
    C-A hit rate < 20% (Category A WITHOUT header) — confirms baseline failure (control).
    W-H hit rate > 95% (working files with header) — confirms no regression.
    Production store `objectivism-library` document count unchanged (verify: `store-sync --dry-run` still shows 1749 documents, 0 orphans).
  </verify>
  <done>Intervention evidence documented. Category A files with metadata headers retrieve in top-10. Control (no header) fails as expected. No regression on working files. GO signal for Plan 16.3-03 production rollout.</done>
</task>

</tasks>

<verification>
Gate: Confirmed fix works on failing files; no regression on working files.

Check each:
- [ ] `src/objlib/upload/header_builder.py` exists and imports cleanly
- [ ] `build_metadata_header()` produces correct header for Category A and B test files
- [ ] Ephemeral test store was created and then deleted
- [ ] 16.3-INTERVENTION.md exists with quantitative hit rates by condition
- [ ] E-A hit rate > 80% (Category A WITH header retrieves)
- [ ] C-A hit rate < 20% (Category A WITHOUT header fails — confirms control)
- [ ] W-H hit rate > 95% (working files not degraded by headers)
- [ ] `python -m objlib store-sync --store objectivism-library` confirms 0 orphans (production store untouched)

If E-A hit rate is 60-80%: proceed with caution, document uncertainty.
If E-A hit rate < 60%: STOP and surface to user before Plan 16.3-03.
</verification>

<success_criteria>
Intervention test complete when:
1. `header_builder.py` produces correct structured headers for Category A and B files
2. `16.3-INTERVENTION.md` documents quantitative hit rates for all 5 conditions
3. E-A hit rate > 80% (confirming H1 fix works on class-number files)
4. Test store deleted — production untouched
5. GO signal recorded in intervention document for Plan 16.3-03 production rollout
</success_criteria>

<output>
After completion, create `.planning/phases/16.3-retrievability-research/16.3-02-SUMMARY.md` following the summary template.

Key fields to populate:
- Quantitative hit rates by condition
- GO/NO-GO decision for Plan 16.3-03
- Any unexpected findings (e.g., H4 actually viable, header format needs adjustment)
- Confirm header_builder.py is ready for production use in Plan 16.3-03
</output>
