---
phase: 03-search-and-cli
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/objlib/search/formatter.py
  - src/objlib/cli.py
  - tests/test_formatter.py
autonomous: true

must_haves:
  truths:
    - "Search results display three-tier citations: inline [1][2] markers, citation details panel with 100-150 char excerpts, and source listing table with scores"
    - "Relevance scores display as visual bar: ━━━━━━━━○○ 87%  (normalized 0-100%)"
    - "`objlib view <index>` shows detailed view of a single result with full metadata panel"
    - "`objlib view <index> --full` displays the complete source document text"
    - "`objlib view <index> --show-related` queries Gemini for similar documents and displays them"
    - "All display adapts to terminal width (truncation, wrapping)"
  artifacts:
    - path: "src/objlib/search/formatter.py"
      provides: "Score bars, compact list, detailed view, source table, three-tier citation display"
      contains: "score_bar"
    - path: "tests/test_formatter.py"
      provides: "Unit tests for score bars, truncation, citation formatting"
  key_links:
    - from: "src/objlib/cli.py (search command)"
      to: "src/objlib/search/formatter.py"
      via: "display_search_results() called after citation extraction"
      pattern: "display_search_results"
    - from: "src/objlib/cli.py (view command)"
      to: "src/objlib/search/formatter.py"
      via: "display_detailed_view() for single result"
      pattern: "display_detailed_view"
---

<objective>
Build the Rich display layer: three-tier citation display, score bar visualization, compact result list, detailed view command, and full document view.

Purpose: Transforms raw search results into polished terminal output. Implements the locked three-tier citation format (inline markers, details panel, source table) and the three-tier display hierarchy (compact list, detailed view, full document).

Output: `search` command uses Rich formatting for results. `view` command shows detailed/full views. All output adapts to terminal width.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-search-and-cli/03-RESEARCH.md
@.planning/phases/03-search-and-cli/03-01-SUMMARY.md
@src/objlib/cli.py
@src/objlib/models.py
@src/objlib/search/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create formatter module with score bars, three-tier display, and result rendering</name>
  <files>
    src/objlib/search/formatter.py
    tests/test_formatter.py
  </files>
  <action>
**Create `src/objlib/search/formatter.py`** with these functions:

**1. `score_bar(score: float, width: int = 10) -> str`**
Render visual relevance bar. Input: 0.0-1.0 float. Output: `━━━━━━━━○○ 87%`
- `filled = round(score * width)`; `empty = width - filled`
- Return `f"{'━' * filled}{'○' * empty} {int(score * 100)}%"`

**2. `truncate_text(text: str, max_len: int, suffix: str = "...") -> str`**
Truncate at word boundary. If `len(text) <= max_len`, return as-is. Otherwise truncate at last space before `max_len - len(suffix)` and append suffix.

**3. `display_search_results(response_text: str, citations: list[Citation], terminal_width: int, limit: int = 10) -> None`**
Three-tier citation display using Rich:

**Tier 1 -- Response with inline citation markers:**
Parse `response_text`. For each citation, if the citation's text appears as a substring or if grounding_supports provide segment indices, insert `[N]` markers. If exact insertion isn't possible (common), append citation indices at end of relevant sentences.
Display via `console.print(Panel(annotated_text, title="Answer", border_style="cyan"))`.

**Tier 2 -- Citation details panel:**
For each citation (up to `limit`):
```
[1] "Title of Document"  ━━━━━━━━○○ 87%
    Course: OPAR | Year: 2023 | Difficulty: intermediate
    "Excerpt of the retrieved passage text truncated to 100-150 chars..."
```
Use Rich `console.print()` with markup. Truncate excerpt to `min(150, terminal_width - 20)` chars at word boundary.

**Tier 3 -- Source listing table:**
Rich `Table` with columns: Ref ([N]), File, Course, Year, Relevance (score_bar).
Set `Table(title="Sources", show_header=True, expand=False)`.
Truncate file column to avoid table overflow.

**4. `display_detailed_view(citation: Citation, terminal_width: int) -> None`**
Rich `Panel` showing full metadata:
```
╭─ Document Title ──────────────────────╮
│ File:       filename.txt              │
│ Course:     OPAR                      │
│ Year:       2023 | Quarter: Q3        │
│ Difficulty: intermediate              │
│ Relevance:  ━━━━━━━━○○ 87%           │
├───────────────────────────────────────┤
│ Full passage text (not truncated)     │
╰───────────────────────────────────────╯
```
Use `Panel` with `title=citation.title`, `border_style="green"`.

**5. `display_no_results() -> None`**
Print `"[dim]No results found. Try a broader query.[/dim]"`.

**All functions use a module-level `console = Console()`.** Accept `Console` as optional parameter for testing.

**Create `tests/test_formatter.py`**:

- `test_score_bar_zero` -- `score_bar(0.0)` -> `"○○○○○○○○○○ 0%"`
- `test_score_bar_full` -- `score_bar(1.0)` -> `"━━━━━━━━━━ 100%"`
- `test_score_bar_partial` -- `score_bar(0.73)` -> `"━━━━━━━○○○ 73%"`
- `test_score_bar_custom_width` -- `score_bar(0.5, width=20)` -> 10 filled, 10 empty
- `test_truncate_text_short` -- Text under max_len returns unchanged
- `test_truncate_text_long` -- Text over max_len truncates at word boundary with "..."
- `test_truncate_text_exact` -- Text at exactly max_len returns unchanged
- `test_display_search_results_no_citations` -- Capture Rich output, verify "No results" or "No sources cited" message
- `test_display_search_results_with_citations` -- Create test Citations, capture output, verify tier 2 panel shows titles and excerpts, tier 3 table has correct rows
- `test_display_detailed_view` -- Create Citation with metadata, capture output, verify Panel contains course, year, difficulty, passage text

Use `from io import StringIO` and `Console(file=StringIO())` to capture Rich output for assertions.
  </action>
  <verify>
  Run `python -m pytest tests/test_formatter.py -v` -- all tests pass.
  Run `python -c "from objlib.search.formatter import score_bar, display_search_results; print(score_bar(0.87))"` -- prints `━━━━━━━━━○ 87%`.
  </verify>
  <done>
  - `score_bar()` renders visual bar for any 0.0-1.0 score
  - `display_search_results()` renders three-tier citation display
  - `display_detailed_view()` renders full metadata panel for a single result
  - `truncate_text()` handles word-boundary truncation
  - 10+ unit tests pass covering all formatting functions
  </done>
</task>

<task type="auto">
  <name>Task 2: Add view command to CLI and wire search command to rich formatter</name>
  <files>
    src/objlib/cli.py
    src/objlib/search/__init__.py
  </files>
  <action>
**1. Update the `search` command in `cli.py`** to use the rich formatter instead of basic output:

Replace the basic display section (the `Panel` and citation loop at the end of the search command) with:

```python
from objlib.search.formatter import display_search_results

# Create SearchResult for potential reuse
from objlib.models import SearchResult
result = SearchResult(
    response_text=response.text or "(No response text)",
    citations=citations,
    query=query,
    metadata_filter=metadata_filter,
)

display_search_results(result.response_text, result.citations, state.terminal_width, limit=limit)
```

**2. Add `view` command to `cli.py`**:

```python
@app.command()
def view(
    ctx: typer.Context,
    index: Annotated[int, typer.Argument(help="Result index from last search (1-based)")],
    full: Annotated[bool, typer.Option("--full", help="Show complete document text")] = False,
    show_related: Annotated[bool, typer.Option("--show-related", help="Find related documents")] = False,
    model: Annotated[str, typer.Option("--model", "-m", help="Gemini model")] = "gemini-2.5-flash",
) -> None:
    """View detailed information about a search result, optionally with related documents.

    Since commands are stateless (locked decision #4), this command performs a
    quick re-query if needed. Pass the search query via --query or rely on
    the index being a document identifier.

    For Phase 3 MVP: view takes a filename or result index. Since there's no
    session state, the view command works by looking up the file directly in SQLite.
    """
```

**Implementation details for `view`:**

The `view` command is stateless (locked decision #4). Since we can't store search results between commands, `view` works differently:

- Accept a **filename** (string) as the index argument via a workaround, OR accept an integer that maps to a file via SQLite query.
- Actually, the simplest stateless approach: `view` accepts a search query via `--query` option and an index into its results. If no `--query`, show help suggesting usage after a search.
- Alternative (simpler): `view` accepts a filename directly: `objlib view "Introduction to Objectivism.txt"` and looks it up in SQLite. This avoids re-querying.

**Choose the filename approach** for simplicity (stateless, no re-query needed):

```python
@app.command()
def view(
    ctx: typer.Context,
    filename: Annotated[str, typer.Argument(help="Filename to view (from search results)")],
    full: Annotated[bool, typer.Option("--full", help="Show complete document text from disk")] = False,
    show_related: Annotated[bool, typer.Option("--show-related", help="Find related documents via Gemini")] = False,
    limit: Annotated[int, typer.Option("--limit", "-l", help="Max related results")] = 5,
    model: Annotated[str, typer.Option("--model", "-m", help="Gemini model")] = "gemini-2.5-flash",
) -> None:
```

**`view` implementation:**
1. Open SQLite, look up `filename` in files table (by filename column).
2. If not found, print error and exit.
3. Parse metadata_json, build a Citation object with full metadata.
4. Call `display_detailed_view(citation, state.terminal_width)`.
5. If `--full`: Read the actual file from disk (using `file_path` from SQLite) and display with `console.print(Panel(content, title="Full Document"))`. Truncate if extremely long (>10000 chars) with a note.
6. If `--show-related`:
   - Read a brief excerpt from the file (first 500 chars).
   - Query Gemini with: `f"Find documents related to this content: {excerpt}"`, using the File Search tool.
   - Extract and enrich citations from the response.
   - Display as compact list using formatter.

**3. Update `src/objlib/search/__init__.py`** to export formatter functions:

```python
from objlib.search.formatter import (
    score_bar,
    display_search_results,
    display_detailed_view,
)
```
  </action>
  <verify>
  Run `objlib view --help` -- shows help with filename argument, --full, --show-related options.
  Run `objlib search --help` -- still works with all options.
  Run `python -m pytest tests/test_search.py tests/test_formatter.py -v` -- all tests still pass.
  </verify>
  <done>
  - `search` command uses three-tier Rich formatting for results
  - `view <filename>` command shows detailed metadata panel for a specific file
  - `view <filename> --full` displays complete document text from disk
  - `view <filename> --show-related` queries Gemini for related documents (on-demand cross-references, locked decision #9)
  - All existing tests still pass
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_formatter.py tests/test_search.py -v` -- all tests pass
2. `objlib search --help` -- shows search command documentation
3. `objlib view --help` -- shows view command documentation
4. `python -c "from objlib.search.formatter import score_bar; print(score_bar(0.87))"` -- prints formatted bar
5. Existing commands (`scan`, `status`, `purge`, `upload`) still work
</verification>

<success_criteria>
- Search results display with three-tier citations (inline markers, details panel, source table)
- Score bars render correctly for all values 0.0-1.0
- View command shows detailed metadata for any file in the database
- View --full displays document content from disk
- View --show-related performs on-demand Gemini cross-reference query
- Terminal width adaptive (truncation, no broken tables)
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-search-and-cli/03-02-SUMMARY.md`
</output>
