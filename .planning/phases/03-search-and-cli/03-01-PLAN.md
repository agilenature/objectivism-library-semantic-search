---
phase: 03-search-and-cli
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/objlib/models.py
  - src/objlib/config.py
  - src/objlib/database.py
  - src/objlib/search/__init__.py
  - src/objlib/search/client.py
  - src/objlib/search/citations.py
  - src/objlib/cli.py
  - tests/test_search.py
autonomous: true

must_haves:
  truths:
    - "Running `objlib search 'What is the Objectivist view of rights?'` calls Gemini File Search API and returns text with cited sources"
    - "If Gemini returns no grounding metadata, the CLI shows the response text with a 'No sources cited' message instead of crashing"
    - "API key is loaded from system keyring (objlib-gemini) with GEMINI_API_KEY env var fallback"
    - "Failed API calls retry 3 times with exponential backoff (0.5s, 1s, 2s + jitter) and display retry status via Rich"
    - "Each citation maps Gemini's grounding_chunk title back to SQLite metadata (course, year, difficulty)"
  artifacts:
    - path: "src/objlib/search/__init__.py"
      provides: "Search subpackage public API"
    - path: "src/objlib/search/client.py"
      provides: "GeminiSearchClient with query_with_retry and store name resolution"
      contains: "query_with_retry"
    - path: "src/objlib/search/citations.py"
      provides: "Citation extraction from GroundingMetadata and SQLite enrichment"
      contains: "extract_citations"
    - path: "src/objlib/models.py"
      provides: "SearchResult, Citation, AppState dataclasses"
      contains: "AppState"
    - path: "src/objlib/config.py"
      provides: "get_api_key() with keyring + env var fallback"
      contains: "get_api_key"
    - path: "tests/test_search.py"
      provides: "Unit tests for search client, citations, and metadata filter builder"
  key_links:
    - from: "src/objlib/cli.py"
      to: "src/objlib/search/client.py"
      via: "AppState.gemini_client used in search command"
      pattern: "query_with_retry"
    - from: "src/objlib/search/citations.py"
      to: "src/objlib/database.py"
      via: "filename lookup to enrich citations with SQLite metadata"
      pattern: "get_file_metadata_by_filename"
    - from: "src/objlib/cli.py"
      to: "src/objlib/config.py"
      via: "get_api_key() called in app callback to initialize AppState"
      pattern: "get_api_key"
---

<objective>
Build the semantic search query layer: Gemini File Search client, citation extraction, AppState initialization, and the `search` command.

Purpose: This is the foundation for all Phase 3 functionality. It establishes the query pipeline (user query -> Gemini API -> grounding metadata -> enriched citations) that the display and navigation layers build upon.

Output: Working `objlib search "query"` command that calls Gemini, extracts citations, enriches with SQLite metadata, and prints basic results. Three-tier display formatting is handled in Plan 02; this plan focuses on the data pipeline.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-search-and-cli/03-RESEARCH.md
@src/objlib/cli.py
@src/objlib/models.py
@src/objlib/config.py
@src/objlib/database.py
@src/objlib/upload/client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create search subpackage with GeminiSearchClient, citation extraction, and data models</name>
  <files>
    src/objlib/search/__init__.py
    src/objlib/search/client.py
    src/objlib/search/citations.py
    src/objlib/models.py
    src/objlib/config.py
    src/objlib/database.py
  </files>
  <action>
**1. Extend `src/objlib/models.py`** -- Add three new dataclasses:

```python
@dataclass
class Citation:
    """A single citation extracted from Gemini grounding metadata."""
    index: int                    # 1-based display index
    title: str                    # display_name from upload (matches filename column)
    uri: str | None               # Gemini file URI
    text: str                     # Retrieved passage text
    document_name: str | None     # Full Gemini resource name
    confidence: float             # Aggregated confidence score (0.0-1.0)
    file_path: str | None = None  # Local file path from SQLite (enriched)
    metadata: dict | None = None  # Full metadata from SQLite (enriched)

@dataclass
class SearchResult:
    """Complete search result from a Gemini query."""
    response_text: str            # Gemini's generated response
    citations: list[Citation]     # Extracted and enriched citations
    query: str                    # Original query string
    metadata_filter: str | None   # AIP-160 filter applied, if any

@dataclass
class AppState:
    """Shared state across all CLI commands. Initialized in app callback."""
    gemini_client: object         # genai.Client (use object to avoid import at module level)
    store_resource_name: str      # Resolved Gemini store resource name (e.g. "fileSearchStores/abc123")
    db_path: str                  # Path to SQLite database
    terminal_width: int           # Current terminal width for adaptive display
```

**2. Extend `src/objlib/config.py`** -- Add `get_api_key()` function:

```python
def get_api_key() -> str:
    """Get Gemini API key: system keyring first, then GEMINI_API_KEY env var fallback.

    Returns:
        API key string.

    Raises:
        RuntimeError: If no key found anywhere, with actionable instructions.
    """
    # Try keyring (consistent with Phase 2: service=objlib-gemini, key=api_key)
    api_key = keyring.get_password(SERVICE_NAME, KEY_NAME)
    if api_key:
        return api_key

    # Fallback to environment variable (per locked decision #6)
    api_key = os.environ.get("GEMINI_API_KEY")
    if api_key:
        return api_key

    raise RuntimeError(
        "Gemini API key not found.\n"
        "Set it with: objlib config set-api-key YOUR_KEY\n"
        "Or: export GEMINI_API_KEY=your-key"
    )
```

Import `os` at the top of config.py if not already present.

**3. Extend `src/objlib/database.py`** -- Add method for filename-to-metadata lookup:

```python
def get_file_metadata_by_filenames(self, filenames: list[str]) -> dict[str, dict]:
    """Return metadata for files matching the given filenames.

    Used to enrich Gemini citations (which provide display_name/title)
    with local metadata (course, year, difficulty, etc).

    Args:
        filenames: List of filename strings to look up.

    Returns:
        Dict mapping filename -> {"file_path": str, "metadata": dict}
    """
    if not filenames:
        return {}
    placeholders = ",".join("?" * len(filenames))
    rows = self.conn.execute(
        f"SELECT filename, file_path, metadata_json FROM files "
        f"WHERE filename IN ({placeholders}) AND status != 'LOCAL_DELETE'",
        filenames,
    ).fetchall()

    import json
    result = {}
    for row in rows:
        meta = json.loads(row["metadata_json"]) if row["metadata_json"] else {}
        result[row["filename"]] = {
            "file_path": row["file_path"],
            "metadata": meta,
        }
    return result
```

**4. Create `src/objlib/search/__init__.py`**:

```python
"""Search subpackage for querying Gemini File Search stores."""

from objlib.search.client import GeminiSearchClient
from objlib.search.citations import extract_citations, enrich_citations

__all__ = [
    "GeminiSearchClient",
    "extract_citations",
    "enrich_citations",
]
```

**5. Create `src/objlib/search/client.py`** -- GeminiSearchClient:

- Constructor takes `genai.Client` and `store_resource_name: str`
- `query(query: str, metadata_filter: str | None = None, model: str = "gemini-2.5-flash") -> GenerateContentResponse` -- Calls `client.models.generate_content()` with `types.Tool(file_search=types.FileSearch(file_search_store_names=[self.store_resource_name], metadata_filter=metadata_filter))`
- `query_with_retry(...)` -- Wraps `query()` with tenacity: `stop_after_attempt(3)`, `wait_exponential_jitter(initial=0.5, max=2.0, jitter=0.5)`, retry on `Exception` (broad for now; Gemini SDK raises various types). Before each retry sleep, print `"[yellow]Retrying search ({attempt}/3)...[/yellow]"` via Rich console.
- `resolve_store_name(client: genai.Client, display_name: str) -> str` -- Static/class method. Lists stores, finds by display_name, returns resource name. Reuses pattern from `GeminiFileSearchClient.get_or_create_store()` but synchronous (use `client.file_search_stores.list()` not `aio`).
- 30-second timeout via `types.GenerateContentConfig(..., request_options={"timeout": 30})` or equivalent if the SDK supports it. If not directly supported, wrap in asyncio with timeout.

Important: Use synchronous genai Client methods (not `.aio.`). The search commands use `asyncio.run()` only if needed for specific async calls. The `generate_content()` method is synchronous in the SDK.

**6. Create `src/objlib/search/citations.py`**:

- `extract_citations(grounding_metadata) -> list[Citation]` -- Takes the `GroundingMetadata` object from `response.candidates[0].grounding_metadata`. Iterates `grounding_chunks`, extracts `retrieved_context.title`, `.uri`, `.text`, `.document_name`. Computes per-chunk confidence by averaging scores from all `grounding_supports` that reference that chunk index. Returns list of `Citation` objects. **Must handle None at every level** (grounding_metadata, grounding_chunks, retrieved_context, grounding_supports, confidence_scores).
- `enrich_citations(citations: list[Citation], db: Database) -> list[Citation]` -- Collects all titles from citations, calls `db.get_file_metadata_by_filenames()`, sets `citation.file_path` and `citation.metadata` on each. Returns the same list (mutated in place).
- `build_metadata_filter(filters: list[str]) -> str | None` -- Converts CLI `--filter field:value` pairs to AIP-160 syntax. Supports operators: `field:value` -> `field="value"` or `field=value` (numeric), `field:>value` -> `field>value`, `field:>=value`, `field:<value`, `field:<=value`. Joins with ` AND `. Validates field names against known set: `{category, course, difficulty, quarter, date, year, week, quality_score}`. Raises `typer.BadParameter` for unknown fields.

  </action>
  <verify>
  Run `python -c "from objlib.models import Citation, SearchResult, AppState; print('Models OK')"` and
  `python -c "from objlib.search import GeminiSearchClient, extract_citations, enrich_citations; print('Search package OK')"` and
  `python -c "from objlib.config import get_api_key; print('Config OK')"` -- all should print OK without import errors.
  Also run `python -c "from objlib.search.citations import build_metadata_filter; assert build_metadata_filter(['course:OPAR', 'year:2023']) == 'course=\"OPAR\" AND year=2023'; print('Filter builder OK')"`
  </verify>
  <done>
  - `Citation`, `SearchResult`, `AppState` dataclasses importable from `objlib.models`
  - `get_api_key()` in config.py returns keyring key or env var or raises RuntimeError
  - `GeminiSearchClient` in `search/client.py` has `query_with_retry()` method
  - `extract_citations()` safely handles None grounding metadata
  - `build_metadata_filter()` converts CLI filter syntax to AIP-160 strings
  - `enrich_citations()` maps Gemini titles to SQLite metadata via `Database.get_file_metadata_by_filenames()`
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire search command into CLI with AppState callback and add tests</name>
  <files>
    src/objlib/cli.py
    tests/test_search.py
  </files>
  <action>
**1. Modify `src/objlib/cli.py`** -- Add AppState callback and search command:

First, update the app description and add the callback:

```python
app = typer.Typer(
    help="Objectivism Library - Search, browse, and explore your philosophical library",
    rich_markup_mode="rich",
)
```

Add `@app.callback(invoke_without_command=True)` that initializes AppState:

```python
@app.callback(invoke_without_command=True)
def app_callback(
    ctx: typer.Context,
    store: Annotated[
        str,
        typer.Option("--store", "-s", help="Gemini File Search store display name"),
    ] = "objectivism-library-v1",
    db_path: Annotated[
        Path,
        typer.Option("--db", "-d", help="Path to SQLite database"),
    ] = Path("data/library.db"),
) -> None:
    """Initialize shared state for search/browse/filter commands."""
    if ctx.invoked_subcommand in (None, "scan", "status", "purge", "upload", "config"):
        # Skip AppState init for commands that don't need Gemini
        return

    import shutil
    from google import genai
    from objlib.config import get_api_key
    from objlib.models import AppState
    from objlib.search.client import GeminiSearchClient

    try:
        api_key = get_api_key()
    except RuntimeError as e:
        console.print(f"[red]{e}[/red]")
        raise typer.Exit(code=1)

    client = genai.Client(api_key=api_key)

    # Resolve store display name to resource name
    try:
        resource_name = GeminiSearchClient.resolve_store_name(client, store)
    except Exception as e:
        console.print(f"[red]Failed to resolve store '{store}':[/red] {e}")
        raise typer.Exit(code=1)

    ctx.obj = AppState(
        gemini_client=client,
        store_resource_name=resource_name,
        db_path=str(db_path),
        terminal_width=shutil.get_terminal_size().columns,
    )
```

Add a type-safe state accessor:
```python
def get_state(ctx: typer.Context) -> "AppState":
    """Type-safe accessor for AppState from Typer context."""
    if ctx.obj is None:
        console.print("[red]Application state not initialized. Is the Gemini API key configured?[/red]")
        raise typer.Exit(code=1)
    return ctx.obj
```

Add the `search` command:
```python
@app.command()
def search(
    ctx: typer.Context,
    query: Annotated[str, typer.Argument(help="Semantic search query")],
    filter: Annotated[
        list[str] | None,
        typer.Option("--filter", "-f", help="Metadata filter (field:value). Filterable: category, course, difficulty, quarter, date, year, week, quality_score"),
    ] = None,
    limit: Annotated[int, typer.Option("--limit", "-l", help="Max results to display")] = 10,
    model: Annotated[str, typer.Option("--model", "-m", help="Gemini model for search")] = "gemini-2.5-flash",
) -> None:
    """Search the library by meaning with optional metadata filters."""
    from objlib.search.client import GeminiSearchClient
    from objlib.search.citations import extract_citations, enrich_citations, build_metadata_filter

    state = get_state(ctx)

    # Build AIP-160 filter
    metadata_filter = build_metadata_filter(filter) if filter else None

    search_client = GeminiSearchClient(state.gemini_client, state.store_resource_name)

    console.print(f"[dim]Searching for:[/dim] [bold]{query}[/bold]")
    if metadata_filter:
        console.print(f"[dim]Filter:[/dim] {metadata_filter}")

    try:
        response = search_client.query_with_retry(query, metadata_filter=metadata_filter, model=model)
    except Exception as e:
        console.print(f"[red]Search failed after retries:[/red] {e}")
        raise typer.Exit(code=1)

    # Extract citations from grounding metadata
    grounding = None
    if response.candidates:
        grounding = response.candidates[0].grounding_metadata

    citations = extract_citations(grounding)

    # Enrich with SQLite metadata
    with Database(state.db_path) as db:
        enrich_citations(citations, db)

    # Basic display (Plan 02 adds rich formatting)
    response_text = response.text or "(No response text)"
    console.print()
    console.print(Panel(response_text, title="Results", border_style="cyan"))

    if not citations:
        console.print("[dim]No sources cited.[/dim]")
        return

    # Basic citation list (Plan 02 replaces with three-tier display)
    console.print()
    for cite in citations[:limit]:
        meta = cite.metadata or {}
        course = meta.get("course", "")
        year = meta.get("year", "")
        score_pct = int(cite.confidence * 100)
        console.print(
            f"[yellow][{cite.index}][/yellow] [bold]{cite.title}[/bold]  "
            f"[green]{score_pct}%[/green]"
            + (f"  | {course}" if course else "")
            + (f", {year}" if year else "")
        )
        if cite.text:
            excerpt = cite.text[:150].rsplit(" ", 1)[0] + "..." if len(cite.text) > 150 else cite.text
            console.print(f"    [dim]{excerpt}[/dim]")
```

**Important:** The callback must NOT break existing commands (scan, status, purge, upload, config). It only initializes AppState when a search/browse/filter/view command is invoked. Use `ctx.invoked_subcommand` to skip initialization for existing commands.

**2. Create `tests/test_search.py`**:

Write tests using mocks (no real API calls):

- `test_build_metadata_filter_single_string` -- `["course:OPAR"]` -> `'course="OPAR"'`
- `test_build_metadata_filter_single_numeric` -- `["year:2023"]` -> `'year=2023'`
- `test_build_metadata_filter_combined` -- `["course:OPAR", "year:2023"]` -> `'course="OPAR" AND year=2023'`
- `test_build_metadata_filter_comparison` -- `["year:>=2020"]` -> `'year>=2020'`
- `test_build_metadata_filter_empty` -- `[]` -> `None`
- `test_build_metadata_filter_invalid_field` -- `["bogus:value"]` raises `typer.BadParameter`
- `test_extract_citations_none_metadata` -- `extract_citations(None)` -> `[]`
- `test_extract_citations_no_chunks` -- metadata with `grounding_chunks=None` -> `[]`
- `test_extract_citations_with_chunks` -- Mock grounding metadata with 2 chunks + supports, verify Citation objects have correct titles, texts, and aggregated confidence scores
- `test_enrich_citations_matches_filename` -- Create in-memory SQLite DB with test data, verify enrichment populates `file_path` and `metadata`
- `test_enrich_citations_unmatched` -- Citation with title not in DB gets `file_path=None`, `metadata=None`
- `test_get_api_key_from_keyring` -- Mock `keyring.get_password` to return a key
- `test_get_api_key_from_env_var` -- Mock keyring returning None, set env var, verify fallback
- `test_get_api_key_neither` -- Mock both returning None, verify RuntimeError

Use `unittest.mock.patch` for keyring and API calls. Use `unittest.mock.MagicMock` to create fake grounding metadata objects matching the SDK's Pydantic structure.
  </action>
  <verify>
  Run `cd /Users/david/projects/objectivism-library-semantic-search && python -m pytest tests/test_search.py -v` -- all tests pass.
  Run `objlib search --help` -- shows help text with query argument, --filter, --limit, --model options.
  Run `objlib scan --help` -- still works (callback doesn't break existing commands).
  </verify>
  <done>
  - `objlib search "query"` command exists with --filter, --limit, --model options
  - AppState initialized via callback only for search/browse/filter/view commands
  - Existing commands (scan, status, purge, upload, config) unaffected by callback
  - 14+ unit tests pass covering filter building, citation extraction, enrichment, and API key loading
  - Search command calls Gemini, extracts citations, enriches from SQLite, displays basic results
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_search.py -v` -- all tests pass
2. `python -c "from objlib.search import GeminiSearchClient, extract_citations"` -- no import errors
3. `objlib search --help` -- shows search command with arguments and options
4. `objlib scan --help` -- existing command still works
5. `objlib status --help` -- existing command still works
6. `objlib upload --help` -- existing command still works
</verification>

<success_criteria>
- GeminiSearchClient can query a File Search store with retry logic
- Citation extraction safely handles all None cases in grounding metadata
- Citations are enriched with SQLite metadata (course, year, difficulty)
- Metadata filter builder converts CLI syntax to AIP-160 format
- AppState callback initializes Gemini client + store resolution for search commands
- All existing CLI commands remain functional
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-search-and-cli/03-01-SUMMARY.md`
</output>
