---
phase: 03-search-and-cli
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/objlib/database.py
  - src/objlib/cli.py
  - tests/test_browse_filter.py
autonomous: true

must_haves:
  truths:
    - "`objlib browse` (no args) shows top-level library structure: categories with file counts"
    - "`objlib browse --category course` lists all 76 courses with file counts"
    - "`objlib browse --course 'OPAR'` lists files within that course, ordered by lesson/year/quarter/week"
    - "`objlib filter course:OPAR year:2023` returns matching files from SQLite without calling Gemini"
    - "Filter command validates field names and shows helpful error for unknown fields"
    - "Browse and filter output uses Rich tables with consistent formatting"
  artifacts:
    - path: "src/objlib/database.py"
      provides: "Hierarchical metadata query methods for browse and filter"
      contains: "get_categories_with_counts"
    - path: "tests/test_browse_filter.py"
      provides: "Unit tests for browse queries and filter validation"
  key_links:
    - from: "src/objlib/cli.py (browse command)"
      to: "src/objlib/database.py"
      via: "get_categories_with_counts, get_courses_with_counts, get_files_by_course"
      pattern: "get_categories_with_counts"
    - from: "src/objlib/cli.py (filter command)"
      to: "src/objlib/database.py"
      via: "filter_files_by_metadata for SQLite-only queries"
      pattern: "filter_files_by_metadata"
---

<objective>
Build the structural navigation layer: `browse` command for hierarchical exploration and `filter` command for metadata-only queries against SQLite.

Purpose: Enables users to explore the library without a search query. Browse provides drill-down navigation (categories -> courses -> files). Filter provides metadata-only file listing. Neither command calls the Gemini API -- they work entirely from local SQLite data.

Output: Working `objlib browse` and `objlib filter` commands with Rich table output.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-search-and-cli/03-RESEARCH.md
@.planning/phases/03-search-and-cli/03-01-SUMMARY.md
@src/objlib/cli.py
@src/objlib/database.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add hierarchical metadata query methods to Database class</name>
  <files>
    src/objlib/database.py
    tests/test_browse_filter.py
  </files>
  <action>
**Extend `src/objlib/database.py`** with these methods:

**1. `get_categories_with_counts(self) -> list[tuple[str, int]]`**
Top-level browse: categories with file counts.
```sql
SELECT json_extract(metadata_json, '$.category') as category,
       COUNT(*) as count
FROM files
WHERE metadata_json IS NOT NULL AND status != 'LOCAL_DELETE'
GROUP BY category
ORDER BY count DESC
```
Returns list of `(category_name, count)` tuples. Treats `None` category as `"uncategorized"`.

**2. `get_courses_with_counts(self) -> list[tuple[str, int]]`**
List all courses with file counts (for `browse --category course`).
```sql
SELECT json_extract(metadata_json, '$.course') as course,
       COUNT(*) as count
FROM files
WHERE json_extract(metadata_json, '$.category') = 'course'
  AND status != 'LOCAL_DELETE'
GROUP BY course
ORDER BY course
```
Returns list of `(course_name, count)` tuples.

**3. `get_files_by_course(self, course: str, year: str | None = None) -> list[dict]`**
Files within a course, optionally filtered by year. Ordered by lesson_number, year, quarter, week.
```sql
SELECT filename, file_path, metadata_json FROM files
WHERE json_extract(metadata_json, '$.course') = ?
  AND status != 'LOCAL_DELETE'
  [AND json_extract(metadata_json, '$.year') = ? -- if year provided]
ORDER BY json_extract(metadata_json, '$.lesson_number'),
         json_extract(metadata_json, '$.year'),
         json_extract(metadata_json, '$.quarter'),
         json_extract(metadata_json, '$.week'),
         filename
```
Returns list of dicts with `filename`, `file_path`, `metadata` (parsed from JSON).

**4. `get_items_by_category(self, category: str) -> list[dict]`**
Files within a non-course category (e.g., "motm", "book", "unknown"). Ordered by filename.
```sql
SELECT filename, file_path, metadata_json FROM files
WHERE json_extract(metadata_json, '$.category') = ?
  AND status != 'LOCAL_DELETE'
ORDER BY filename
```
Returns list of dicts with `filename`, `file_path`, `metadata` (parsed).

**5. `filter_files_by_metadata(self, filters: dict[str, str], limit: int = 50) -> list[dict]`**
General metadata filter query for the `filter` command. Builds WHERE clauses from a dict of field:value pairs.

```python
def filter_files_by_metadata(self, filters: dict[str, str], limit: int = 50) -> list[dict]:
    """Query files by metadata field values.

    Supports the same fields as Gemini metadata_filter:
    category, course, difficulty, quarter, date, year, week, quality_score.

    Comparison operators in values: >=, <=, >, < are supported.

    Args:
        filters: Dict of {field_name: value_or_comparison}.
        limit: Maximum results.

    Returns:
        List of dicts with filename, file_path, metadata.
    """
    import json as json_module

    VALID_FIELDS = {"category", "course", "difficulty", "quarter", "date", "year", "week", "quality_score"}

    where_parts = ["status != 'LOCAL_DELETE'", "metadata_json IS NOT NULL"]
    params: list = []

    for field, value in filters.items():
        if field not in VALID_FIELDS:
            raise ValueError(f"Unknown filter field: {field}. Valid: {', '.join(sorted(VALID_FIELDS))}")

        json_path = f"$.{field}"

        # Check for comparison operators
        if value.startswith(">="):
            where_parts.append(f"json_extract(metadata_json, ?) >= ?")
            params.extend([json_path, value[2:]])
        elif value.startswith("<="):
            where_parts.append(f"json_extract(metadata_json, ?) <= ?")
            params.extend([json_path, value[2:]])
        elif value.startswith(">"):
            where_parts.append(f"json_extract(metadata_json, ?) > ?")
            params.extend([json_path, value[1:]])
        elif value.startswith("<"):
            where_parts.append(f"json_extract(metadata_json, ?) < ?")
            params.extend([json_path, value[1:]])
        else:
            # Exact match (try numeric for year/week/quality_score)
            try:
                numeric_val = int(value)
                where_parts.append(f"json_extract(metadata_json, ?) = ?")
                params.extend([json_path, numeric_val])
            except ValueError:
                where_parts.append(f"json_extract(metadata_json, ?) = ?")
                params.extend([json_path, value])

    where_clause = " AND ".join(where_parts)
    sql = f"""
        SELECT filename, file_path, metadata_json
        FROM files
        WHERE {where_clause}
        ORDER BY filename
        LIMIT ?
    """
    params.append(limit)

    rows = self.conn.execute(sql, params).fetchall()
    results = []
    for row in rows:
        meta = json_module.loads(row["metadata_json"]) if row["metadata_json"] else {}
        results.append({
            "filename": row["filename"],
            "file_path": row["file_path"],
            "metadata": meta,
        })
    return results
```

**Create `tests/test_browse_filter.py`**:

Set up a test fixture that creates an in-memory SQLite database with `Database(":memory:")` (or a temp file) and inserts ~10 test file records with varied metadata:
- 3 files with category="course", course="OPAR", varying years
- 2 files with category="course", course="ITOE"
- 2 files with category="motm"
- 2 files with category="book"
- 1 file with status="LOCAL_DELETE" (should be excluded)

Tests:
- `test_get_categories_with_counts` -- Returns 3 categories (course, motm, book) with correct counts. LOCAL_DELETE excluded.
- `test_get_courses_with_counts` -- Returns 2 courses (OPAR=3, ITOE=2).
- `test_get_files_by_course` -- `get_files_by_course("OPAR")` returns 3 files.
- `test_get_files_by_course_with_year` -- Filtered by year returns subset.
- `test_get_items_by_category` -- `get_items_by_category("motm")` returns 2 files.
- `test_filter_files_exact` -- `filter_files_by_metadata({"course": "OPAR"})` returns 3.
- `test_filter_files_numeric` -- `filter_files_by_metadata({"year": "2023"})` returns correct count.
- `test_filter_files_comparison` -- `filter_files_by_metadata({"year": ">=2022"})` returns correct count.
- `test_filter_files_combined` -- `filter_files_by_metadata({"course": "OPAR", "year": "2023"})` returns intersection.
- `test_filter_files_invalid_field` -- `filter_files_by_metadata({"bogus": "val"})` raises ValueError.
- `test_filter_files_excludes_deleted` -- LOCAL_DELETE records never appear.
  </action>
  <verify>
  Run `python -m pytest tests/test_browse_filter.py -v` -- all tests pass.
  Run `python -c "from objlib.database import Database; print('DB methods OK')"` -- no import errors.
  </verify>
  <done>
  - Database class has 5 new query methods for hierarchical navigation and filtering
  - All methods exclude LOCAL_DELETE records
  - `filter_files_by_metadata` validates field names and supports comparison operators
  - 11+ unit tests pass with in-memory test database
  </done>
</task>

<task type="auto">
  <name>Task 2: Add browse and filter commands to CLI</name>
  <files>
    src/objlib/cli.py
  </files>
  <action>
**Add `browse` command to `cli.py`**:

```python
@app.command()
def browse(
    ctx: typer.Context,
    category: Annotated[
        str | None,
        typer.Option("--category", "-c", help="Filter by category (course, motm, book, etc.)"),
    ] = None,
    course: Annotated[
        str | None,
        typer.Option("--course", help="Show files within a specific course"),
    ] = None,
    year: Annotated[
        str | None,
        typer.Option("--year", "-y", help="Filter by year (within a course)"),
    ] = None,
    db_path: Annotated[
        Path,
        typer.Option("--db", "-d", help="Path to SQLite database"),
    ] = Path("data/library.db"),
) -> None:
    """Browse the library structure: categories, courses, and files.

    Progressive drill-down:
      objlib browse                         # Show categories
      objlib browse --category course       # Show courses
      objlib browse --course "OPAR"         # Show files in OPAR
      objlib browse --course "OPAR" --year 2023  # Filter by year
    """
```

**Browse implementation -- three levels of drill-down:**

**Level 1 -- No filters (top-level categories):**
```python
if course is None and category is None:
    with Database(db_path) as db:
        categories = db.get_categories_with_counts()

    table = Table(title="Library Structure", show_header=True)
    table.add_column("Category", style="bold cyan")
    table.add_column("Files", justify="right", style="green")
    for cat, count in categories:
        table.add_row(cat or "uncategorized", str(count))
    console.print(table)
    console.print("\n[dim]Drill down: objlib browse --category <name>[/dim]")
```

**Level 2 -- Category specified:**
If category == "course": use `get_courses_with_counts()`, display as table with course name + count. Add hint: `"Drill down: objlib browse --course <name>"`.
If category is anything else (motm, book, etc.): use `get_items_by_category(category)`, display as file listing table.

**Level 3 -- Course specified:**
Use `get_files_by_course(course, year)`. Display table with columns: Filename, Year, Quarter, Week, Difficulty. Extract from metadata dict.

**Add `filter` command to `cli.py`**:

```python
@app.command(name="filter")
def filter_cmd(
    ctx: typer.Context,
    filters: Annotated[
        list[str],
        typer.Argument(help="Metadata filters as field:value pairs (e.g., course:OPAR year:2023 difficulty:introductory)"),
    ],
    limit: Annotated[int, typer.Option("--limit", "-l", help="Max results")] = 50,
    db_path: Annotated[
        Path,
        typer.Option("--db", "-d", help="Path to SQLite database"),
    ] = Path("data/library.db"),
) -> None:
    """List files matching metadata filters (no semantic search).

    Queries local SQLite database only -- does not call Gemini API.
    Supports fields: category, course, difficulty, quarter, date, year, week, quality_score.
    Comparison operators: field:>value, field:>=value, field:<value, field:<=value.

    Examples:
      objlib filter course:OPAR
      objlib filter course:OPAR year:2023
      objlib filter year:>=2020 difficulty:introductory
    """
```

**Filter implementation:**
1. Parse each filter string: split on first `:` to get field and value.
2. Build filters dict: `{"course": "OPAR", "year": "2023"}`.
3. Validate: if any field has no `:`, print error and exit.
4. Call `db.filter_files_by_metadata(filters_dict, limit=limit)`.
5. If ValueError raised (unknown field), print the error message and exit.
6. Display results as Rich Table with columns: Filename, Course, Year, Difficulty, Category.
7. Show count: `"Found {N} file(s) matching filters."`.
8. If no results: `"[yellow]No files match the given filters.[/yellow]"`.

**Important notes:**
- `browse` and `filter` do NOT need AppState (no Gemini calls). They accept `--db` directly like existing `scan`/`status` commands.
- Name the filter command function `filter_cmd` to avoid shadowing Python's built-in `filter`.
- Use `name="filter"` in the decorator so the CLI command name is `filter`.
- Both commands must NOT trigger the AppState callback. The callback already skips for unrecognized subcommands since it checks `ctx.invoked_subcommand`. Add "browse" and "filter" to the skip list in the callback: `if ctx.invoked_subcommand in (None, "scan", "status", "purge", "upload", "config", "browse", "filter"):`.

Actually, a cleaner approach: only initialize AppState for commands that NEED it (search, view). Change the callback to use an allowlist:
```python
GEMINI_COMMANDS = {"search", "view"}
if ctx.invoked_subcommand not in GEMINI_COMMANDS:
    return
```
  </action>
  <verify>
  Run `objlib browse --help` -- shows help with --category, --course, --year options.
  Run `objlib filter --help` -- shows help with filter arguments and --limit option.
  Run `objlib browse --db data/library.db` -- shows categories table from real database (if available).
  Run `objlib filter course:OPAR --db data/library.db` -- shows matching files.
  Run `python -m pytest tests/ -v` -- all tests pass.
  </verify>
  <done>
  - `objlib browse` shows top-level categories with file counts
  - `objlib browse --category course` lists all courses
  - `objlib browse --course "OPAR"` lists files in OPAR with year/quarter/week
  - `objlib filter course:OPAR year:2023` returns matching files from SQLite
  - `objlib filter bogus:value` shows helpful error with valid field names
  - Browse and filter do not trigger Gemini API initialization
  - All existing commands and tests still work
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_browse_filter.py -v` -- all tests pass
2. `python -m pytest tests/ -v` -- full test suite passes
3. `objlib browse --help` -- shows browse command documentation
4. `objlib filter --help` -- shows filter command documentation
5. `objlib scan --help` -- existing command still works
6. `objlib search --help` -- search command still works
</verification>

<success_criteria>
- Browse command provides three-level drill-down (categories -> courses -> files)
- Filter command queries SQLite with validated field names and comparison operators
- Neither browse nor filter calls the Gemini API
- Both commands use Rich tables for consistent formatting
- Invalid filter fields produce helpful error messages
- LOCAL_DELETE records excluded from all results
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-search-and-cli/03-03-SUMMARY.md`
</output>
