---
phase: 18-rxpy-codebase-wide-async-migration
plan: 03
type: execute
wave: 3
depends_on: ["18-02"]
files_modified:
  - src/objlib/extraction/batch_orchestrator.py
  - src/objlib/extraction/orchestrator.py
autonomous: true

must_haves:
  truths:
    - "Semaphore+gather fan-outs in batch_orchestrator.py replaced with flat_map(max_concurrent=N)"
    - "AsyncLimiter rate-limiting replaced with RxPY throttle or custom rate-limit operator (from 18-01 contracts)"
    - "Polling loop for batch job completion replaced with rx.interval(period).pipe(ops.take_while(not_done))"
    - "Wave 1/2 checkpoint logic in extraction/orchestrator.py replaced with concat_map + state Subject"
    - "Batch-extract smoke test passes against real Mistral job (or mock if offline)"
    - "Full pytest suite passes: no behavior regression"
  artifacts:
    - path: "src/objlib/extraction/batch_orchestrator.py"
      provides: "Extraction batch orchestrator using RxPY flat_map for concurrency and rx.interval for polling"
      contains: "flat_map, rx.interval, take_while"
    - path: "src/objlib/extraction/orchestrator.py"
      provides: "Extraction orchestrator with wave 1/2 logic as observable pipeline"
      contains: "concat_map"
  key_links:
    - from: "src/objlib/extraction/batch_orchestrator.py"
      to: "Mistral Batch API"
      via: "Observable polling loop: rx.interval(30s).pipe(take_while(not_done)) checks job status"
      pattern: "interval polling"
    - from: "src/objlib/extraction/orchestrator.py"
      to: "src/objlib/extraction/batch_orchestrator.py"
      via: "concat_map chains wave 1 completion into wave 2 start"
      pattern: "concat_map sequential waves"
---

<objective>
Migrate Tier 2 modules (Extraction Pipeline) from asyncio primitives to RxPY observables.

Medium complexity. Three distinct patterns to replace:

**Pattern A: Semaphore + gather fan-out**
Current: `asyncio.gather(*[process(item) for item in batch])` with `asyncio.Semaphore(N)`
guarding each coroutine. This is an eager fan-out where all items start concurrently but
are rate-limited by the semaphore.

RxPY target: `rx.from_iterable(batch).pipe(ops.flat_map(process_item, max_concurrent=N))`

The key difference: RxPY's flat_map lazily starts each item's observable only when a
concurrency slot opens, while asyncio.gather starts all items immediately (semaphore blocks
inside). Both produce the same effective concurrency — but flat_map is more backpressure-correct.

**Pattern B: AsyncLimiter (aiolimiter)**
Current: `async with rate_limiter:` inside each coroutine. Limits calls per second to the
Mistral API.

RxPY target: `ops.throttle_with_timeout(period_seconds)` or a custom rate-limit operator.
The 18-01 spike may have addressed this — use the confirmed approach from design_doc.md.

If throttle_with_timeout doesn't provide the exact semantics (it drops, not delays), use:
`ops.zip(rx.interval(period), observable).pipe(ops.map(lambda x: x[1]))` which delays each
item by at least `period` seconds.

**Pattern C: Polling loop (batch job completion)**
Current: `while not job.done: await asyncio.sleep(30); job = await check_status(job_id)`

RxPY target:
```python
rx.interval(30.0).pipe(
    ops.flat_map(lambda _: rx.from_callable(lambda: check_status(job_id))),
    ops.take_while(lambda job: not job.done, inclusive=True),
    ops.last()
)
```
Note: `inclusive=True` ensures the final `job.done=True` item is emitted before completion.

**Pattern D: Wave 1/2 checkpoint (concat_map)**
Current: Explicit sequential await between wave 1 (initial extraction) and wave 2 (validation/repair)
RxPY target: `wave1_obs.pipe(ops.concat_map(lambda results: wave2_obs(results)))`

This makes the sequential dependency explicit in the observable chain structure rather than
in the control flow.

**Verification gate:** Batch-extract smoke test must complete successfully. This is an end-to-end
test against the Mistral Batch API (or a mock), not just unit tests.
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/18-rxpy-codebase-wide-async-migration/18-CONTEXT.md
@.planning/phases/18-rxpy-codebase-wide-async-migration/18-02-SUMMARY.md
@spike/phase18_spike/design_doc.md
@src/objlib/extraction/batch_orchestrator.py
@src/objlib/extraction/orchestrator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Read and inventory extraction pipeline patterns</name>
  <files>src/objlib/extraction/batch_orchestrator.py, src/objlib/extraction/orchestrator.py</files>
  <action>
Read both files in full. Produce an inventory of every asyncio primitive:

For each site record:
- Pattern type (Semaphore, gather, AsyncLimiter, while+sleep polling, explicit await between waves)
- Line number and function name
- Concurrency value N (for Semaphore/gather)
- Rate limit value (for AsyncLimiter: calls/second)
- Polling interval (for while+sleep: seconds)

This inventory is the migration checklist for Tasks 2-4.

Also check: does either file import from state.py? (If so, those calls stay async — do not wrap them.)
  </action>
  <verify>
Inventory produced. All asyncio primitives identified with context.
  </verify>
  <done>
Inventory complete. Migration checklist ready.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate batch_orchestrator.py semaphore+gather and polling</name>
  <files>src/objlib/extraction/batch_orchestrator.py</files>
  <action>
Read `src/objlib/extraction/batch_orchestrator.py` in full before making any changes.

**Semaphore + gather → flat_map:**
```python
# Before:
sem = asyncio.Semaphore(MAX_CONCURRENT)
async def bounded(item):
    async with sem:
        return await process(item)
results = await asyncio.gather(*[bounded(item) for item in batch])

# After:
import rx
from rx import operators as ops
results = await rx.from_iterable(batch).pipe(
    ops.flat_map(lambda item: rx.from_callable(lambda: asyncio.run(process(item))),
                 max_concurrent=MAX_CONCURRENT)
).pipe(ops.to_list()).run()
```

**AsyncLimiter → rate-limit operator:**
Use the approach confirmed in 18-01 spike. If `zip(rx.interval(...), obs)` is the correct
approach, apply it here. The rate limit must match the original aiolimiter rate.

**Polling loop → rx.interval:**
```python
# Before:
while True:
    job = await check_batch_status(job_id)
    if job.status in ("DONE", "FAILED", "TIMEOUT"):
        break
    await asyncio.sleep(POLL_INTERVAL)

# After:
import rx
from rx import operators as ops
job = await rx.interval(POLL_INTERVAL).pipe(
    ops.flat_map(lambda _: rx.from_callable(lambda: asyncio.run(check_batch_status(job_id)))),
    ops.take_while(lambda j: j.status not in ("DONE", "FAILED", "TIMEOUT"), inclusive=True),
    ops.last()
).run()
```

Apply all three patterns. Do not change logic — only replace the control-flow primitives.
  </action>
  <verify>
1. `grep -n "asyncio.Semaphore\|asyncio.gather\|AsyncLimiter\|asyncio.sleep" src/objlib/extraction/batch_orchestrator.py` → 0 results
2. `grep -n "flat_map\|rx.interval\|take_while" src/objlib/extraction/batch_orchestrator.py` → results present
3. `python -c "from objlib.extraction.batch_orchestrator import BatchOrchestrator; print('OK')"` → OK
  </verify>
  <done>
batch_orchestrator.py migrated. All asyncio primitives replaced with RxPY operators.
  </done>
</task>

<task type="auto">
  <name>Task 3: Migrate extraction/orchestrator.py wave logic</name>
  <files>src/objlib/extraction/orchestrator.py</files>
  <action>
Read `src/objlib/extraction/orchestrator.py` in full before making any changes.

**Semaphore + AsyncLimiter → flat_map + rate-limit:**
Apply the same patterns as Task 2 (same Pattern A and B).

**Wave 1/2 sequential logic → concat_map:**
Locate the code that runs wave 1 extraction, then awaits its completion, then starts wave 2
validation/repair. Replace with:

```python
# Before:
wave1_results = await wave1_extraction()
if not wave1_results.errors:
    return wave1_results
wave2_results = await wave2_validation(wave1_results)
return wave2_results

# After:
result = await rx.from_callable(wave1_extraction).pipe(
    ops.concat_map(
        lambda wave1_results: (
            rx.of(wave1_results) if not wave1_results.errors
            else rx.from_callable(lambda: wave2_validation(wave1_results))
        )
    )
).run()
```

**Checkpoint logic:**
If the orchestrator writes checkpoint state to DB after each wave, wrap the checkpoint write
in a `do_action` (side effect) operator rather than a separate await:

```python
.pipe(
    ops.do_action(lambda results: write_checkpoint(results)),  # side effect
    ops.concat_map(lambda results: wave2_obs(results))
)
```
  </action>
  <verify>
1. `grep -n "asyncio.Semaphore\|asyncio.gather\|AsyncLimiter\|asyncio.sleep" src/objlib/extraction/orchestrator.py` → 0 results
2. `grep -n "concat_map\|flat_map\|do_action" src/objlib/extraction/orchestrator.py` → results present
3. `python -c "from objlib.extraction.orchestrator import ExtractionOrchestrator; print('OK')"` → OK
  </verify>
  <done>
extraction/orchestrator.py migrated. Wave logic replaced with concat_map pipeline.
  </done>
</task>

<task type="auto">
  <name>Task 4: Batch-extract smoke test and full pytest run</name>
  <files>src/objlib/extraction/batch_orchestrator.py, src/objlib/extraction/orchestrator.py</files>
  <action>
Run verification in two steps:

**Step 1: Unit tests**
```bash
python -m pytest tests/ -x -q
```
All tests must pass. If any extraction-related test fails, investigate and fix before Step 2.

**Step 2: Batch-extract smoke test**
Run a small batch extraction (2-3 files) to confirm the observable pipeline works end-to-end
against the Mistral Batch API:

```bash
python -m objlib metadata batch-extract --limit 3 --dry-run
```
(Use --dry-run or a test mode if available; if not, run with 3 files and verify the batch
job is submitted and polled correctly)

Verify:
- Batch job submitted without error
- Polling loop runs for the expected duration (rx.interval fires at the configured interval)
- Results written to DB correctly
- No RxPY subscription errors or scheduler conflicts

If the Mistral API is unavailable (offline), verify with the existing mock-based tests instead.
  </action>
  <verify>
1. `python -m pytest tests/ -x -q` → ALL PASS
2. Batch-extract smoke test completes without errors (or mock-based test passes)
3. No "Subject closed" or "Scheduler conflict" errors in output
  </verify>
  <done>
Tier 2 migration validated. Full pytest suite green. Batch-extract smoke test passed.
  </done>
</task>

<task type="auto">
  <name>Task 5: Produce SUMMARY</name>
  <files>.planning/phases/18-rxpy-codebase-wide-async-migration/18-03-SUMMARY.md</files>
  <action>
Create `.planning/phases/18-rxpy-codebase-wide-async-migration/18-03-SUMMARY.md` with:

- Files migrated: batch_orchestrator.py, orchestrator.py
- Pattern replacements by type:
  - Semaphore+gather → flat_map(max_concurrent=N): N occurrences, N value used
  - AsyncLimiter → rate-limit operator: approach used, rate value
  - Polling loop → rx.interval: interval value, take_while predicate
  - Wave checkpoint → concat_map: structure description
- Test results: full pytest pass count and duration
- Batch-extract smoke test results: job ID (if real API), item count, timing
- Any deviations from planned approach (with justification)
- Gate status: 18-04 UNBLOCKED
  </action>
  <verify>
18-03-SUMMARY.md exists with all sections complete.
  </verify>
  <done>
18-03 complete. Tier 2 migrated. SUMMARY written. 18-04 unblocked.
  </done>
</task>

</tasks>

<verification>
Phase 18 Plan 03 verification checklist:
1. `grep -rn "asyncio.Semaphore\|asyncio.gather\|AsyncLimiter" src/objlib/extraction/` → 0 results
2. `grep -rn "asyncio.sleep" src/objlib/extraction/` → 0 results (replaced by rx.interval)
3. `grep -rn "flat_map\|rx.interval\|concat_map" src/objlib/extraction/` → results in both files
4. `python -m pytest tests/ -x -q` → ALL PASS
5. Batch-extract smoke test (3 files) completes successfully
6. 18-03-SUMMARY.md documents all replacements with evidence
</verification>

<success_criteria>
- Zero asyncio concurrency primitives (Semaphore, gather, AsyncLimiter, sleep polling) in extraction/
- Polling loop uses rx.interval — no while+sleep pattern
- Wave sequential dependency expressed via concat_map — no explicit await between waves
- Batch-extract smoke test confirms observable pipeline works end-to-end with Mistral API
- 18-04 is unblocked
</success_criteria>

<output>
After completion, create `.planning/phases/18-rxpy-codebase-wide-async-migration/18-03-SUMMARY.md`
</output>
