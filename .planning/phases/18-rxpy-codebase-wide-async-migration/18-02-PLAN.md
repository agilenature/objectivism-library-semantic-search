---
phase: 18-rxpy-codebase-wide-async-migration
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - src/objlib/services/search.py
  - src/objlib/services/library.py
  - src/objlib/search/client.py
  - src/objlib/sync/orchestrator.py
autonomous: true

must_haves:
  truths:
    - "All asyncio.to_thread wrappers in services/search.py and services/library.py are replaced with rx.from_callable + observe_on(AsyncIOScheduler())"
    - "Tenacity @retry in search/client.py is replaced with RxPY retry operators using operator contracts from 18-01"
    - "sync/orchestrator.py light async usage migrated to observable pattern"
    - "Full pytest suite passes: no behavior regression from Tier 3 migration"
    - "aiosqlite internals in state.py are NOT touched in this plan (DB calls stay async, observables wrap them at a higher level)"
  artifacts:
    - path: "src/objlib/services/search.py"
      provides: "Search service using RxPY observable wrappers for thread dispatch"
      contains: "rx.from_callable"
    - path: "src/objlib/services/library.py"
      provides: "Library service using RxPY observable wrappers for thread dispatch"
      contains: "rx.from_callable"
    - path: "src/objlib/search/client.py"
      provides: "Search client with RxPY retry operators replacing tenacity @retry"
      contains: "retry_when"
  key_links:
    - from: "src/objlib/services/search.py"
      to: "src/objlib/search/client.py"
      via: "Observable chain: search service dispatches to search client"
      pattern: "observe_on(AsyncIOScheduler)"
    - from: "src/objlib/search/client.py"
      to: "Gemini File Search API"
      via: "retry_when with exponential backoff on transient errors"
      pattern: "RxPY retry_when replacing tenacity"
---

<objective>
Migrate Tier 3 modules (Services & Search) from asyncio primitives to RxPY observables.

This is the lowest-risk migration tier. The patterns are straightforward:
- `asyncio.to_thread(fn, *args)` → `rx.from_callable(lambda: fn(*args)).pipe(ops.observe_on(AsyncIOScheduler()))`
- Tenacity sync `@retry` → `retry_when` with exponential backoff observable

The guiding principle: callers see no change. The observable interface is internal to each
module. Public API signatures (return types) must remain unchanged — observables are
subscribed synchronously within the function body where needed for backward compatibility,
or the caller is updated to accept an observable if the call site is also being migrated
in the same plan.

**Scope boundary:** `state.py` aiosqlite internals are NOT touched here. Only the
thread-dispatch wrappers and retry decorators in the Tier 3 modules listed above.

**Operator contracts (from 18-01):**
Use the `AsyncIOScheduler` and `retry_when` patterns confirmed in the 18-01 spike.
Do not re-invent — reference `spike/phase18_spike/design_doc.md` Section 4 (Tier 3 guidelines).
</objective>

<execution_context>
@/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/18-rxpy-codebase-wide-async-migration/18-CONTEXT.md
@.planning/phases/18-rxpy-codebase-wide-async-migration/18-01-SUMMARY.md
@spike/phase18_spike/design_doc.md
@src/objlib/services/search.py
@src/objlib/services/library.py
@src/objlib/search/client.py
@src/objlib/sync/orchestrator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Inventory asyncio.to_thread sites in services/</name>
  <files>src/objlib/services/search.py, src/objlib/services/library.py</files>
  <action>
Read both files in full. Produce an inventory of every `asyncio.to_thread` call:
- File, line number, function name, the callable being dispatched, the return type
- Any `await` sites that receive the result (to understand call signature constraints)

For each to_thread call, determine:
1. Is the caller synchronous or async? (affects how observable is subscribed)
2. Does the function return the value to a TUI component, a CLI command, or another service?
3. Is there a test that exercises this code path?

This inventory becomes the migration checklist for Tasks 2 and 3.
  </action>
  <verify>
Inventory produced and written to stdout (or a temporary note). Counts match grep:
`grep -rn "asyncio.to_thread" src/objlib/services/`
  </verify>
  <done>
Inventory complete. All to_thread sites identified with call context.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate services/search.py to RxPY observe_on</name>
  <files>src/objlib/services/search.py</files>
  <action>
Read `src/objlib/services/search.py` in full before making any changes.

For each `asyncio.to_thread(fn, *args)` site:

Replace:
```python
result = await asyncio.to_thread(fn, arg1, arg2)
```

With:
```python
import rx
from rx import operators as ops
from rx.scheduler.eventloop import AsyncIOScheduler

scheduler = AsyncIOScheduler(asyncio.get_event_loop())
result = await rx.from_callable(
    lambda: fn(arg1, arg2), scheduler=scheduler
).pipe(
    ops.observe_on(scheduler)
).run()
```

**Note on run():** `Observable.run()` blocks until the observable completes and returns
the last emitted item. This is the correct pattern for backward-compatible replacement
of `await asyncio.to_thread(...)`.

If the module uses many to_thread calls, create a module-level helper:
```python
def _to_rx(fn, *args):
    """Run a synchronous function on the thread pool via RxPY observable."""
    scheduler = AsyncIOScheduler(asyncio.get_event_loop())
    return rx.from_callable(lambda: fn(*args), scheduler=scheduler).pipe(
        ops.observe_on(scheduler)
    )
```

Then each call site becomes:
```python
result = await _to_rx(fn, arg1, arg2).run()
```

**Critical:** Keep the public API signature identical. Return types must not change.
If the function currently returns `Optional[SearchResult]`, it must still return that
after migration — the observable is an implementation detail.
  </action>
  <verify>
1. `grep -n "asyncio.to_thread" src/objlib/services/search.py` → 0 results
2. `grep -n "rx.from_callable\|_to_rx\|observe_on" src/objlib/services/search.py` → N results (one per old to_thread site)
3. `python -m pytest tests/ -k "search" -x -q` → passes
4. `python -c "from objlib.services.search import SearchService; print('OK')"` → OK
  </verify>
  <done>
services/search.py migrated. All to_thread calls replaced. Tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Migrate services/library.py to RxPY observe_on</name>
  <files>src/objlib/services/library.py</files>
  <action>
Read `src/objlib/services/library.py` in full before making any changes.

Apply the same pattern as Task 2. Library has 6+ to_thread sites — use the `_to_rx`
helper pattern to avoid repetition.

Pay attention to:
- Any to_thread calls that are inside comprehensions or loops (may need rx.from_iterable + flat_map)
- Any to_thread calls that pass results to other async functions
- Error handling: if the wrapped function raises, the observable error must propagate correctly

After migration, verify behavior matches by running the existing tests.
  </action>
  <verify>
1. `grep -n "asyncio.to_thread" src/objlib/services/library.py` → 0 results
2. `python -m pytest tests/ -k "library" -x -q` → passes
3. `python -c "from objlib.services.library import LibraryService; print('OK')"` → OK
  </verify>
  <done>
services/library.py migrated. All 6+ to_thread calls replaced. Tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 4: Migrate search/client.py tenacity @retry to RxPY retry_when</name>
  <files>src/objlib/search/client.py</files>
  <action>
Read `src/objlib/search/client.py` in full before making any changes.

The sync `@retry` decorator from tenacity wraps the Gemini search API call. Replace with
the `retry_when` operator confirmed in the 18-01 spike.

Pattern (using contracts from spike/phase18_spike/design_doc.md):
```python
# Before (tenacity):
@retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=1, max=10))
def _call_gemini_search(self, query: str) -> GenerateContentResponse:
    ...

# After (RxPY):
def _call_gemini_search(self, query: str) -> GenerateContentResponse:
    def _attempt():
        return self._raw_gemini_call(query)

    return rx.from_callable(_attempt).pipe(
        ops.retry_when(
            lambda errors: errors.pipe(
                ops.scan(lambda count, e: count + 1, 0),
                ops.flat_map(
                    lambda n: rx.throw(Exception(f"Max retries ({n}) exceeded"))
                    if n > 3
                    else rx.timer(min(1.0 * (2 ** (n - 1)), 10.0))
                )
            )
        )
    ).run()
```

**Note:** If the search client is sync (not async), use `scheduler=CurrentThreadScheduler()`
instead of `AsyncIOScheduler`. Check the module before deciding.

**Critical:** The public `query()` method signature must remain unchanged.
  </action>
  <verify>
1. `grep -n "@retry\|from tenacity" src/objlib/search/client.py` → 0 results (tenacity removed)
2. `grep -n "retry_when\|rx.from_callable" src/objlib/search/client.py` → results present
3. `python -m pytest tests/ -k "search_client or client" -x -q` → passes
4. Import check: `python -c "from objlib.search.client import GeminiFileSearchClient; print('OK')"` → OK
  </verify>
  <done>
search/client.py migrated. Tenacity @retry replaced with rx retry_when. Tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 5: Migrate sync/orchestrator.py and run full test suite</name>
  <files>src/objlib/sync/orchestrator.py</files>
  <action>
Read `src/objlib/sync/orchestrator.py` in full.

Apply the same observable patterns as Tier 3 guidelines from design_doc.md.
The sync orchestrator likely has light async usage (a few awaits, possibly to_thread calls).
Migrate each to the appropriate RxPY pattern.

After migration, run the **full** pytest suite:
```bash
python -m pytest tests/ -x -q
```

All tests must pass. If any fail, investigate root cause before proceeding — do not
suppress or skip tests.

Also run a quick smoke test:
```bash
python -m objlib status
python -m objlib --store objectivism-library search "Rand on epistemology"
```

Both commands must complete without errors.
  </action>
  <verify>
1. `grep -n "asyncio.to_thread" src/objlib/sync/orchestrator.py` → 0 results
2. `python -m pytest tests/ -x -q` → ALL PASS
3. `python -m objlib status` → exits 0
4. Search command returns results without errors
  </verify>
  <done>
sync/orchestrator.py migrated. Full test suite green. Tier 3 migration complete.
  </done>
</task>

<task type="auto">
  <name>Task 6: Produce SUMMARY</name>
  <files>.planning/phases/18-rxpy-codebase-wide-async-migration/18-02-SUMMARY.md</files>
  <action>
Create `.planning/phases/18-rxpy-codebase-wide-async-migration/18-02-SUMMARY.md` with:

- Files migrated: list each file with the count of to_thread/retry calls replaced
- Pattern used for each: _to_rx helper, retry_when variant, etc.
- Test results: full pytest output (pass count, duration)
- Any surprises or deviations from the CONTEXT.md plan (document if approach differed)
- Gate status: 18-03 UNBLOCKED
- Remaining tenacity dependencies: does `requirements.txt` still need tenacity after this plan?
  (Only if Tier 1/2 still use it — do not remove until 18-04 is complete)
  </action>
  <verify>
18-02-SUMMARY.md exists with all sections complete.
  </verify>
  <done>
18-02 complete. Tier 3 migrated. SUMMARY written. 18-03 unblocked.
  </done>
</task>

</tasks>

<verification>
Phase 18 Plan 02 verification checklist:
1. `grep -rn "asyncio.to_thread" src/objlib/services/ src/objlib/search/ src/objlib/sync/` → 0 results
2. `grep -rn "@retry" src/objlib/search/client.py` → 0 results (tenacity removed from this file)
3. `python -m pytest tests/ -x -q` → ALL PASS (no regressions from Tier 3 migration)
4. `python -m objlib --store objectivism-library search "Rand"` → results returned without error
5. 18-02-SUMMARY.md documents all 4 files migrated with evidence
</verification>

<success_criteria>
- Zero behavior change: all test assertions still pass, search results identical to pre-migration
- No asyncio.to_thread calls in Tier 3 modules
- No tenacity @retry in search/client.py
- Public API signatures unchanged
- 18-03 is unblocked (go/no-go from 18-02 results)
</success_criteria>

<output>
After completion, create `.planning/phases/18-rxpy-codebase-wide-async-migration/18-02-SUMMARY.md`
</output>
