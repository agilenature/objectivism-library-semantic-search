# Codebase Structure

**Analysis Date:** 2026-02-15

## Directory Layout

```
objectivism-library-semantic-search/
├── README.md                          # System overview and philosophy
├── QUICK_START.md                     # Get running in 30 minutes
├── METADATA_SCHEMA.md                 # Complete metadata specification
├── IMPLEMENTATION_PLAN.md             # Detailed implementation guide
├── PROJECT_SUMMARY.md                 # Project summary and use cases
│
├── config/
│   └── library_config.json            # Configuration: paths, batch sizes, keywords
│
├── src/
│   ├── 01_scan_library.py            # Phase 1: Scan & extract metadata
│   ├── 02_upload_to_gemini.py        # Phase 2: Upload to Gemini corpus
│   └── 03_query_interface.py         # Phase 3: Query system & synthesis
│
├── examples/
│   └── example_queries.py             # 8 example queries demonstrating capabilities
│
└── .planning/
    └── codebase/                      # GSD analysis output directory
        ├── ARCHITECTURE.md            # Architecture analysis
        └── STRUCTURE.md               # This file
```

## Directory Purposes

**Root Directory:**
- Purpose: Project documentation and entry point
- Contains: Markdown documentation, quick start guides, implementation plans
- Key files: `README.md` (overview), `QUICK_START.md` (30-minute setup), `PROJECT_SUMMARY.md` (use cases)

**config/:**
- Purpose: Centralized configuration for all pipeline phases
- Contains: Configuration templates and runtime settings
- Key files: `library_config.json` (library paths, exclusion patterns, batch sizes, metadata enrichment rules)

**src/:**
- Purpose: Core pipeline implementation
- Contains: Three executable Python scripts implementing the scan-upload-query pipeline
- Key files: Three main scripts (`01_scan_library.py`, `02_upload_to_gemini.py`, `03_query_interface.py`)

**examples/:**
- Purpose: Demonstration of system capabilities
- Contains: Working code examples showing typical query patterns
- Key files: `example_queries.py` (8 runnable examples)

**.planning/codebase/:**
- Purpose: GSD analysis output (generated by mapping process)
- Contains: Documentation about codebase structure, architecture, conventions, testing, concerns

## Key File Locations

**Entry Points:**

1. `src/01_scan_library.py` - Library scanning (Phase 1)
   - Main class: `LibraryScanner`
   - Main function: `main()` with argparse CLI
   - Usage: `python src/01_scan_library.py --verbose --library-root /path/to/library`

2. `src/02_upload_to_gemini.py` - Gemini upload (Phase 2)
   - Main class: `GeminiUploader`
   - Main function: `main()` with argparse CLI
   - Usage: `python src/02_upload_to_gemini.py --batch-size 100 --resume`

3. `src/03_query_interface.py` - Query interface (Phase 3)
   - Main class: `ObjectivismLibrary`
   - Main function: `main()` with argparse CLI
   - Usage: `python src/03_query_interface.py --query "your question"` or `--interactive`

**Configuration:**
- `config/library_config.json` - All configuration centralized here
  - Library root path
  - File extensions to scan (`.txt`)
  - Excluded patterns (`.claude`, `.git`, `.DS_Store`)
  - Batch sizes, retry attempts
  - Known instructors and branch keywords
  - Metadata enrichment rules

**Data Files (Generated):**
- `data/library_catalog.json` - Output of Phase 1 (comprehensive file metadata)
- `data/upload_state_objectivism-library-v1.json` - State file for Phase 2 resumption
- `output/*.md` - Synthesis documents generated by Phase 3

## Naming Conventions

**Files:**
- Phase scripts: `{NN}_{description}.py` where NN is phase number (01, 02, 03)
- Configuration: `*_config.json` in `config/` directory
- Data files: `*_catalog.json` and `upload_state_*.json` in `data/` directory
- Examples: `example_*.py` in `examples/` directory

**Classes:**
- PascalCase: `LibraryScanner`, `GeminiUploader`, `ObjectivismLibrary`
- Utility/helper classes: Purpose-clear names like `GeminiUploader` (not generic like `Uploader`)

**Functions:**
- snake_case for methods and functions
- Public methods: `search()`, `upload_file()`, `extract_metadata_from_path()`
- Private methods: prefixed with underscore `_build_metadata_filter()`, `_flatten_dict()`

**Variables:**
- snake_case: `library_root`, `file_path`, `batch_size`, `catalog`
- Constants/config: UPPER_CASE (though used minimally; config in JSON instead)
- Metadata keys: Use dot-notation in flattened form for Gemini (`intellectual.title`, `pedagogical_structure.course_sequence.year`)

**Directories:**
- lowercase with underscores: `src/`, `config/`, `examples/`, `.planning/codebase/`
- Organized by function (not by file type)

## Where to Add New Code

**New Query Mode:**
- **Implementation**: Add method to `ObjectivismLibrary` class in `src/03_query_interface.py`
  - Example pattern: `def new_mode(self, ...params...) -> ...: ...`
  - Add handling in `main()` function with new argparse argument
  - Follow existing pattern: search → format results → return to user
- **Tests**: Add test method to test suite (if tests exist)

**New Metadata Extractor (for new content type):**
- **Implementation**: Add new method to `LibraryScanner` in `src/01_scan_library.py`
  - Pattern: `def extract_[category]_metadata(self, parts: tuple, filename: str, metadata: Dict)`
  - Call from `extract_metadata_from_path()` based on category detection
  - Populate relevant metadata sections (instructional, pedagogical_structure, temporal, etc.)
- **Configuration**: Add category patterns to `config/library_config.json` if needed

**New Configuration Setting:**
- **Location**: `config/library_config.json` (centralized)
- **Usage**: Load in scripts with `json.load(f)` and pass to relevant class constructors
- **Pattern**: Follow existing structure (separate sections for upload_settings, query_settings, etc.)

**New Utility Functions:**
- **Location**: Add to appropriate phase file or create `src/utils/` module if substantial
- **Pattern**: Keep utilities close to where they're used; only extract to shared location if used by multiple phases

**New Example:**
- **Location**: `examples/example_queries.py`
- **Pattern**: Demonstrate typical usage pattern with comments explaining what's being done
- **Structure**: Create `ObjectivismLibrary`, run example command, show expected output

## Special Directories

**src/ (Active Code):**
- Purpose: Executable pipeline stages
- Generated: No (all hand-written)
- Committed: Yes (core implementation)
- Three main scripts orchestrate the entire workflow

**config/ (Configuration):**
- Purpose: Runtime configuration centralized in JSON
- Generated: No (templates provided, users customize)
- Committed: Yes (templates with examples)
- Load patterns: Each script loads JSON and passes config to relevant class

**examples/ (Demonstration):**
- Purpose: Show system capabilities and typical usage patterns
- Generated: Output files created by running examples (synthesis docs)
- Committed: Yes (example code)
- Runnable: `python examples/example_queries.py`

**data/ (Generated State):**
- Purpose: Intermediate and state files
- Generated: Yes (created by Phase 1 and Phase 2)
- Committed: No (gitignored)
- Contents: `library_catalog.json` (all file metadata), `upload_state_*.json` (resumable progress)

**output/ (Generated Results):**
- Purpose: Synthesis documents and query results saved to disk
- Generated: Yes (created by Phase 3 synthesis commands)
- Committed: No (gitignored)
- Contents: `*.md` synthesis documents

**.planning/codebase/ (Analysis Output):**
- Purpose: GSD mapping analysis documents
- Generated: Yes (by `/gsd:map-codebase` orchestrator)
- Committed: Yes (reference documentation)
- Contains: ARCHITECTURE.md, STRUCTURE.md, CONVENTIONS.md, TESTING.md, CONCERNS.md

## File Dependencies

```
01_scan_library.py
  ├─ config/library_config.json      (input - configuration)
  ├─ /Volumes/U32 Shadow/Objectivism Library/  (input - live library)
  └─ data/library_catalog.json       (output - all file metadata)

02_upload_to_gemini.py
  ├─ data/library_catalog.json       (input - from Phase 1)
  ├─ config/library_config.json      (input - configuration)
  ├─ /Volumes/U32 Shadow/Objectivism Library/  (input - actual files)
  ├─ Gemini File API                  (external service)
  └─ data/upload_state_*.json        (state file - for resumption)

03_query_interface.py
  ├─ Gemini API / Corpus              (external service - indexed data)
  ├─ config/library_config.json      (input - optional configuration)
  ├─ examples/example_queries.py     (optional - imports to demonstrate)
  └─ output/*.md                      (output - synthesis documents)
```

## Code Organization Principles

**Single Responsibility:** Each script has one primary phase
- `01_scan_library.py` → Extract metadata from filesystem
- `02_upload_to_gemini.py` → Index in Gemini
- `03_query_interface.py` → Search and synthesize

**Configuration Over Code:** Settings in `config/library_config.json`, not hardcoded
- Batch sizes, retry attempts, branch keywords, instructor mappings

**Metadata-First:** Rich metadata enables powerful queries
- 10+ metadata sections extracted for every file
- Enables semantic search + structured navigation + concept tracking

**Stateful Uploads:** Resume capability prevents reprocessing
- Phase 2 saves state every N files
- Can interrupt and resume without re-uploading

**Multiple Query Modes:** Same backend, different interfaces
- CLI commands, Python API, interactive mode
- Each mode built on core `ObjectivismLibrary` methods

---

*Structure analysis: 2026-02-15*
